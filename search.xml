<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go基础篇-切片</title>
      <link href="/article/daa1d97.html"/>
      <url>/article/daa1d97.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-序"><a href="#1-序" class="headerlink" title="1 序"></a>1 序</h2><hr><p>在Go语言中，切片是对数组的一个引用，它是一个动态长度的序列。切片的使用更加灵活，通常在实际开发中更常用。</p><h2 id="2-切片特点"><a href="#2-切片特点" class="headerlink" title="2 切片特点"></a>2 切片特点</h2><p>数组是一种固定长度的数据结构，用于存储相同类型的元素序列。声明数组时，需要指定其长度，这意味着数组的大小在创建后不可更改。数组的索引从0开始，提供了快速访问元素的方式。然而，由于其固定长度的特性，数组在某些场景下的灵活性受到限制。<br>数组具有以下特点：</p><ul><li>数组里数据是相同类型数据</li><li>数组中元素可以是任意的原始类型，比如int、string等</li><li>一个数组中元素的个数被称为数组长度</li><li>数组的长度属于类型一部分，也就是[5]int和[10]int属于不同类型</li><li>数组占用内存连续性，也就是数组中的元素被分配到连续内存地址中，因而索引数组元素速度非常快。</li></ul><h2 id="3-定义切片"><a href="#3-定义切片" class="headerlink" title="3 定义切片"></a>3 定义切片</h2><p>Go语言中，数组的声明和实现可以通过以下方式进行：</p><p>1.var关键字申明<br>在Go语言中，可以使用var关键字来声明一个数组。数组的声明语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayName [size]dataType</span><br></pre></td></tr></table></figure><p>其中，arrayName是数组的名称，size是数组的大小, 而且size是必须要指定的，dataType是数组中元素的数据类型。</p><p>例如，声明一个包含5个整数的数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers [<span class="number">5</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><p>在这个例子中，数组的名称是numbers，大小为5个整数元素，即[5]int。</p><p>声明完该数组，我们可以后面再针对该数组进行赋值。一般是直接用{}大括号赋值，或者通过索引设置数组元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>2.声明并初始化数组</p><p>在声明数组的同时，可以使用大括号{}来初始化数组的元素。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化值</span></span><br><span class="line"><span class="keyword">var</span> numbers1 [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 数组大小可以根据数组内容自动推断</span></span><br><span class="line"><span class="keyword">var</span> numbers2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>或者可以使用简化的声明和初始化方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化值</span></span><br><span class="line">numbers1 := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//  数组大小可以根据数组内容自动推断</span></span><br><span class="line">numbers2 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>这样，数组numbers就被声明并初始化为包含元素1到5的整数数组。</p><h3 id="3-2-访问数组元素"><a href="#3-2-访问数组元素" class="headerlink" title="3.2 访问数组元素"></a>3.2 访问数组元素</h3><p>可以通过索引来访问数组中的元素。索引从0开始，逐个递增。例如，要访问上面声明的数组numbers的第一个元素，可以使用numbers[0]。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  first := numbers[<span class="number">0</span>]</span><br><span class="line">  fmt.Println(<span class="string">&quot;first ele: &quot;</span>, first)  <span class="comment">// Output: first ele: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以通过<code>len()</code>和<code>cap()</code>函数计算数组的长度和容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;值=%d，长度=%d，容量=%d\n&quot;</span>, numbers, <span class="built_in">len</span>(numbers), <span class="built_in">cap</span>(numbers))  <span class="comment">// Output: 值=[1 2 3 4 5]，长度=5，容量=5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-数组遍历"><a href="#3-3-数组遍历" class="headerlink" title="3.3 数组遍历"></a>3.3 数组遍历</h3><p>有两种主要的方法可以遍历Go中的数组。你可以使用传统的<code>for</code>循环，也可以使用<code>range</code>关键字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(numbers); i++ &#123;</span><br><span class="line">      fmt.Println(numbers[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过range关键字遍历数组:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> index, value := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Index: %d, Value: %d\n&quot;</span>, index, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要使用索引，可以通过下划线’_’代替：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> _, value := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">      fmt.Println(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-修改数组元素"><a href="#3-4-修改数组元素" class="headerlink" title="3.4 修改数组元素"></a>3.4 修改数组元素</h3><p>可以通过索引来修改数组中的元素。例如，要将上面声明的数组numbers的第一个元素修改为0，可以使用numbers[0] &#x3D; 0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  numbers[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  fmt.Println(numbers)   <span class="comment">// Output: [0,2,3,4,5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-删除数组元素"><a href="#3-5-删除数组元素" class="headerlink" title="3.5 删除数组元素"></a>3.5 删除数组元素</h3><p>在Go中，数组的长度是固定的，因此无法直接删除或调整数组的大小。如果需要删除数组中的元素，可以使用切片来实现类似的效果。</p><h3 id="3-6-数组的复制"><a href="#3-6-数组的复制" class="headerlink" title="3.6 数组的复制"></a>3.6 数组的复制</h3><p>在Go语言中，数组是<strong>值类型（value type）</strong>。</p><p>当你将一个数组赋值给另一个变量时，会复制整个数组的内容，而不是复制对数组的引用。这意味着对一个数组的修改不会影响到另一个数组，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  arr2 := arr1 <span class="comment">// 复制arr1到arr2</span></span><br><span class="line">  arr1[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// 修改arr1的第一个元素</span></span><br><span class="line">  fmt.Println(arr1) <span class="comment">// 输出 [10 2 3]</span></span><br><span class="line">  fmt.Println(arr2) <span class="comment">// 输出 [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，虽然修改了arr1的第一个元素，但arr2并不受影响，因为在赋值时是将arr1的内容复制给了arr2，它们是完全独立的数组。<br>当你把一个数组作为参数传给函数，然后在函数中修改数组的其中一个元素，这并不会改变原数组的值，因为参数实际上是该数组的副本，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  arr2 := changeEle(arr1) <span class="comment">// 复制arr1到arr2</span></span><br><span class="line">  fmt.Println(arr1) <span class="comment">// 输出 [1 2 3]</span></span><br><span class="line">  fmt.Println(arr2) <span class="comment">// 输出 [10 2 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数组第一个元素的值为10，并返回修改后的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeEle</span><span class="params">(array [3]<span class="type">int</span>)</span></span> [<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片（Slice）：<br>在Go语言中，切片是对数组的一个引用，它是一个动态长度的序列。切片的使用更加灵活，通常在实际开发中更常用。可以通过以下方式声明和初始化一个切片：</p><p>go<br>var slice &#x3D; []int{1, 2, 3, 4, 5}<br>这将声明并初始化一个包含元素1到5的整数切片。可以使用切片的索引来访问和修改其中的元素，与数组类似。切片的长度是动态的，可以根据需要扩展或缩小。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复合类型 </tag>
            
            <tag> Golang </tag>
            
            <tag> 切片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础篇-数组</title>
      <link href="/article/daa1d97.html"/>
      <url>/article/daa1d97.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-序"><a href="#1-序" class="headerlink" title="1 序"></a>1 序</h2><hr><p>在Go语言中，数组是数据管理中至关重要的组件。它们作为核心数据结构，为开发者提供了灵活性、性能和便利性，本文将带您了解Go语言复合数据类型的数组。并深入探讨它的特性、用法和常见操作。</p><p>在使用数组的时候，我们会使用一些函数来实现，这里我们将介绍Go语言中的内置函数。</p><h2 id="2-内置函数"><a href="#2-内置函数" class="headerlink" title="2 内置函数"></a>2 内置函数</h2><p>Go语言提供了一些内置函数（Built-in Functions），这些函数是在编译器中实现的，并且可以直接使用，无需导入任何包。以下是一些常用的Go内置函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">len</span>()： 返回字符串、数组、切片、字典或通道的长度。</span><br><span class="line"><span class="number">2.</span> <span class="built_in">cap</span>()： 返回数组、切片或通道的容量。</span><br><span class="line"><span class="number">3.</span> <span class="built_in">make</span>()： 用于创建切片、映射或通道。</span><br><span class="line"><span class="number">4.</span> <span class="built_in">new</span>()： 用于创建某种类型的指针，并返回其地址。</span><br><span class="line"><span class="number">5.</span> <span class="built_in">append</span>()： 用于向切片追加元素，可以同时追加一个或多个元素。</span><br><span class="line"><span class="number">6.</span> <span class="built_in">copy</span>()： 用于将源 slice 的元素复制到目标 slice，并返回复制的元素个数。</span><br><span class="line"><span class="number">7.</span> <span class="built_in">delete</span>()： 用于从字典中删除指定键的元素。</span><br><span class="line"><span class="number">8.</span> <span class="built_in">close</span>()： 用于关闭通道。</span><br><span class="line"><span class="number">9.</span> <span class="built_in">panic</span>()和<span class="built_in">recover</span>()： 用于处理错误和异常情况。</span><br><span class="line"><span class="number">10.</span> <span class="built_in">print</span>()和<span class="built_in">println</span>()： 用于在控制台打印输出。</span><br></pre></td></tr></table></figure><p>除了以上列出的内置函数，Go语言还提供了其他很多有用的内置函数，涵盖了各种操作和功能，例如类型转换、数学计算、字符串处理等。你可以通过查看官方文档来获取完整的内置函数列表和详细的使用说明。</p><blockquote><p>需要注意的是，虽然这些函数是内置的，但它们也可以被重新定义为普通的标识符。所以，如果你在自己的代码中使用了跟内置函数同名的标识符，那么内置函数将会被覆盖。</p></blockquote><h2 id="3-数组底层原理"><a href="#3-数组底层原理" class="headerlink" title="3 数组底层原理"></a>3 数组底层原理</h2><p>在Go语言中，数组是一种值类型。当你创建一个数组时，Go会在内存中为该数组分配一个连续的内存块，每个元素都占据该内存块中的一部分。数组中的每个元素都可以通过其索引直接访问。因为这种内存布局，数组的访问速度非常快。</p><p>下面是一个简单的图解，展示了一个长度为3，元素类型为int的数组在内存中的布局。</p><table><thead><tr><th align="center">内存地址</th><th align="center">0x00</th><th align="center">0x04</th><th align="center">0x08</th></tr></thead><tbody><tr><td align="center">索引</td><td align="center">0</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">值</td><td align="center">arr[0]</td><td align="center">arr[1]</td><td align="center">arr[2]</td></tr></tbody></table><p>当你将一个数组赋值给另一个数组时，Go会创建一个新的内存块，并将原数组的所有元素值复制到新的内存块。这就是为什么说Go中的数组是值类型，而不是引用类型。这也意味着如果你在函数中修改了一个数组，原数组不会被修改，除非你使用指针或者切片。</p><h2 id="4-数组特点"><a href="#4-数组特点" class="headerlink" title="4 数组特点"></a>4 数组特点</h2><p>数组是一种固定长度的数据结构，用于存储相同类型的元素序列。声明数组时，需要指定其长度，这意味着数组的大小在创建后不可更改。数组的索引从0开始，提供了快速访问元素的方式。然而，由于其固定长度的特性，数组在某些场景下的灵活性受到限制。</p><p>数组具有以下特点：</p><ul><li>数组长度不可变，且它不是引用类型。</li><li>数组里数据是相同类型数据。</li><li>数组中元素可以是任意的原始类型，比如int、string等。</li><li>一个数组中元素的个数被称为数组长度。</li><li>数组的长度属于类型一部分，也就是[5]int和[10]int属于不同类型。</li><li>数组占用内存连续性，也就是数组中的元素被分配到连续内存地址中，因而索引数组元素速度非常快。</li></ul><h2 id="5-定义数组"><a href="#5-定义数组" class="headerlink" title="5 定义数组"></a>5 定义数组</h2><p>Go语言中，数组的声明和实现可以通过以下方式进行：</p><h3 id="5-1-var关键字声明"><a href="#5-1-var关键字声明" class="headerlink" title="5.1 var关键字声明"></a>5.1 var关键字声明</h3><p>在Go语言中，可以使用var关键字来声明一个数组。数组的声明语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayName [size]dataType</span><br></pre></td></tr></table></figure><p>其中，arrayName是数组的名称，size是数组的大小, 而且size是必须要指定的，dataType是数组中元素的数据类型。</p><p>例如，声明一个包含5个整数的数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers [<span class="number">5</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><p>在这个例子中，数组的名称是numbers，大小为5个整数元素，即[5]int。</p><p>声明完该数组，我们可以后面再针对该数组进行赋值。一般是直接用{}大括号赋值，或者通过索引设置数组元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 直接通过&#123;&#125;大括号实现</span></span><br><span class="line">numbers = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 或者通过索引依次赋值</span></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">numbers[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">numbers[<span class="number">4</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="5-2-声明并初始化数组"><a href="#5-2-声明并初始化数组" class="headerlink" title="5.2 :&#x3D;声明并初始化数组"></a>5.2 :&#x3D;声明并初始化数组</h3><p>在声明数组的同时，可以使用大括号{}来初始化数组的元素。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化值</span></span><br><span class="line"><span class="keyword">var</span> numbers [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>或者可以使用简化的声明和初始化方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化值</span></span><br><span class="line">numbers := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>如果你不确定数组的长度，可以让Go编译器自动计算数组的长度，在初始化的时候，可以使用 <strong>…</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组大小可以根据数组内容自动推断</span></span><br><span class="line"><span class="keyword">var</span> numbers1 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 数组大小可以根据数组内容自动推断</span></span><br><span class="line">numbers2 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>这样，数组numbers就被声明并初始化为包含元素1到5的整数数组。</p><h2 id="6-访问数组"><a href="#6-访问数组" class="headerlink" title="6 访问数组"></a>6 访问数组</h2><p>可以通过索引来访问数组中的元素。索引从0开始，逐个递增。例如，要访问上面声明的数组numbers的第一个元素，可以使用<code>numbers[0]</code>。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  first := numbers[<span class="number">0</span>]</span><br><span class="line">  fmt.Println(<span class="string">&quot;First element: &quot;</span>, first)  <span class="comment">// Output: First element: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以通过<code>len()</code>和<code>cap()</code>函数计算数组的长度和容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Value=%d，Length=%d，Capacity=%d\n&quot;</span>, numbers, <span class="built_in">len</span>(numbers), <span class="built_in">cap</span>(numbers))  <span class="comment">// Output: Value=[1 2 3 4 5]，Length=5，Capacity=5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-遍历数组"><a href="#7-遍历数组" class="headerlink" title="7 遍历数组"></a>7 遍历数组</h2><p>有两种主要的方法可以遍历Go中的数组。你可以使用传统的<code>for</code>循环，也可以使用<code>range</code>关键字。</p><h3 id="7-1-For关键字遍历"><a href="#7-1-For关键字遍历" class="headerlink" title="7.1 For关键字遍历"></a>7.1 For关键字遍历</h3><p>首先可以通过for关键字遍历，其中需要借助<code>len()</code>函数计算数组长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(numbers); i++ &#123;</span><br><span class="line">      fmt.Println(numbers[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Range关键字遍历"><a href="#7-2-Range关键字遍历" class="headerlink" title="7.2 Range关键字遍历"></a>7.2 Range关键字遍历</h3><p>也可以通过range关键字遍历数组，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> index, value := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Index: %d, Value: %d\n&quot;</span>, index, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要使用索引，可以通过下划线’_’代替：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> _, value := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">      fmt.Println(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常来说，我们使用<code>for range</code>方式迭代可能会好一点，因为这种迭代可以保证不会出现数组越界的情况，每次迭代对数组的访问可以省略对下标越界判断，当然具体使用，因实际情况不同而不同。</p><h2 id="8-修改数组元素"><a href="#8-修改数组元素" class="headerlink" title="8 修改数组元素"></a>8 修改数组元素</h2><p>可以通过索引来修改数组中的元素。例如，要将上面声明的数组numbers的第一个元素修改为0，可以使用<code>numbers[0] = 0</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  numbers := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  numbers[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  fmt.Println(numbers)   <span class="comment">// Output: [0,2,3,4,5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你把一个数组作为参数传给函数，然后在函数中修改数组的其中一个元素，这并不会改变原数组的值，因为参数值实际上是该数组的副本，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  arr2 := changeElement(arr1) <span class="comment">// 修改数组元素</span></span><br><span class="line">  fmt.Println(arr1) <span class="comment">// Output: [1 2 3]</span></span><br><span class="line">  fmt.Println(arr2) <span class="comment">// Output: [10 2 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数组第一个元素的值为10，并返回修改后的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeElement</span><span class="params">(array [3]<span class="type">int</span>)</span></span> [<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要想在函数中修改数组的值，可以通过指针实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  arr2 := changeElement(&amp;arr1) <span class="comment">// 修改数组元素</span></span><br><span class="line">  fmt.Println(arr1) <span class="comment">// Output: [10 2 3]</span></span><br><span class="line">  fmt.Println(arr2) <span class="comment">// Output: [10 2 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数组第一个元素的值为10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeElement</span><span class="params">(array *[3]<span class="type">int</span>)</span></span> [<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">  <span class="comment">// 获取第一个元素的地址</span></span><br><span class="line">  ptr := &amp;array[<span class="number">0</span>]</span><br><span class="line">  fmt.Println(<span class="string">&quot;第一个元素值为:&quot;</span>, *ptr) <span class="comment">// 通过指针访问元素的值 Output: 第一个元素值为: 1</span></span><br><span class="line">  <span class="comment">// 通过指针修改数组元素的值</span></span><br><span class="line">  *ptr = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> *array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-数组的复制"><a href="#9-数组的复制" class="headerlink" title="9 数组的复制"></a>9 数组的复制</h2><p>在Go语言中，数组是<strong>值类型</strong>。当你将一个数组赋值给另一个变量时，会复制整个数组的内容，而不是复制对数组的引用。这意味着对一个数组的修改不会影响到另一个数组，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  arr2 := arr1 <span class="comment">// 复制arr1到arr2</span></span><br><span class="line">  arr1[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// 修改arr1的第一个元素</span></span><br><span class="line">  fmt.Println(arr1) <span class="comment">// Output: [10 2 3]</span></span><br><span class="line">  fmt.Println(arr2) <span class="comment">// Output: [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，虽然修改了arr1的第一个元素，但arr2并不受影响，因为在赋值时是将arr1的内容复制给了arr2，它们是完全独立的数组。</p><h2 id="10-数组比较"><a href="#10-数组比较" class="headerlink" title="10 数组比较"></a>10 数组比较</h2><p>在go语言中，可以使用比较运算符“&#x3D;&#x3D;”或“!&#x3D;”来进行数组比较，判断两个数组是否相等。</p><blockquote><p>注意：只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 通过 == 来比较数组</span></span><br><span class="line">  arr1 := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Ratel&quot;</span>&#125;</span><br><span class="line">  arr2 := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Ratel&quot;</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;arr1 == arr2 &quot;</span>, arr1 == arr2)  <span class="comment">// Output: arr1 == arr2  true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-1-数组长度不同"><a href="#10-1-数组长度不同" class="headerlink" title="10.1 数组长度不同"></a>10.1 数组长度不同</h3><p>根据数组特点我们知道，即便是元素类型相同，数组长度只要不同，编译器都认为这是两种不同的数据类型，所以数组无法通过&#x3D;&#x3D;比较，编译器会直接报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 数组长度不同，不可以通过 == 来比较数组</span></span><br><span class="line">  arr1 := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Ratel&quot;</span>, <span class="string">&quot;Wu&quot;</span>&#125;</span><br><span class="line">  arr2 := [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Ratel&quot;</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;arr1 == arr2 &quot;</span>, arr1 == arr2) </span><br><span class="line">  <span class="comment">// invalid operation: arr1 == arr2 (mismatched types [3]string and [2]string)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-数组元素类型不同"><a href="#10-2-数组元素类型不同" class="headerlink" title="10.2 数组元素类型不同"></a>10.2 数组元素类型不同</h3><p>如果数组的长度相同，数据类型不同，编译器同样认为这是两种不同的数据类型，所以数组也无法通过&#x3D;&#x3D;比较，编译器会直接报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 数组元素数据类型不同，不可以通过 == 来比较数组</span></span><br><span class="line">  arr1 := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">  arr2 := [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Ratel&quot;</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;arr1 == arr2 &quot;</span>, arr1 == arr2) </span><br><span class="line">  <span class="comment">// invalid operation: arr1 == arr2 (mismatched types [2]int and [2]string)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11 总结"></a>11 总结</h2><blockquote><p>需要注意的是，在Go中数组的长度是固定的，因此无法直接删除或调整数组的大小。如果需要删除数组中的元素，可以使用切片来实现类似的效果，我们将在下一章节中介绍。</p></blockquote><p>在Go语言中，数组类型是非常重要的类型，数组本身的赋值和函数传参都是通过复制的方式处理的，理解数组的底层原理有助于更好的使用数组，但是Go语言中很少直接使用数组，原因就是不同长度的数组因为类型不同无法直接赋值，我们下章节将介绍切片，具体看看切片的操作使用，欢迎阅读。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复合类型 </tag>
            
            <tag> Golang </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础篇-关键字|变量|常量|基本数据类型</title>
      <link href="/article/3a64c617.html"/>
      <url>/article/3a64c617.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-序"><a href="#1-序" class="headerlink" title="1 序"></a>1 序</h2><p><img src="/img/cover/go_index1.png" alt="图片"></p><hr><p>在计算机编程中，数据类型是一种基础概念，它定义了数据的特性、存储方式以及可以对其执行的操作。数据类型的正确选择和使用对于编写高效、可靠的代码至关重要。Go语言作为一门现代化、简洁而强大的编程语言，提供了丰富的数据类型，使得开发人员能够更好地控制和操作数据。</p><p>本文将带您踏上一段探索Go语言基本数据类型的奇妙之旅。我们将深入探讨Go语言中的布尔型、整数型、浮点型和字符串型等基本数据类型的特性、用法和常见操作。</p><p>变量就是承载各种数据类型的容器，变量的定义又离不开关键字，所以我们先看Go的关键字。</p><h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2 关键字"></a>2 关键字</h2><p>Go语言具有一些关键字（Keywords），这些关键字具有特殊的含义，不能作为标识符来使用，以下是Go语言中的关键字列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>：用于在循环中跳出循环或在<span class="keyword">switch</span>语句中跳出<span class="keyword">switch</span>语句。</span><br><span class="line"><span class="keyword">case</span>：用于在<span class="keyword">switch</span>语句中分支选择。</span><br><span class="line"><span class="keyword">chan</span>：用于定义通道类型。</span><br><span class="line"><span class="keyword">const</span>：用于定义常量。</span><br><span class="line"><span class="keyword">continue</span>：用于跳过循环中剩余的语句并开始下一次循环。</span><br><span class="line"><span class="keyword">default</span>：在<span class="keyword">switch</span>语句中所有<span class="keyword">case</span>都不匹配时执行的语句块。</span><br><span class="line"><span class="keyword">defer</span>：用于函数结束前执行一个语句块，常用于资源释放。</span><br><span class="line"><span class="keyword">else</span>：在<span class="keyword">if</span>语句中，如果条件不成立时执行的语句块。</span><br><span class="line"><span class="keyword">fallthrough</span>：在<span class="keyword">switch</span>语句中，将控制权转移到下一个<span class="keyword">case</span>语句。</span><br><span class="line"><span class="keyword">for</span>：用于循环语句。</span><br><span class="line"><span class="function"><span class="keyword">func</span>：用于定义函数和方法。</span></span><br><span class="line"><span class="keyword">go</span>：用于启动一个新的goroutine。</span><br><span class="line"><span class="keyword">goto</span>：用于无条件跳转到代码中的某个标签。</span><br><span class="line"><span class="keyword">if</span>：用于条件语句。</span><br><span class="line"><span class="keyword">import</span>：用于导入其他包。</span><br><span class="line"><span class="keyword">interface</span>：用于定义接口类型。</span><br><span class="line"><span class="keyword">map</span>：用于定义映射类型。</span><br><span class="line"><span class="keyword">package</span>：用于定义包，每个Go文件必须在<span class="keyword">package</span>定义的包中。</span><br><span class="line"><span class="keyword">range</span>：用于循环迭代数组、切片、字符串、映射和通道。</span><br><span class="line"><span class="keyword">return</span>：用于从函数返回一个值。</span><br><span class="line"><span class="keyword">select</span>：用于同时等待多个通道操作。</span><br><span class="line"><span class="keyword">struct</span>：用于定义结构体类型。</span><br><span class="line"><span class="keyword">switch</span>：用于根据不同的条件执行不同的分支语句。</span><br><span class="line"><span class="keyword">type</span>：用于定义自定义类型。</span><br><span class="line"><span class="keyword">var</span>：用于定义变量。</span><br></pre></td></tr></table></figure><p>这些关键字在Go语言的语法中扮演着重要的角色，用于定义控制流程、定义变量、创建函数等。需要注意的是，除了上面列出的关键字之外，Go语言还有一些保留字（Reserved Words），虽然目前未被使用，但保留用于将来的扩展和功能增强。这些保留字包括nil、true和false等。</p><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3 变量"></a>3 变量</h2><p>什么是变量，从数学概念上讲，变量表示没有固定值且可以改变的数，在程序中，变量用来存储各数据类型没有固定值且可以改变的值，你可以可以理解为用于存储值的一种容器，从计算机底层实现角度来看，变量是一段或多段用来存储数据的内存，和C\C++\Java一样，Go是静态强类型语言，因此变量<strong>Variable</strong>需要明确指定类型，编译器也会检查变量类型的正确性。</p><h3 id="3-1-变量定义"><a href="#3-1-变量定义" class="headerlink" title="3.1 变量定义"></a>3.1 变量定义</h3><p>变量定义有两种方式，分别是通过var关键字定义和使用:&#x3D;短变量定义。</p><h4 id="3-1-1-var关键字定义变量"><a href="#3-1-1-var关键字定义变量" class="headerlink" title="3.1.1 var关键字定义变量"></a>3.1.1 var关键字定义变量</h4><p>变量的定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 [类型] = 值</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> variableName [<span class="keyword">type</span>] = variableValue</span><br></pre></td></tr></table></figure><p>其中，var是关键字用于定义变量，变量名是你给变量起的名称，类型是变量的数据类型，其中类型是可省略的，表明Go的变量是可以自动推断的，值是各数据类型所表示的值。</p><p>以下是一些例子来说明如何定义不同类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整数类型变量</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span>  <span class="comment">// 定义一个int类型的变量num</span></span><br><span class="line"><span class="comment">// 定义字符串类型变量</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span>  <span class="comment">// 定义一个string类型的变量str</span></span><br><span class="line"><span class="comment">// 定义布尔类型变量</span></span><br><span class="line"><span class="keyword">var</span> flag <span class="type">bool</span>   <span class="comment">// 定义一个bool类型的变量flag</span></span><br><span class="line"><span class="comment">// 定义浮点数类型变量</span></span><br><span class="line"><span class="keyword">var</span> score <span class="type">float64</span>   <span class="comment">// 定义一个float64类型的变量score</span></span><br><span class="line"><span class="comment">// 定义字符类型变量</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="type">rune</span>   <span class="comment">// 定义一个rune类型的变量ch (用于表示Unicode字符)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：以上变量只是定义变量名，没有初始化值，在定义变量时，如果没有显式地指定初始值，那么变量将会被赋予其类型的零值。例如，整数类型变量的零值是0，字符串类型变量的零值是空字符串，布尔类型变量的零值是false。</p></blockquote><p>在定义变量时，可以省略type，由Go语言自动推断类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整数类型变量并赋值</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">// 定义字符串类型变量并赋值</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Ratel&quot;</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;Ratel&quot;</span></span><br></pre></td></tr></table></figure><p>我们还可以一次性定义多个变量，且多个变量的数据类型可以不同。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性定义name和age两个变量，且数据类型不同</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="type">string</span> = <span class="string">&quot;Ratel&quot;</span></span><br><span class="line">age <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %T&quot;</span>, name, age) <span class="comment">// Output: string int</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-运算符定义变量"><a href="#3-1-2-运算符定义变量" class="headerlink" title="3.1.2 :&#x3D;运算符定义变量"></a>3.1.2 :&#x3D;运算符定义变量</h4><p>我们还可以使用短变量定义语法来更简洁地定义并初始化变量。短变量定义使用冒号等于符号 <strong>:&#x3D;</strong> 进行赋值，赋值后，Go会自动进行类型推断。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整数类型变量并赋值</span></span><br><span class="line">num := <span class="number">20</span></span><br><span class="line"><span class="comment">// 定义字符串类型变量并赋值</span></span><br><span class="line">str := <span class="string">&quot;Ratel&quot;</span></span><br><span class="line"><span class="comment">// 定义布尔类型变量并赋值</span></span><br><span class="line">flag := <span class="literal">false</span></span><br><span class="line"><span class="comment">// 定义浮点数类型变量并赋值</span></span><br><span class="line">score := <span class="number">0.2315</span></span><br><span class="line"><span class="comment">// 定义字符类型变量并赋值</span></span><br><span class="line">ch := <span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><p>在短变量定义中，我们同样可以一次定义多个变量，且多个变量的数据类型可以不同，Golang会根据值自动推断变量类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性定义name和age两个变量，且数据类型不同</span></span><br><span class="line">name, age := <span class="string">&quot;Ratel&quot;</span>, <span class="number">20</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %T&quot;</span>, name, age) <span class="comment">// Output: string int</span></span><br></pre></td></tr></table></figure><p>此时，name会被自动推断为string类型，age则被推断为int类型。</p><p>综上所述，使用var关键字可以定义不同类型的变量。同时，使用短变量定义语法也是一种常用的快捷方式来定义并初始化变量。</p><h3 id="3-2-作用域"><a href="#3-2-作用域" class="headerlink" title="3.2 作用域"></a>3.2 作用域</h3><p>Golang的变量还具有作用域和生命周期。在同一个作用域中，不能使用相同名称的变量。变量的生命周期由变量在内存中的存储时间来决定。变量的生命周期可以是全局、局部或动态分配的。</p><p>例如，以下是一个在函数内定义并初始化的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Ratel&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上例子中，变量name的作用域为main函数，在main函数外无法访问变量name，变量name的生命周期取决于变量name的创建和销毁时间。</p><h2 id="4-常量"><a href="#4-常量" class="headerlink" title="4 常量"></a>4 常量</h2><p>常量，顾名思义，与变量相反，常量用来存储各种数据类型有固定值且不可以改变的值。在Go语言中，常量<strong>Constant</strong>是在程序编译阶段就确定的值，它们在定义时必须赋予一个固定的初值，并且不能被修改。常量的定义和变量的定义有一些差异。</p><p>常量的定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 常量名 [类型] = 值</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> constantName [<span class="keyword">type</span>] = constantValue</span><br></pre></td></tr></table></figure><p>其中，const是关键字用于定义常量，常量名是你给常量起的名称，类型是常量的数据类型, 是可以省略的，表达式是常量的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整数常量</span></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span>   <span class="comment">// 定义一个浮点数类型的常量Pi，并初始化为3.14</span></span><br><span class="line"><span class="keyword">const</span> MaxSize <span class="type">int</span> = <span class="number">100</span>   <span class="comment">// 定义一个整数类型的常量MaxSize，并初始化为100</span></span><br><span class="line"><span class="comment">// 定义字符串常量</span></span><br><span class="line"><span class="keyword">const</span> Name = <span class="string">&quot;Ratel&quot;</span>   <span class="comment">// 定义一个字符串类型的常量Name，并初始化为&quot;Ratel&quot;</span></span><br><span class="line"><span class="comment">// 定义布尔常量</span></span><br><span class="line"><span class="keyword">const</span> IsDebug = <span class="literal">false</span>   <span class="comment">// 定义一个布尔类型的常量IsDebug，并初始化为false</span></span><br><span class="line"><span class="comment">// 定义多个常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Monday = <span class="number">1</span></span><br><span class="line">    Tuesday = <span class="number">2</span></span><br><span class="line">    Wednesday = <span class="number">3</span></span><br><span class="line">    Thursday = <span class="number">4</span></span><br><span class="line">    Friday = <span class="number">5</span></span><br><span class="line">    Saturday = <span class="number">6</span></span><br><span class="line">    Sunday = <span class="number">7</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里使用了括号和换行符来分组和格式化多个常量的定义。</p><blockquote><p>值得注意的是，在批量定义常量时，第一个常量的值默认被赋值为0，后续常量的值会根据前面的常量值自动递增。</p></blockquote><p>在Go语言中，常量可以用于各种常见的场景，例如定义数学常量、枚举值、配置参数等。它们具有不可变性，并且可以提高代码的可读性和可维护性。</p><p>需要注意的是，Go语言常量的类型是根据初值自动推导得出的，因此在大多数情况下，常量的类型定义是可选的。</p><p>综上所述，使用const关键字可以定义不同类型的常量，并为其赋予一个固定的初值。常量在编译时确定，并且不能被修改。</p><h2 id="5-基本数据类型"><a href="#5-基本数据类型" class="headerlink" title="5 基本数据类型"></a>5 基本数据类型</h2><hr><p>Go语言基本数据类型包括布尔类型、整数类型、浮点类型、复数类型、字符（串）类型五种类型，我们将依次介绍这些数据类型以及它们的操作。</p><blockquote><p>所有的基础类型都是值类型， 这意味着当它们作为参数传递或从函数返回时，它们通过值传递给函数。</p></blockquote><ol><li>布尔类型（Boolean Type）：</li></ol><ul><li>bool：表示真（true）或假（false）的布尔类型。</li></ul><ol start="2"><li>整数类型（Integer Types）：</li></ol><ul><li>int：根据平台可能是32位或64位的有符号整数。</li><li>uint：根据平台可能是32位或64位的无符号整数。</li><li>int8、int16、int32、int64：固定大小的有符号整数类型。</li><li>uint8、uint16、uint32、uint64：固定大小的无符号整数类型。</li><li>uintptr：用于存储指针的整数类型。</li></ul><ol start="3"><li>浮点数类型（Floating-Point Types）：</li></ol><ul><li>float32：IEEE-754 32位浮点数。</li><li>float64：IEEE-754 64位浮点数。</li></ul><ol start="4"><li>复数类型（Complex Types）：</li></ol><ul><li>complex64：包含32位实部和32位虚部的复数类型。</li><li>complex128：包含64位实部和64位虚部的复数类型。</li></ul><ol start="5"><li>字符类型（Character Type）：</li></ol><ul><li>byte：与uint8类型相同，用于表示ASCII字符。</li><li>rune：与int32类型相同，用于表示Unicode码点。</li></ul><ol start="6"><li>字符串类型（String Type）：</li></ol><ul><li>string：表示一系列字符的字符串类型。</li></ul><h3 id="5-1-布尔类型"><a href="#5-1-布尔类型" class="headerlink" title="5.1 布尔类型"></a>5.1 布尔类型</h3><p>在Go语言中，bool表示布尔类型，它只有两个可能的值：true和false。布尔类型用于表示逻辑条件的真假状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="type">bool</span> <span class="comment">// 声明一个布尔变量</span></span><br><span class="line">    b = <span class="literal">true</span>   <span class="comment">// 赋值为true</span></span><br><span class="line">    fmt.Println(b) <span class="comment">// 输出: true</span></span><br><span class="line">    <span class="comment">// 条件判断</span></span><br><span class="line">    <span class="keyword">if</span> b &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;b is true&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;b is false&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逻辑运算</span></span><br><span class="line">    x := <span class="literal">true</span></span><br><span class="line">    y := <span class="literal">false</span></span><br><span class="line">    fmt.Println(x &amp;&amp; y) <span class="comment">// 与运算, 输出: false</span></span><br><span class="line">    fmt.Println(x || y) <span class="comment">// 或运算, 输出: true</span></span><br><span class="line">    fmt.Println(!x)     <span class="comment">// 非运算, 输出: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在条件判断语句中，只能使用布尔类型的表达式作为条件。不能使用任意其他类型的值进行条件判断。</p></blockquote><h3 id="5-2-整数类型"><a href="#5-2-整数类型" class="headerlink" title="5.2 整数类型"></a>5.2 整数类型</h3><p>Go语言同时提供了有符号和无符号的整数类型，其中包括int8、int16、int32和int64四种大小截然不同的有符号整数类型，分别对应8、16、32、64 bit（二进制位）大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。</p><p>此外还有两种整数类型int和uint，它们分别对应特定CPU平台的字长（机器字大小），其中int表示有符号整数，应用最为广泛，uint表示无符号整数。实际开发中由于编译器和计算机硬件的不同，int和uint所能表示的整数大小会在32bit或64bit之间变化。</p><p>用来表示Unicode字符的rune类型和int32类型是等价的，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样，byte和uint8也是等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p><p>尽管在某些特定的运行环境下int、uint和uintptr的大小可能相等，但是它们依然是不同的类型，比如int和int32，虽然int类型的大小也可能是32bit，但是在需要把int类型当做int32类型使用的时候必须显示的对类型进行转换，反之亦然。</p><p>Go语言中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的取值范围是从-2(n-1) 到 2(n-1)-1。无符号整数的所有bit位都用于表示非负数，取值范围是0到2n-1。例如，int8类型整数的取值范围是从-128到127，而uint8类型整数的取值范围是从0到255。</p><p>最后，还有一种无符号的整数类型uintptr，它没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>  </span><br><span class="line">    <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">5</span>  </span><br><span class="line">    <span class="keyword">var</span> c <span class="type">uint</span> = <span class="number">15</span>  </span><br><span class="line">    <span class="keyword">var</span> d <span class="type">uint</span> = <span class="number">7</span>  </span><br><span class="line">  </span><br><span class="line">    sum := a + b       <span class="comment">// 加法运算  </span></span><br><span class="line">    diff := a - b      <span class="comment">// 减法运算  </span></span><br><span class="line">    product := a * b   <span class="comment">// 乘法运算  </span></span><br><span class="line">    quotient := a / b  <span class="comment">// 除法运算  </span></span><br><span class="line">    remainder := a % b <span class="comment">// 取模运算  </span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Sum:&quot;</span>, sum)          <span class="comment">// 输出: Sum: 15  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Difference:&quot;</span>, diff)   <span class="comment">// 输出: Difference: 5  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Product:&quot;</span>, product)   <span class="comment">// 输出: Product: 50  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Quotient:&quot;</span>, quotient) <span class="comment">// 输出: Quotient: 2  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Remainder:&quot;</span>, remainder) <span class="comment">// 输出: Remainder: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无符号整数的运算示例  </span></span><br><span class="line">    unsignedSum := c + d       <span class="comment">// 加法运算  </span></span><br><span class="line">    unsignedDiff := c - d      <span class="comment">// 减法运算  </span></span><br><span class="line">    unsignedProduct := c * d   <span class="comment">// 乘法运算  </span></span><br><span class="line">    unsignedQuotient := c / d  <span class="comment">// 除法运算  </span></span><br><span class="line">    unsignedRemainder := c % d <span class="comment">// 取模运算  </span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Sum:&quot;</span>, unsignedSum)          <span class="comment">// 输出: Unsigned Sum: 22  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Difference:&quot;</span>, unsignedDiff)   <span class="comment">// 输出: Unsigned Difference: 8  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Product:&quot;</span>, unsignedProduct)   <span class="comment">// 输出: Unsigned Product: 105  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Quotient:&quot;</span>, unsignedQuotient) <span class="comment">// 输出: Unsigned Quotient: 2  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Remainder:&quot;</span>, unsignedRemainder) <span class="comment">// 输出: Unsigned Remainder: 1  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-浮点数类型"><a href="#5-3-浮点数类型" class="headerlink" title="5.3 浮点数类型"></a>5.3 浮点数类型</h3><p>float32是32位的浮点数类型，它可以表示大约6个小数位的精度。这种类型适用于对内存占用有限且精度要求不高的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="type">float32</span> = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>float64是64位的浮点数类型，它可以表示大约15个小数位的精度。这种类型适用于需要更高精度的计算或涉及较大数值范围的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num2 <span class="type">float64</span> = <span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><p>注意，如果没有指定具体的浮点数类型，默认情况下，Go语言会将浮点数值视为float64类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num3 = <span class="number">3.14</span> <span class="comment">//默认为float64类型</span></span><br></pre></td></tr></table></figure><p>简单四则运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="type">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">    b := <span class="type">float32</span>(<span class="number">2.5</span>)</span><br><span class="line">    sum := a + b            <span class="comment">// 加法运算</span></span><br><span class="line">    diff := a - b           <span class="comment">// 减法运算</span></span><br><span class="line">    product := a * b        <span class="comment">// 乘法运算</span></span><br><span class="line">    quotient := a / b       <span class="comment">// 除法运算</span></span><br><span class="line">    fmt.Println(sum)        <span class="comment">// 输出: 5.6400003</span></span><br><span class="line">    fmt.Println(diff)       <span class="comment">// 输出: 0.6400001</span></span><br><span class="line">    fmt.Println(product)    <span class="comment">// 输出: 7.8500004</span></span><br><span class="line">    fmt.Println(quotient)   <span class="comment">// 输出: 1.256</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-1-注意事项"><a href="#5-3-1-注意事项" class="headerlink" title="5.3.1 注意事项"></a>5.3.1 注意事项</h4><ul><li>浮点数不适合用于精确计算，因为它们是基于二进制表示的近似值。在进行计算时可能会出现舍入误差。</li><li>不要使用等号（&#x3D;&#x3D;）来比较两个浮点数是否相等，因为舍入误差可能导致结果不准确。通过定义一个误差范围来判断浮点数是否接近。例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">epsilon := <span class="number">1e-9</span> <span class="comment">// 定义一个小的误差范围</span></span><br><span class="line"><span class="keyword">if</span> math.Abs(f1-f2) &lt; epsilon &#123;</span><br><span class="line">    <span class="comment">// 浮点数接近</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>浮点数运算可能会导致溢出或下溢。务必注意结果是否在所选类型的范围内。</li><li>避免在循环中使用浮点数作为循环控制条件，因为舍入误差可能导致无限循环或提前退出循环。</li><li>在使用浮点数进行计算时，可以通过引入math包来执行更复杂的数学操作，例如开方、幂等等。</li><li>尽量使用float64类型，除非有特别的需求。虽然float32占用的内存更小，但float64提供了更高的精度，并且在大多数情况下，性能影响不大。</li></ul><p>总结起来，虽然Go提供了浮点类型进行小数运算，但需要注意浮点数的近似性、舍入误差和比较等问题。如果需要精确计算，应考虑使用整数类型或专门的十进制数库。</p><h3 id="5-4-复数类型"><a href="#5-4-复数类型" class="headerlink" title="5.4 复数类型"></a>5.4 复数类型</h3><p>在Go语言中，复数类型用于表示复数数值。Go语言中的复数类型是内置的，由complex64和complex128两种类型组成。</p><blockquote><p>complex64类型表示一个复数，其中实部和虚部都是float32类型。complex128类型表示一个复数，其中实部和虚部都是float64类型。</p></blockquote><p>复数有两种定义方式，一种是通过complex(a, b)声明，其中a是实部，b是虚部，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// complex</span></span><br><span class="line"><span class="keyword">var</span> c1 <span class="type">complex64</span> = <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">6</span>) </span><br></pre></td></tr></table></figure><p>另外一种是通过a + bi方式声明，其中a是实部，b是虚部，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a + bi</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">complex64</span> = <span class="number">2</span> + <span class="number">3i</span></span><br></pre></td></tr></table></figure><p>然后我们看一些关于复数的一些计算操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c1 <span class="type">complex64</span> = <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">var</span> c2 <span class="type">complex64</span> = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;real(c1) =&quot;</span>, <span class="built_in">real</span>(c1)) <span class="comment">// 获取实部，输出: 4</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;imag(c1) =&quot;</span>, <span class="built_in">imag</span>(c1)) <span class="comment">// 获取虚部，输出: 6</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mod(c1) =&quot;</span>, Mod(c1))   <span class="comment">// 获取模长，输出：7.211102550927978</span></span><br><span class="line">    sum := c1 + c2</span><br><span class="line">    diff := c1 - c2</span><br><span class="line">    product := c1 * c2</span><br><span class="line">    quotient := c1 / c2</span><br><span class="line">    fmt.Println(sum)      <span class="comment">// 输出: 6+9i</span></span><br><span class="line">    fmt.Println(diff)     <span class="comment">// 输出: 2+3i</span></span><br><span class="line">    fmt.Println(product)  <span class="comment">// 输出: -10+24i</span></span><br><span class="line">    fmt.Println(quotient) <span class="comment">// 输出: 2+0i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算复数的模</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mod</span><span class="params">(c <span class="type">complex64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    a := <span class="built_in">real</span>(c) * <span class="built_in">real</span>(c)</span><br><span class="line">    b := <span class="built_in">imag</span>(c) * <span class="built_in">imag</span>(c)</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(<span class="type">float64</span>(a + b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意精度：在使用复数进行计算时，需要注意浮点数的精度问题。由于浮点数精度的限制，复数计算可能会产生舍入误差。因此，在比较复数是否相等时，不应该直接使用&#x3D;&#x3D;运算符，而应该使用近似判断方法，如判断实部和虚部的差值是否在允许的误差范围内。</p></blockquote><p>Go语言还提供了math&#x2F;cmplx包，其中包含一些用于复数计算的函数，如求模、幅角、共轭等。你可以根据需要使用这些函数来进行更复杂的复数计算。</p><p>总之，复数类型在Go语言中提供了处理复数数值的能力，可以进行基本的复数计算操作，用于涉及复数计算、信号处理、物理模拟、图像处理和控制系统等领域。但需要注意浮点数精度和比较的问题，以及根据需求使用适当的复数运算函数和库。</p><h3 id="5-5-字符类型"><a href="#5-5-字符类型" class="headerlink" title="5.5 字符类型"></a>5.5 字符类型</h3><p>字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。</p><p>Go语言的字符有以下两种：</p><ul><li>一种是byte类型，或者叫uint8型，代表了ASCII码的一个字符。</li><li>一种是rune类型，代表一个UTF-8字符，当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型等价于int32类型。它实际上是一个32位的整数类型。rune类型可以用来存储Unicode码点（Unicode code point）。要定义一个字符变量，可以使用单引号将字符括起来。</li></ul><p>byte类型是uint8的别名，对于只占用1个字节的传统ASCII编码的字符来说，完全没有问题，例如 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;A&#x27;</span> <span class="comment">//字符使用单引号括起来</span></span><br></pre></td></tr></table></figure><p>在ASCII码表中，A的值是65，使用16进制表示则为41，所以下面的写法是等效的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span> = <span class="number">65</span> 或 <span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;\x41&#x27;</span>  <span class="comment">//（\x 总是紧跟着长度为2的16进制数）</span></span><br></pre></td></tr></table></figure><p>另外一种可能的写法是\后面紧跟着长度为3的八进制数，例如\377。</p><p>Go语言同样支持Unicode（UTF-8），因此字符同样称为Unicode代码点或者runes，并在内存中使用int来表示。在文档中，一般使用格式U+hhhh来表示，其中h表示一个16进制数。</p><p>在书写Unicode字符时，需要在16进制数之前加上前缀\u或者\U。因为Unicode至少占用2个字节，所以我们使用 int16或者int类型来表示。如果需要使用到4字节，则使用\u前缀，如果需要使用到8个字节，则使用\U前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">int</span> = <span class="string">&#x27;\u0041&#x27;</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="type">int</span> = <span class="string">&#x27;\u03B2&#x27;</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="type">int</span> = <span class="string">&#x27;\U00101234&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d - %d - %d\n&quot;</span>, ch, ch2, ch3) <span class="comment">// integer</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c - %c - %c\n&quot;</span>, ch, ch2, ch3) <span class="comment">// character</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X - %X - %X\n&quot;</span>, ch, ch2, ch3) <span class="comment">// UTF-8 bytes</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%U - %U - %U&quot;</span>, ch, ch2, ch3)   <span class="comment">// UTF-8 code point</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">65</span> - <span class="number">946</span> - <span class="number">1053236</span></span><br><span class="line">A - β - r</span><br><span class="line"><span class="number">41</span> - <span class="number">3</span>B2 - <span class="number">101234</span></span><br><span class="line">U+<span class="number">0041</span> - U+<span class="number">03</span>B2 - U+<span class="number">101234</span></span><br></pre></td></tr></table></figure><p>格式化说明符%c用于表示字符，当和字符配合使用时，%v或%d会输出用于表示该字符的整数，%U输出格式为U+hhhh的字符串。</p><p>Unicode包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中ch代表字符）：<br>判断是否为字母：<code>unicode.IsLetter(ch)</code><br>判断是否为数字：<code>unicode.IsDigit(ch)</code><br>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></p><p>Unicode与ASCII类似，都是一种字符集。</p><p>字符集为每个字符分配一个唯一的ID，我们使用到的所有字符在Unicode字符集中都有一个唯一的 ID，例如上面例子中的 a 在 Unicode 与 ASCII 中的编码都是 97。汉字“你”在 Unicode 中的编码为 20320，在不同国家的字符集中，字符所对应的 ID 也会不同。而无论任何情况下，Unicode 中的字符的 ID 都是不会变化的。</p><p>UTF-8是编码规则，将Unicode中字符的ID以某种方式进行编码，UTF-8是一种变长编码规则，从1到4个字节不等。编码规则如下：<br>0xxxxxx表示文字符号0～127，兼容ASCII字符集。<br>从128到0x10ffff表示其他字符。</p><p>根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用3个字节。</p><p>广义的Unicode指的是一个标准，它定义了字符集及编码规则，即Unicode字符集和UTF-8、UTF-16编码等。</p><h3 id="5-6-字符串类型"><a href="#5-6-字符串类型" class="headerlink" title="5.6 字符串类型"></a>5.6 字符串类型</h3><p>Go语言中的字符串类型用string关键字表示。字符串是不可变的序列，可以包含任意Unicode字符。可以使用双引号或反引号将字符串括起来。</p><p>在Go中，字符串是一种基本数据类型，其值是Unicode码点（code point）序列，通常被解释为UTF-8编码的字节序列。在Go语言中，字符串的底层数据结构是一个只读的字节数组，也就是一组连续的字节。</p><p>一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8字符的一个序列（当字符为ASCII码表上的字符时则占用1个字节，其它字符根据需要占用2-4个字节）。</p><p>字符串类型在Go语言中使用双引号（”）或反引号（&#96;）括起来，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;Hello, World!&quot;</span> <span class="comment">// 使用双引号括起来的字符串</span></span><br><span class="line">str2 := <span class="string">`This is a multiline </span></span><br><span class="line"><span class="string">string using backticks`</span>  <span class="comment">// 使用反引号括起来的多行字符串</span></span><br></pre></td></tr></table></figure><p>字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\n：换行符</span><br><span class="line">\r：回车符</span><br><span class="line">\t：TAB键</span><br><span class="line">\u或\U：Unicode字符</span><br><span class="line">\\：反斜杠自身</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;这是我的\nGo语言教程&quot;</span></span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是我的</span><br><span class="line">Go语言教程</span><br></pre></td></tr></table></figure><p>以下是一些常见的字符串操作：</p><p>1.字符串长度：可以使用内置函数<code>len()</code>获取字符串的长度，即字符的个数。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">length := <span class="built_in">len</span>(str) <span class="comment">// 获取字符串的长度</span></span><br><span class="line">fmt.Println(length) <span class="comment">// 输出：13</span></span><br></pre></td></tr></table></figure><p>2.字符串索引和切片：可以通过索引访问字符串中的单个字符，索引从0开始。还可以使用切片操作提取子字符串，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">char := str[<span class="number">0</span>] <span class="comment">// 获取第一个字符&#x27;H&#x27;</span></span><br><span class="line">substr := str[<span class="number">7</span>:<span class="number">12</span>] <span class="comment">// 提取子字符串&quot;World&quot;</span></span><br></pre></td></tr></table></figure><p>3.字符串拼接：可以使用加号（+）运算符将两个字符串连接起来，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;World&quot;</span></span><br><span class="line">result := str1 + <span class="string">&quot; &quot;</span> + str2 <span class="comment">// 拼接字符串为&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>4.字符串比较：可以使用比较运算符（&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;）对字符串进行比较，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="keyword">if</span> str1 == str2 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Strings are equal&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Strings are not equal&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.字符串遍历：可以使用<code>for range</code>循环遍历字符串中的字符。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>, char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.其他类型转化成字符串<br><strong>strconv</strong>包是关于字符串转化的工具集。</p><ul><li>整数转字符串：使用<code>strconv.Itoa()</code>函数将整数类型转换为字符串。</li><li>浮点数转字符串：使用<code>strconv.FormatFloat()</code>函数将浮点数类型转换为字符串。</li><li>布尔值转字符串：可以直接使用<code>strconv.FormatBool()</code>将布尔值转换为字符串。</li><li>其他类型转字符串：可以使用<code>fmt.Sprintf()</code>函数将其他类型转换为字符串。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将整数转换为字符串</span></span><br><span class="line">    str1 := strconv.Itoa(<span class="number">42</span>) </span><br><span class="line">    <span class="comment">// 将浮点数转换为字符串, 第一个参数是要转换的浮点数，第二个参数是格式，第三个参数是小数点的精度（-1表示不限制），最后一个参数是指定浮点数的位数（32或64）。</span></span><br><span class="line">    str2 := strconv.FormatFloat(num, <span class="string">&#x27;f&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="comment">// 将布尔值转换为字符串</span></span><br><span class="line">    str3 := strconv.FormatBool(<span class="literal">true</span>) </span><br><span class="line">    <span class="comment">// 将其他类型转换为字符串，其中%d是格式化字符串中的占位符，用于指定要转换的类型。</span></span><br><span class="line">    str4 := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, num) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go语言中，<code>fmt.Sprintf</code>函数可以使用不同的数据类型的占位符来格式化字符串。以下是一些常见的占位符及其对应的类型：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%d：表示整数类型（int、int8、int16、int32、int64等）。</span><br><span class="line">%f：表示浮点数类型（float32、float64）。</span><br><span class="line">%s：表示字符串类型（string）。</span><br><span class="line">%t：表示布尔类型（bool）。</span><br><span class="line">%v：表示通用占位符，可以用于任何类型。它会根据值的类型进行适当的格式化。</span><br></pre></td></tr></table></figure><p>除了这些常见的占位符之外，还有一些其他的占位符可以用于特定类型的数据。以下是一些额外的占位符：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%b：表示二进制数（整数类型以二进制格式输出）。</span><br><span class="line">%x：表示十六进制数（整数类型以十六进制格式输出）。</span><br><span class="line">%X：表示大写十六进制数（整数类型以大写格式的十六进制输出）。</span><br><span class="line">%o：表示八进制数（整数类型以八进制格式输出）。</span><br><span class="line">%u：表示无符号整数类型（如uint、uintptr等）。</span><br><span class="line">%c：表示字符类型（rune类型，Unicode码点）。</span><br></pre></td></tr></table></figure><p>这些占位符可以用于格式化字符串中的特定类型的数据。通过使用适当的占位符，你可以控制数据的输出格式，以满足你的需求。</p><blockquote><p>需要注意的是，以上方法适用于将基本类型转换为字符串。如果需要将自定义类型转换为字符串，可以在自定义类型的方法中实现String()函数来定义其字符串表示形式。</p></blockquote><p>7.字符串转化成其他类型</p><ul><li>字符串转整数：使用<code>strconv.Atoi()</code>函数将字符串转换为整数类型。</li><li>字符串转浮点数：使用<code>strconv.ParseFloat()</code>函数将字符串转换为浮点数类型。</li><li>字符串转布尔值：使用<code>strconv.ParseBool()</code>将字符串转换为布尔类型。</li><li>字符串转复数类型：使用<code>strconv.ParseComplex()</code>函数将字符串转换为复数类型。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num1, err := strconv.Atoi(<span class="string">&quot;54&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;转换失败:&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;转换结果:&quot;</span>, num1)  </span><br><span class="line"></span><br><span class="line">    num2, err := strconv.ParseFloat(<span class="string">&quot;3.14&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;转换失败:&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;转换结果:&quot;</span>, num2) </span><br><span class="line"></span><br><span class="line">    num3, err := strconv.ParseBool(<span class="string">&quot;true&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;转换失败:&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;转换结果:&quot;</span>, num3) </span><br><span class="line">    </span><br><span class="line">    num4, err := strconv.ParseComplex(<span class="string">&quot;1+2i&quot;</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;转换失败:&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;转换结果:&quot;</span>, num4) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>以上这些函数尝试将字符串解析为指定的类型，并返回解析后的值和可能的错误。在使用这些函数时，记得检查返回的错误以确保转换成功。</p></blockquote></li></ul><p>8.字符串、byte、rune关系和转换</p><p>在Go语言中，字符串底层是一个只读的字节数组，也就是[]byte类型，但是因为字符串是只读的，所以需要使用 rune类型来表示Unicode字符，而不是byte类型。因此，我们可以简单地把string类型看成是一个包含了若干个 rune类型的数组，其中每个rune表示一个Unicode字符。</p><ul><li>[]byte 转 string：使用 string() 方法将字节数组转为字符串类型。</li><li>string 转 []byte：使用 []byte() 方法将字符串类型转为字节数组。</li><li>string 转 []rune：使用 []rune() 方法将字符串类型转为rune数组。</li><li>[]rune 转 string：使用 string() 方法将rune数组转为字符串类型。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// []byte 转 string</span></span><br><span class="line">bytes := []<span class="type">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(bytes)  <span class="comment">// &quot;ABCD&quot;</span></span><br><span class="line"><span class="comment">// string 转 []byte</span></span><br><span class="line">str := <span class="string">&quot;ABCD&quot;</span></span><br><span class="line">bytes := []<span class="type">byte</span>(str)  <span class="comment">// [65 66 67 68]</span></span><br><span class="line"><span class="comment">// string 转 []rune</span></span><br><span class="line">str := <span class="string">&quot;ABCD&quot;</span></span><br><span class="line">runes := []<span class="type">rune</span>(str)  <span class="comment">// [65 66 67 68]</span></span><br><span class="line"><span class="comment">// []rune 转 string</span></span><br><span class="line">runes := []<span class="type">rune</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(runes)  <span class="comment">// &quot;ABCD&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，虽然Go语言的字符串是Unicode编码的，但是它并不是固定长度的。因为一个 Unicode 字符可能由多个字节组成，所以在Go语言中，使用UTF-8编码来表示 Unicode 字符，一个字符可能由1到4个字节组成。因此，在处理字符串时，需要注意字符的长度和字节的长度并不是一一对应的关系。</p></blockquote></li></ul><p>另外，<strong>strings</strong>包中提供了很多关于字符串操作的方法，总而言之，Go语言的字符串类型提供了一系列的操作和函数，可用于处理文本、字符串拼接、搜索和解析等任务。</p><h3 id="5-7-引用类型和非引用类型"><a href="#5-7-引用类型和非引用类型" class="headerlink" title="5.7 引用类型和非引用类型"></a>5.7 引用类型和非引用类型</h3><p>在Go语言中，有两种类型的数据类型：引用类型和非引用类型。</p><ul><li><p>基本数据类型（如int、float、bool、string等）是<strong>非引用类型</strong>。这些类型的变量在内存中分配的是实际值的空间。当传递这些变量时，函数会复制实际值而不是变量本身。在处理基本数据类型时，我们使用值传递。</p></li><li><p>引用类型（如slice、map、channel、interface和函数类型）则是指向底层数据结构的指针的包装器。这些类型的变量在内存中分配的是指向底层数据结构的指针，而不是实际值的空间。在处理引用类型时，我们使用指针传递。</p></li><li><p>指针类型是一种特殊的引用类型，用于指向变量的内存地址。指针变量保存的是变量的地址，而不是实际值。使用指针类型可以通过指针间接访问变量，也可以在函数中传递指针以通过指针访问原始变量。</p></li></ul><h2 id="6-编码"><a href="#6-编码" class="headerlink" title="6 编码"></a>6 编码</h2><p>在计算机中，编码是将一种形式的数据转换为另一种形式的过程。</p><p>在Golang中，编码是指将一组字符或字符串转换为一组字节或二进制数据的过程，通常用于将数据在网络或存储介质中进行传输或存储。</p><p>Golang中支持的编码方式有多种，包括ASCII、UTF-8、UTF-16、UTF-32等。下面简要介绍几种常见的编码方式：</p><ul><li>ASCII 编码：ASCII编码使用一个字节来表示一个字符，即采用8位二进制数表示一个字符，共可以表示2^8 &#x3D; 256 种不同的字符。</li><li>UTF-8 编码：UTF-8 是一种可变长度的编码方式，使用1~4个字节来表示一个字符。对于ASCII字符，使用一个字节表示；对于中文、韩文等字符，使用3个字节表示；对于某些特殊字符，如表情符号等，需要使用4个字节表示。因此，一个字符串的长度并不等于它所占用的字节数，它由其中的字符数量决定。</li><li>UTF-16 编码：UTF-16使用2个字节来表示一个字符，对于 ASCII 字符，使用一个字节表示；对于大多数中文、日文、韩文等字符，使用2个字节表示；对于某些特殊字符，需要使用4个字节表示。</li><li>UTF-32 编码：UTF-32使用4个字节来表示一个字符，无需考虑可变长度的问题，但对于大部分字符而言，会造成空间浪费。<br>在Golang中，字符串默认采用UTF-8编码，每个字符占用1~4个字节。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于ASCII字符，使用一个字节表示；</span><br><span class="line">对于中文、韩文等字符，使用3个字节表示；</span><br><span class="line">对于某些特殊字符，如表情符号等，需要使用4个字节表示。</span><br></pre></td></tr></table></figure>Go中还提供了很多用于处理不同编码方式的库和函数，如encoding&#x2F;json、encoding&#x2F;base64、unicode&#x2F;utf8等。这些库和函数可以帮助开发者在不同编码方式之间进行转换和处理。</li></ul><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><p>什么是指针？有过C\C++开发经验的同学一定非常熟悉指针，同样在Go语言中也一样，指针是一个变量，它存储了另一个变量的内存地址。因此，指针变量指向的是另一个变量的内存地址，后面我们会说明Go语言中指针和C\C++指针有啥区别。</p><p>定义指针变量时，需要在变量名前加上*，表示这是一个指针变量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br></pre></td></tr></table></figure><p>这表示定义了一个名为p的指向整型变量的指针。使用&amp;运算符可以取得一个变量的地址，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line">p := &amp;x</span><br></pre></td></tr></table></figure><p>这表示取得变量x的地址，并将地址赋给指针变量p。<br>使用指针访问变量时，需要使用*运算符，它表示解引用操作符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line">p := &amp;x</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>这表示打印出指针变量p指向的变量的值，即变量x的值。</p><p>除了定义指针变量和获取变量的地址之外，还可以使用new函数来创建指针变量。例如，创建一个指向整型变量的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>这将创建一个新的整型变量，并返回它的地址，然后将地址赋给指针变量p。</p><p>指针还可以用于函数参数和返回值，以便在函数调用之间共享数据。</p><p>在使用指针时需要小心，因为如果指针指向一个无效的内存地址，程序可能会崩溃或产生不可预测的行为。因此，使用指针时需要确保指针指向的内存地址是有效的。</p><h3 id="7-1-指针函数传参"><a href="#7-1-指针函数传参" class="headerlink" title="7.1 指针函数传参"></a>7.1 指针函数传参</h3><p>指针可以用于函数参数的传递，当一个函数需要修改实参的值时，可以将实参的地址作为形参传递给函数，通过操作指针来达到修改实参的值的目的。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(str *<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    *str = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    modify(&amp;str)</span><br><span class="line">    fmt.Println(str) <span class="comment">// 输出：hello, world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-指针访问结构体字段"><a href="#7-2-指针访问结构体字段" class="headerlink" title="7.2 指针访问结构体字段"></a>7.2 指针访问结构体字段</h3><p>通过指针可以更方便地访问结构体中的字段，特别是当结构体很大时，传递指针比较传递整个结构体更高效。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := &amp;Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        Age:  <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    p.Name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    fmt.Println(p) <span class="comment">// 输出：&amp;&#123;Bob 18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-通过指针动态分配内存"><a href="#7-3-通过指针动态分配内存" class="headerlink" title="7.3 通过指针动态分配内存"></a>7.3 通过指针动态分配内存</h3><p>通过指针可以在运行时动态地分配内存，比如使用<code>new()</code>函数创建一个新的变量并返回它的地址。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *p = <span class="number">42</span></span><br><span class="line">    fmt.Println(*p) <span class="comment">// 输出：42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-传递可变参数"><a href="#7-4-传递可变参数" class="headerlink" title="7.4 传递可变参数"></a>7.4 传递可变参数</h3><p>在Golang中，可以使用指针传递可变参数。这是因为在使用可变参数时，传递的是一个切片（slice），而切片本身就是指向一个数组的指针。这样的操作，可以避免拷贝大量的数据。</p><p>例如，考虑以下函数，它接受一个可变参数并将其打印出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArgs</span><span class="params">(args ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果要将切片作为参数传递给另一个函数，可以使用指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArgsPtr</span><span class="params">(args *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> *args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    args := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    printArgsPtr(&amp;args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个新函数printArgsPtr，它使用指针作为参数来接收切片。函数体内，我们使用*args来解引用指针，从而得到实际的切片，并遍历它以打印每个元素。在主函数中，我们创建了一个切片，并将其地址传递给printArgsPtr函数。</p><blockquote><p>需要注意的是，在使用指针传递变长参数时，如果切片为空，则不能传递nil指针，而应该传递一个空的切片。这是因为在Golang中，使用空的切片和nil指针的含义不同，后面会介绍。</p></blockquote><p>除了上述几个方面，指针在一些特定的场景下也非常有用，比如在处理数据结构时，通过指针可以更高效地操作链表、树等数据结构。但需要注意，过度使用指针可能会导致代码难以维护，需要谨慎使用。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>通过深入学习Go语言基本数据类型，您将能够更好地理解和掌握这些基本数据类型的特性和用法。无论您是初学者还是有经验的开发人员，对基本数据类型的深入理解都是成为一位优秀的Go语言程序员的关键，下一张我们将讲解复合数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 基础语法 </tag>
            
            <tag> 基本数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试重点</title>
      <link href="/article/9351.html"/>
      <url>/article/9351.html</url>
      
        <content type="html"><![CDATA[<h3 id="1）Redis为什么使用单进程单线程方式也这么快"><a href="#1）Redis为什么使用单进程单线程方式也这么快" class="headerlink" title="1）Redis为什么使用单进程单线程方式也这么快"></a>1）Redis为什么使用单进程单线程方式也这么快</h3><p>Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。</p><span id="more"></span><p>Redis快的主要原因是：</p><ol><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I&#x2F;O 复用模型</li></ol><p>多路 I&#x2F;O 复用模型是利用select、poll、epoll可以同时监察多个流的 I&#x2F;O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I&#x2F;O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p>和Memcached不同，Redis并没有直接使用Libevent，而是自己完成了一个非常轻量级的对select、epoll、evport、kqueue这些通用的接口的实现。在不同的系统调用选用适合的接口，linux下默认是epoll。因为Libevent比较重更通用代码量也就很庞大，拥有很多Redis用不上的功能，Redis为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。</p><h4 id="单进程单线程好处"><a href="#单进程单线程好处" class="headerlink" title="单进程单线程好处"></a>单进程单线程好处</h4><ul><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ul><h4 id="单进程单线程弊端"><a href="#单进程单线程弊端" class="headerlink" title="单进程单线程弊端"></a>单进程单线程弊端</h4><p>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</p><h4 id="其他一些优秀的开源软件采用的模型"><a href="#其他一些优秀的开源软件采用的模型" class="headerlink" title="其他一些优秀的开源软件采用的模型"></a>其他一些优秀的开源软件采用的模型</h4><ul><li>多进程单线程模型：Nginx</li><li>单进程多线程模型：Memcached</li></ul><h3 id="2）五种类型数据类型"><a href="#2）五种类型数据类型" class="headerlink" title="2）五种类型数据类型"></a>2）五种类型数据类型</h3><p>字符串、列表、散列表，集合、有序集合</p><h3 id="3）内存中数据持久化"><a href="#3）内存中数据持久化" class="headerlink" title="3）内存中数据持久化"></a>3）内存中数据持久化</h3><p>使用复制来扩展读性能：复制到多台服务器、提高读性能和可用性</p><p>使用分区来扩展写性能【hash一致性算法】：当数据量大的时候,把数据分散存入多个数据库中,减少单节点的连接压力</p><p>特点</p><ul><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I&#x2F;O 复用模型</li></ul><h3 id="4）Redis-适用场景"><a href="#4）Redis-适用场景" class="headerlink" title="4）Redis 适用场景"></a>4）Redis 适用场景</h3><ol><li>缓存 将热点数据放到内存中</li><li>消息队列 List 类型是双向链表，很适合用于消息队列</li><li>计数器 快速、频繁读写操作；string的单线性自增减 ++ –</li><li>共同好友关系 set 交集运算，很容易就可以知道用户的共同好友</li><li>排名 zset有序集合</li></ol><h3 id="5）持久化"><a href="#5）持久化" class="headerlink" title="5）持久化"></a>5）持久化</h3><p>快照持久化</p><p>将某个时间点的所有数据都存放到硬盘上</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本</p><p>缺点：故障可能丢失最后一次创建快照之后的数据；如果数据量很大，保存快照的时间也会很长。</p><p>AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾</p><ul><li>always： 每个写命令都同步，严重减低服务器的性能；</li><li>everysec ：每秒同步一次，比较合适，保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no ：让操作系统来决定何时同步，不能给性能带来提升，且会增加奔溃时数据丢失量</li></ul><p> </p><p>随着服务器写请求的增多，AOF 文件会越来越大；Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><p>对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，操作系统决定何时写</p><p>用户可以调用 file.flush() 方法请求尽快将缓冲区存储的数据同步到硬盘</p><p>redis主从复制 分布式数据同步方式</p><p>slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器</p><p>从服务器连接主服务器的过程</p><ul><li>主服务器创建快照文件，发送给从服务器。同时记录其间执行的写命令，发送完毕后，开始向从服务器发送写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器的快照文件，然后开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令</li></ul><p>主从链 创建一个中间层来分担主服务器的复制工作</p><ul><li>随着负载不断上升，主服务器可能无法很快地更新所有从服务器</li><li>重新连接和重新同步从服务器将导致系统超载</li><li>中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器</li></ul><h3 id="6）redis-主服务器-故障-处理"><a href="#6）redis-主服务器-故障-处理" class="headerlink" title="6）redis 主服务器 故障 处理"></a>6）redis 主服务器 故障 处理</h3><p>当主服务器出现故障时，Redis 常用的做法是新开一台服务器作为主服务器，具体步骤如下：假设 A 为主服务器，B 为从服务器，当 A 出现故障时，让 B 生成一个快照文件，将快照文件发送给 C，并让 C 恢复快照文件的数据。最后，让 B 成为 C 的从服务器。</p><h3 id="7）分片-集群-读并发"><a href="#7）分片-集群-读并发" class="headerlink" title="7）分片 集群 读并发"></a>7）分片 集群 读并发</h3><p>数据划分为多个部分，可以将数据存储到多台机器里，作用：负载均衡、线性级别的性能提升</p><h3 id="8）分片方式："><a href="#8）分片方式：" class="headerlink" title="8）分片方式："></a>8）分片方式：</h3><p>客户端代码分片</p><ul><li>Redis Sharding，对Redis数据的key进行hash，相同的key到相同的节点上</li><li>一致性哈希算法</li><li>代理服务器分片 轮询round-bin</li></ul><h3 id="9）redis与数据库的同步-数据一致"><a href="#9）redis与数据库的同步-数据一致" class="headerlink" title="9）redis与数据库的同步 数据一致"></a>9）redis与数据库的同步 数据一致</h3><ul><li><p>一致性要求高场景，实时同步方案，即查询redis，若查询不到再从DB查询，保存到redis；</p></li><li><p>更新redis时，先更新数据库，再将redis内容设置为过期(建议不要去更新缓存内容，直接设置缓存过期)，再用ZINCRBY增量修正redis数据</p></li><li><p>并发程度高的，采用异步队列的方式，采用kafka等消息中间件处理消息生产和消费</p></li><li><p>阿里的同步工具canal，实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发redis的更新，解放程序员双手，减少工作量</p></li><li><p>利用mysql触发器的API进行编程,c&#x2F;c++语言实现，学习成本高。</p></li></ul><h3 id="10）热数据与Mysql的同步编码实现-数据库上锁"><a href="#10）热数据与Mysql的同步编码实现-数据库上锁" class="headerlink" title="10）热数据与Mysql的同步编码实现 数据库上锁"></a>10）热数据与Mysql的同步编码实现 数据库上锁</h3><p>热点数据（经常会被查询，但是不经常被修改或者删除的数据），首选是使用redis缓存</p><p>用spring的AOP来构建redis缓存的自动生产和清除，过程如下：</p><ul><li>Select 数据库前查询redis，有的话使用redis数据，放弃select 数据库，没有的话，select 数据库，然后将数据插入redis</li><li>update或者delete 数据库数据<ul><li>高并发的情况下：先对数据库加锁，再删除redis</li><li>查询redis是否存在该数据，若存在则先对数据库加行锁，再删除redis，再update或者delete数据库中数据</li></ul></li><li>update或者delete redis，先更新数据库，再将redis内容设置为过期(建议不要去更新缓存内容，直接设置缓存过期)</li></ul><p> </p><p>出错场景：update先删掉了redis中的该数据，这时另一个线程执行查询，发现redis中没有，瞬间执行了查询SQL，并且插入到redis</p><h3 id="11）缓存穿透，缓存击穿，缓存雪崩解决方案分析"><a href="#11）缓存穿透，缓存击穿，缓存雪崩解决方案分析" class="headerlink" title="11）缓存穿透，缓存击穿，缓存雪崩解决方案分析"></a>11）缓存穿透，缓存击穿，缓存雪崩解决方案分析</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>我们的目标是：尽量少的线程构建缓存(甚至是一个) + 数据一致性 + 较少的潜在危险</p><p><a href="https://www.cnblogs.com/raichen/p/7750165.html">https://www.cnblogs.com/raichen/p/7750165.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引使用和优化</title>
      <link href="/article/52980.html"/>
      <url>/article/52980.html</url>
      
        <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引； </p><span id="more"></span><p>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替： </p><ul><li>正确选择复合索引中的主列字段，一般是选择性较好的字段； </li><li>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否  极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； </li><li>如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； </li><li>如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； </li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；<br>8、频繁进行数据操作的表，不要建立太多的索引；<br>9、删除无用的索引，避免对执行计划造成负面影响；</li></ul><p>以上是一些普遍的建立索引时的判断依据。索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。</p><p> 因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。 另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 </p><p>总的来说，小型表肯定不建索引，或者数据库记录在亿条数据级以上，还是建议使用非关系型数据库。 还有些特殊字段的数据库，比如BLOB，CLOB字段肯定也不适合建索引。</p><h3 id="对千万级MySQL数据库建立索引的事项及提高性能的手段"><a href="#对千万级MySQL数据库建立索引的事项及提高性能的手段" class="headerlink" title="对千万级MySQL数据库建立索引的事项及提高性能的手段"></a>对千万级MySQL数据库建立索引的事项及提高性能的手段</h3><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>首先，应当考虑表空间和磁盘空间是否足够。我们知道索引也是一种数据，在建立索引的时候势必也会占用大量表空间。因此在对一大表建立索引的时候首先应当考虑的是空间容量问题。<br>其次，在对建立索引的时候要对表进行加锁，因此应当注意操作在业务空闲的时候进行。</p><h4 id="性能调整方面"><a href="#性能调整方面" class="headerlink" title="性能调整方面"></a>性能调整方面</h4><p>首当其冲的考虑因素便是磁盘I&#x2F;O。物理上，应当尽量把索引与数据分散到不同的磁盘上（不考虑阵列的情况）。逻辑上，数据表空间与索引表空间分开。这是在建索引时应当遵守的基本准则。<br>其次，我们知道，在建立索引的时候要对表进行全表的扫描工作，因此，应当考虑调大初始化参数db_file_multiblock_read_count的值。一般设置为32或更大。</p><p>再次，建立索引除了要进行全表扫描外同时还要对数据进行大量的排序操作，因此，应当调整排序区的大小。<br>    9i之前，可以在session级别上加大sort_area_size的大小，比如设置为100m或者更大。<br>    9i以后，如果初始化参数workarea_size_policy的值为TRUE，则排序区从pga_aggregate_target里自动分配获得。<br>最后，建立索引的时候，可以加上nologging选项。以减少在建立索引过程中产生的大量redo，从而提高执行的速度。</p><h3 id="MySql在建立索引优化时需要注意的问题"><a href="#MySql在建立索引优化时需要注意的问题" class="headerlink" title="MySql在建立索引优化时需要注意的问题"></a>MySql在建立索引优化时需要注意的问题</h3><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>比如有一条语句是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where area=’beijing’ and age=22;</span><br></pre></td></tr></table></figure><p>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</p><h4 id="索引不会包含有NULL值的列"><a href="#索引不会包含有NULL值的列" class="headerlink" title="索引不会包含有NULL值的列"></a>索引不会包含有NULL值的列</h4><p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p><h4 id="使用短索引"><a href="#使用短索引" class="headerlink" title="使用短索引"></a>使用短索引</h4><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。</p><h4 id="排序的索引问题"><a href="#排序的索引问题" class="headerlink" title="排序的索引问题"></a>排序的索引问题</h4><p>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><h4 id="like语句操作"><a href="#like语句操作" class="headerlink" title="like语句操作"></a>like语句操作</h4><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%a%” 不会使用索引而like “aaa%”可以使用索引。</p><h4 id="不要在列上进行运算"><a href="#不要在列上进行运算" class="headerlink" title="不要在列上进行运算"></a>不要在列上进行运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where YEAR(adddate)</span><br></pre></td></tr></table></figure><h4 id="不使用NOT-IN和操作"><a href="#不使用NOT-IN和操作" class="headerlink" title="不使用NOT IN和操作"></a>不使用NOT IN和操作</h4><p>NOT IN和操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id3则可使用id&gt;3 or id</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA的使用</title>
      <link href="/article/15457.html"/>
      <url>/article/15457.html</url>
      
        <content type="html"><![CDATA[<p>IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言，对于这样一个强大的代码编辑器，我们势必要了解他的快捷键操作，方便我们快速的编写实现代码。</p><span id="more"></span><h2 id="快捷键的使用"><a href="#快捷键的使用" class="headerlink" title="快捷键的使用"></a>快捷键的使用</h2><blockquote><p>注意：以下快捷键的使用仅针对于Windows平台的操作，对于MAC和LINUX大家自己对照windows平台idea的使用</p></blockquote><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><ul><li>项目之间的跳转（项目分别位于不同的idea窗口）：<br>  Ctrl + Alt + [ : 跳转到上一个idea窗口<br>  Ctrl + Alt + ] : 跳转到下一个idea窗口</li><li>文件之间的跳转<br>  Ctrl + E : 多个文件之间的跳转（最近打开文件）<br>  Ctrl + Shift + E : 多个文件之间的跳转（最近编辑修改文件）</li><li>浏览修改位置的跳转<br>  Ctrl + Shift + BackSpace : 跳转到上一次编辑的文件 </li><li>浏览位置的跳转<br>  Ctrl + Alt + ← : 跳转到上一次浏览文件的位置<br>  Ctrl + Alt + → : 跳转到下一次浏览文件的位置</li><li>最近两个文件之间的跳转（windows自带）<br>  Ctrl + Tab : 最近两个文件之间随意切换</li><li>根据书签进行跳转<br>  首先要针对你要标记的代码行作为书签，F11或者Ctrl + F11,其中后者可以使用数字进行标记，但我们要跳转的时候就可以<br>   使用Ctrl + 你标记的数字 进行跳转定位</li><li>使用收藏夹<br>   通过Shift + Alt + F : 可以将当前文件（类），当前函数方法 加入到收藏列表<br>   然后Alt + 2 : 可以打开你的收藏的文件和书签</li><li>字符跳转插件emacsIDEAs跳转<br>  1.首先要安装这个插件，自行安装<br>  2.设置快捷键</li><li>编辑区和文件区的来回跳转<br>  Alt + 1 : 通过右边的编辑区定位该文件在文件区的位置</li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li>通过输入类名称搜索<br>  Ctrl + N : 通过输入类名称搜索类文件，如果要搜索jar包里面的类，直接勾选上include non-project classes即可</li><li>通过输入文件名搜索<br>  Ctrl + Shift + N : 通过输入文件名称搜索文件，如果要搜索jar包里面的文件，直接勾选上include non-project classes即可</li><li>通过输入字符串搜索<br>  Ctrl + Shift + Alt + N : 通过输入字符串搜索（这里的字符串可以是函数，属性，类名，其他文件名称），如果要搜索jar包里面的内容，直接勾选上include non-project symbols即可</li><li>通过输入查找普通字符串<br>  Ctrl + Shift + F ：通过输入字符串搜索所有的东西</li></ul><h3 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h3><ul><li>列选<br> Ctrl + Shift + Alt + J : 列选</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ idea </tag>
            
            <tag> Jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之线程顺序执行</title>
      <link href="/article/30518.html"/>
      <url>/article/30518.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;我们知道在多线程中，线程在启动的时候不是马上去执行任务的，而是由cpu调度让哪一个线程执行，通常情况下多线程的执行顺序是随机的，如果我们想要让线程按照一定的顺序让线程执行，怎么做呢？</p><span id="more"></span><h3 id="1-初见"><a href="#1-初见" class="headerlink" title="1.初见"></a>1.初见</h3><p>首先我们先上一段代码,看看执行效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如图所示：<br><img src="http://120.78.190.213/images/multithread/multithread-orderexecute.png" alt="如图示"><br>从代码运行结果看，线程执行的顺序是随机的，我们无法保证线程按照特定的顺序执行，线程启动之后处于就绪状态，等待CPU调度执行，也就是说如果不做处理话，我们是无法控制的。</p><h3 id="2-相恋"><a href="#2-相恋" class="headerlink" title="2.相恋"></a>2.相恋</h3><h4 id="2-1-设置线程优先级"><a href="#2-1-设置线程优先级" class="headerlink" title="2.1 设置线程优先级"></a>2.1 设置线程优先级</h4><p>线程的执行除了CPU调度外，还有一个因素就是每个线程的优先级，线程的级别有1-10个等级，级别越高表示线程越有可能拿到CPU时间片，但是并不是优先级越高的线程就一定比优先级低的线程更早获得CPU时间片执行任务呢，按但是否定的，我们只能说优先级高的线程更有可能获取的执行权，如果说优先级高的进入了等待，那么优先级低的线程就会执行，如果几个线程都处于就组状态，那毫无疑问优先级高的线程就会先执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">thread3.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">thread2.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">thread1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line">thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-priority.png" alt="如图示"></p><h4 id="2-2-Thread-join"><a href="#2-2-Thread-join" class="headerlink" title="2.2 Thread.join()"></a>2.2 Thread.join()</h4><p>我们Thread.join()方法就是让主线程等待，新线程执行完了后再继续执行主线程，让我们来看一下Thread.join()方法的源码吧<br>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>源码很清晰的告诉我们，当我们调用join()方法后，后调用join(long millis)，在millis &#x3D;&#x3D; 0的情况下，如果当前线程是存活的，就让当前线程等待，让新线程继续执行知道死亡，知道原理后就来实现下代码喔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.join();</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-join.png"></p><h4 id="2-3-Executors-newSingleThreadExecutor"><a href="#2-3-Executors-newSingleThreadExecutor" class="headerlink" title="2.3 Executors.newSingleThreadExecutor()"></a>2.3 Executors.newSingleThreadExecutor()</h4><p>Executors.newSingleThreadExecutor()就是创建一个只有一个线程线程池，让我们看了一个源码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到Executors.newSingleThreadExecutor()实际上是创建了一个单线程的线程池，并且维护了一个任务队列，我们知道队列的特点就是FIFO(先进先出)，而且线程池每次只能执行一个任务线程，其余的线程实际上放到new LinkedBlockingQueue<Runnable>()这个队列里等待CPU调度，当第一个线程执行完了后，线程池就会从队列取下一个任务线程来执行，以此类推，从而保证了线程的执行顺序，来看看代码怎么实现的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    service.execute(thread1);</span><br><span class="line">    service.execute(thread2);</span><br><span class="line">    service.execute(thread3);</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-executors.png"></p><h3 id="婚恋"><a href="#婚恋" class="headerlink" title="婚恋"></a>婚恋</h3><p>以上就是控制多线程执行顺序方法，有什么不对欢迎指正喔。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
