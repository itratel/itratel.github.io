<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go基础篇-关键字|变量|常量|基本数据类型</title>
      <link href="/article/3a64c617.html"/>
      <url>/article/3a64c617.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-序"><a href="#1-序" class="headerlink" title="1 序"></a>1 序</h2><p><img src="/img/cover/go_index1.png" alt="图片"></p><hr><p>在计算机编程中，数据类型是一种基础概念，它定义了数据的特性、存储方式以及可以对其执行的操作。数据类型的正确选择和使用对于编写高效、可靠的代码至关重要。Go语言作为一门现代化、简洁而强大的编程语言，提供了丰富的数据类型，使得开发人员能够更好地控制和操作数据。</p><p>本文将带您踏上一段探索Go语言基本数据类型的奇妙之旅。我们将深入探讨Go语言中的布尔型、整数型、浮点型和字符串型等基本数据类型的特性、用法和常见操作。</p><p>变量就是承载各种数据类型的容器，变量的定义又离不开关键字，所以我们先看Go的关键字。</p><h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2 关键字"></a>2 关键字</h2><p>Go语言具有一些关键字（Keywords），这些关键字具有特殊的含义，不能作为标识符来使用，以下是Go语言中的关键字列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>：用于在循环中跳出循环或在<span class="keyword">switch</span>语句中跳出<span class="keyword">switch</span>语句。</span><br><span class="line"><span class="keyword">case</span>：用于在<span class="keyword">switch</span>语句中分支选择。</span><br><span class="line"><span class="keyword">chan</span>：用于定义通道类型。</span><br><span class="line"><span class="keyword">const</span>：用于定义常量。</span><br><span class="line"><span class="keyword">continue</span>：用于跳过循环中剩余的语句并开始下一次循环。</span><br><span class="line"><span class="keyword">default</span>：在<span class="keyword">switch</span>语句中所有<span class="keyword">case</span>都不匹配时执行的语句块。</span><br><span class="line"><span class="keyword">defer</span>：用于函数结束前执行一个语句块，常用于资源释放。</span><br><span class="line"><span class="keyword">else</span>：在<span class="keyword">if</span>语句中，如果条件不成立时执行的语句块。</span><br><span class="line"><span class="keyword">fallthrough</span>：在<span class="keyword">switch</span>语句中，将控制权转移到下一个<span class="keyword">case</span>语句。</span><br><span class="line"><span class="keyword">for</span>：用于循环语句。</span><br><span class="line"><span class="function"><span class="keyword">func</span>：用于定义函数和方法。</span></span><br><span class="line"><span class="keyword">go</span>：用于启动一个新的goroutine。</span><br><span class="line"><span class="keyword">goto</span>：用于无条件跳转到代码中的某个标签。</span><br><span class="line"><span class="keyword">if</span>：用于条件语句。</span><br><span class="line"><span class="keyword">import</span>：用于导入其他包。</span><br><span class="line"><span class="keyword">interface</span>：用于定义接口类型。</span><br><span class="line"><span class="keyword">map</span>：用于定义映射类型。</span><br><span class="line"><span class="keyword">package</span>：用于定义包，每个Go文件必须在<span class="keyword">package</span>定义的包中。</span><br><span class="line"><span class="keyword">range</span>：用于循环迭代数组、切片、字符串、映射和通道。</span><br><span class="line"><span class="keyword">return</span>：用于从函数返回一个值。</span><br><span class="line"><span class="keyword">select</span>：用于同时等待多个通道操作。</span><br><span class="line"><span class="keyword">struct</span>：用于定义结构体类型。</span><br><span class="line"><span class="keyword">switch</span>：用于根据不同的条件执行不同的分支语句。</span><br><span class="line"><span class="keyword">type</span>：用于定义自定义类型。</span><br><span class="line"><span class="keyword">var</span>：用于定义变量。</span><br></pre></td></tr></table></figure><p>这些关键字在Go语言的语法中扮演着重要的角色，用于定义控制流程、定义变量、创建函数等。需要注意的是，除了上面列出的关键字之外，Go语言还有一些保留字（Reserved Words），虽然目前未被使用，但保留用于将来的扩展和功能增强。这些保留字包括nil、true和false等。</p><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3 变量"></a>3 变量</h2><p>什么是变量，从数学概念上讲，变量表示没有固定值且可以改变的数，在程序中，变量用来存储各数据类型没有固定值且可以改变的值，你可以可以理解为用于存储值的一种容器，从计算机底层实现角度来看，变量是一段或多段用来存储数据的内存，和C\C++\Java一样，Go是静态强类型语言，因此变量<strong>Variable</strong>需要明确指定类型，编译器也会检查变量类型的正确性。</p><h3 id="3-1-变量定义"><a href="#3-1-变量定义" class="headerlink" title="3.1 变量定义"></a>3.1 变量定义</h3><p>变量定义有两种方式，分别是通过var关键字定义和使用:&#x3D;短变量定义。</p><h4 id="3-1-1-var关键字定义变量"><a href="#3-1-1-var关键字定义变量" class="headerlink" title="3.1.1 var关键字定义变量"></a>3.1.1 var关键字定义变量</h4><p>变量的定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 [类型] = 值</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> variableName [<span class="keyword">type</span>] = variableValue</span><br></pre></td></tr></table></figure><p>其中，var是关键字用于定义变量，变量名是你给变量起的名称，类型是变量的数据类型，其中类型是可省略的，表明Go的变量是可以自动推断的，值是各数据类型所表示的值。</p><p>以下是一些例子来说明如何定义不同类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整数类型变量</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span>  <span class="comment">// 定义一个int类型的变量num</span></span><br><span class="line"><span class="comment">// 定义字符串类型变量</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span>  <span class="comment">// 定义一个string类型的变量str</span></span><br><span class="line"><span class="comment">// 定义布尔类型变量</span></span><br><span class="line"><span class="keyword">var</span> flag <span class="type">bool</span>   <span class="comment">// 定义一个bool类型的变量flag</span></span><br><span class="line"><span class="comment">// 定义浮点数类型变量</span></span><br><span class="line"><span class="keyword">var</span> score <span class="type">float64</span>   <span class="comment">// 定义一个float64类型的变量score</span></span><br><span class="line"><span class="comment">// 定义字符类型变量</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="type">rune</span>   <span class="comment">// 定义一个rune类型的变量ch (用于表示Unicode字符)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：以上变量只是定义变量名，没有初始化值，在定义变量时，如果没有显式地指定初始值，那么变量将会被赋予其类型的零值。例如，整数类型变量的零值是0，字符串类型变量的零值是空字符串，布尔类型变量的零值是false。</p></blockquote><p>在定义变量时，可以省略type，由Go语言自动推断类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整数类型变量并赋值</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">// 定义字符串类型变量并赋值</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Ratel&quot;</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;Ratel&quot;</span></span><br></pre></td></tr></table></figure><p>我们还可以一次性定义多个变量，且多个变量的数据类型可以不同。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性定义name和age两个变量，且数据类型不同</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="type">string</span> = <span class="string">&quot;Ratel&quot;</span></span><br><span class="line">age <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %T&quot;</span>, name, age) <span class="comment">// Output: string int</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-运算符定义变量"><a href="#3-1-2-运算符定义变量" class="headerlink" title="3.1.2 :&#x3D;运算符定义变量"></a>3.1.2 :&#x3D;运算符定义变量</h4><p>我们还可以使用短变量定义语法来更简洁地定义并初始化变量。短变量定义使用冒号等于符号 <strong>:&#x3D;</strong> 进行赋值，赋值后，Go会自动进行类型推断。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整数类型变量并赋值</span></span><br><span class="line">num := <span class="number">20</span></span><br><span class="line"><span class="comment">// 定义字符串类型变量并赋值</span></span><br><span class="line">str := <span class="string">&quot;Ratel&quot;</span></span><br><span class="line"><span class="comment">// 定义布尔类型变量并赋值</span></span><br><span class="line">flag := <span class="literal">false</span></span><br><span class="line"><span class="comment">// 定义浮点数类型变量并赋值</span></span><br><span class="line">score := <span class="number">0.2315</span></span><br><span class="line"><span class="comment">// 定义字符类型变量并赋值</span></span><br><span class="line">ch := <span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><p>在短变量定义中，我们同样可以一次定义多个变量，且多个变量的数据类型可以不同，Golang会根据值自动推断变量类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性定义name和age两个变量，且数据类型不同</span></span><br><span class="line">name, age := <span class="string">&quot;Ratel&quot;</span>, <span class="number">20</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %T&quot;</span>, name, age) <span class="comment">// Output: string int</span></span><br></pre></td></tr></table></figure><p>此时，name会被自动推断为string类型，age则被推断为int类型。</p><p>综上所述，使用var关键字可以定义不同类型的变量。同时，使用短变量定义语法也是一种常用的快捷方式来定义并初始化变量。</p><h3 id="3-2-作用域"><a href="#3-2-作用域" class="headerlink" title="3.2 作用域"></a>3.2 作用域</h3><p>Golang的变量还具有作用域和生命周期。在同一个作用域中，不能使用相同名称的变量。变量的生命周期由变量在内存中的存储时间来决定。变量的生命周期可以是全局、局部或动态分配的。</p><p>例如，以下是一个在函数内定义并初始化的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Ratel&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上例子中，变量name的作用域为main函数，在main函数外无法访问变量name，变量name的生命周期取决于变量name的创建和销毁时间。</p><h2 id="4-常量"><a href="#4-常量" class="headerlink" title="4 常量"></a>4 常量</h2><p>常量，顾名思义，与变量相反，常量用来存储各种数据类型有固定值且不可以改变的值。在Go语言中，常量<strong>Constant</strong>是在程序编译阶段就确定的值，它们在定义时必须赋予一个固定的初值，并且不能被修改。常量的定义和变量的定义有一些差异。</p><p>常量的定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 常量名 [类型] = 值</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> constantName [<span class="keyword">type</span>] = constantValue</span><br></pre></td></tr></table></figure><p>其中，const是关键字用于定义常量，常量名是你给常量起的名称，类型是常量的数据类型, 是可以省略的，表达式是常量的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整数常量</span></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span>   <span class="comment">// 定义一个浮点数类型的常量Pi，并初始化为3.14</span></span><br><span class="line"><span class="keyword">const</span> MaxSize <span class="type">int</span> = <span class="number">100</span>   <span class="comment">// 定义一个整数类型的常量MaxSize，并初始化为100</span></span><br><span class="line"><span class="comment">// 定义字符串常量</span></span><br><span class="line"><span class="keyword">const</span> Name = <span class="string">&quot;Ratel&quot;</span>   <span class="comment">// 定义一个字符串类型的常量Name，并初始化为&quot;Ratel&quot;</span></span><br><span class="line"><span class="comment">// 定义布尔常量</span></span><br><span class="line"><span class="keyword">const</span> IsDebug = <span class="literal">false</span>   <span class="comment">// 定义一个布尔类型的常量IsDebug，并初始化为false</span></span><br><span class="line"><span class="comment">// 定义多个常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Monday = <span class="number">1</span></span><br><span class="line">    Tuesday = <span class="number">2</span></span><br><span class="line">    Wednesday = <span class="number">3</span></span><br><span class="line">    Thursday = <span class="number">4</span></span><br><span class="line">    Friday = <span class="number">5</span></span><br><span class="line">    Saturday = <span class="number">6</span></span><br><span class="line">    Sunday = <span class="number">7</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里使用了括号和换行符来分组和格式化多个常量的定义。</p><blockquote><p>值得注意的是，在批量定义常量时，第一个常量的值默认被赋值为0，后续常量的值会根据前面的常量值自动递增。</p></blockquote><p>在Go语言中，常量可以用于各种常见的场景，例如定义数学常量、枚举值、配置参数等。它们具有不可变性，并且可以提高代码的可读性和可维护性。</p><p>需要注意的是，Go语言常量的类型是根据初值自动推导得出的，因此在大多数情况下，常量的类型定义是可选的。</p><p>综上所述，使用const关键字可以定义不同类型的常量，并为其赋予一个固定的初值。常量在编译时确定，并且不能被修改。</p><h2 id="5-基本数据类型"><a href="#5-基本数据类型" class="headerlink" title="5 基本数据类型"></a>5 基本数据类型</h2><hr><p>Go语言基本数据类型包括布尔类型、整数类型、浮点类型、复数类型、字符（串）类型五种类型，我们将依次介绍这些数据类型以及它们的操作。</p><blockquote><p>所有的基础类型都是值类型， 这意味着当它们作为参数传递或从函数返回时，它们通过值传递给函数。</p></blockquote><ol><li>布尔类型（Boolean Type）：</li></ol><ul><li>bool：表示真（true）或假（false）的布尔类型。</li></ul><ol start="2"><li>整数类型（Integer Types）：</li></ol><ul><li>int：根据平台可能是32位或64位的有符号整数。</li><li>uint：根据平台可能是32位或64位的无符号整数。</li><li>int8、int16、int32、int64：固定大小的有符号整数类型。</li><li>uint8、uint16、uint32、uint64：固定大小的无符号整数类型。</li><li>uintptr：用于存储指针的整数类型。</li></ul><ol start="3"><li>浮点数类型（Floating-Point Types）：</li></ol><ul><li>float32：IEEE-754 32位浮点数。</li><li>float64：IEEE-754 64位浮点数。</li></ul><ol start="4"><li>复数类型（Complex Types）：</li></ol><ul><li>complex64：包含32位实部和32位虚部的复数类型。</li><li>complex128：包含64位实部和64位虚部的复数类型。</li></ul><ol start="5"><li>字符类型（Character Type）：</li></ol><ul><li>byte：与uint8类型相同，用于表示ASCII字符。</li><li>rune：与int32类型相同，用于表示Unicode码点。</li></ul><ol start="6"><li>字符串类型（String Type）：</li></ol><ul><li>string：表示一系列字符的字符串类型。</li></ul><h3 id="5-1-布尔类型"><a href="#5-1-布尔类型" class="headerlink" title="5.1 布尔类型"></a>5.1 布尔类型</h3><p>在Go语言中，bool表示布尔类型，它只有两个可能的值：true和false。布尔类型用于表示逻辑条件的真假状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="type">bool</span> <span class="comment">// 声明一个布尔变量</span></span><br><span class="line">    b = <span class="literal">true</span>   <span class="comment">// 赋值为true</span></span><br><span class="line">    fmt.Println(b) <span class="comment">// 输出: true</span></span><br><span class="line">    <span class="comment">// 条件判断</span></span><br><span class="line">    <span class="keyword">if</span> b &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;b is true&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;b is false&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逻辑运算</span></span><br><span class="line">    x := <span class="literal">true</span></span><br><span class="line">    y := <span class="literal">false</span></span><br><span class="line">    fmt.Println(x &amp;&amp; y) <span class="comment">// 与运算, 输出: false</span></span><br><span class="line">    fmt.Println(x || y) <span class="comment">// 或运算, 输出: true</span></span><br><span class="line">    fmt.Println(!x)     <span class="comment">// 非运算, 输出: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在条件判断语句中，只能使用布尔类型的表达式作为条件。不能使用任意其他类型的值进行条件判断。</p></blockquote><h3 id="5-2-整数类型"><a href="#5-2-整数类型" class="headerlink" title="5.2 整数类型"></a>5.2 整数类型</h3><p>Go语言同时提供了有符号和无符号的整数类型，其中包括int8、int16、int32和int64四种大小截然不同的有符号整数类型，分别对应8、16、32、64 bit（二进制位）大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。</p><p>此外还有两种整数类型int和uint，它们分别对应特定CPU平台的字长（机器字大小），其中int表示有符号整数，应用最为广泛，uint表示无符号整数。实际开发中由于编译器和计算机硬件的不同，int和uint所能表示的整数大小会在32bit或64bit之间变化。</p><p>用来表示Unicode字符的rune类型和int32类型是等价的，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样，byte和uint8也是等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p><p>尽管在某些特定的运行环境下int、uint和uintptr的大小可能相等，但是它们依然是不同的类型，比如int和int32，虽然int类型的大小也可能是32bit，但是在需要把int类型当做int32类型使用的时候必须显示的对类型进行转换，反之亦然。</p><p>Go语言中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的取值范围是从-2(n-1) 到 2(n-1)-1。无符号整数的所有bit位都用于表示非负数，取值范围是0到2n-1。例如，int8类型整数的取值范围是从-128到127，而uint8类型整数的取值范围是从0到255。</p><p>最后，还有一种无符号的整数类型uintptr，它没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>  </span><br><span class="line">    <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">5</span>  </span><br><span class="line">    <span class="keyword">var</span> c <span class="type">uint</span> = <span class="number">15</span>  </span><br><span class="line">    <span class="keyword">var</span> d <span class="type">uint</span> = <span class="number">7</span>  </span><br><span class="line">  </span><br><span class="line">    sum := a + b       <span class="comment">// 加法运算  </span></span><br><span class="line">    diff := a - b      <span class="comment">// 减法运算  </span></span><br><span class="line">    product := a * b   <span class="comment">// 乘法运算  </span></span><br><span class="line">    quotient := a / b  <span class="comment">// 除法运算  </span></span><br><span class="line">    remainder := a % b <span class="comment">// 取模运算  </span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Sum:&quot;</span>, sum)          <span class="comment">// 输出: Sum: 15  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Difference:&quot;</span>, diff)   <span class="comment">// 输出: Difference: 5  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Product:&quot;</span>, product)   <span class="comment">// 输出: Product: 50  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Quotient:&quot;</span>, quotient) <span class="comment">// 输出: Quotient: 2  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Remainder:&quot;</span>, remainder) <span class="comment">// 输出: Remainder: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无符号整数的运算示例  </span></span><br><span class="line">    unsignedSum := c + d       <span class="comment">// 加法运算  </span></span><br><span class="line">    unsignedDiff := c - d      <span class="comment">// 减法运算  </span></span><br><span class="line">    unsignedProduct := c * d   <span class="comment">// 乘法运算  </span></span><br><span class="line">    unsignedQuotient := c / d  <span class="comment">// 除法运算  </span></span><br><span class="line">    unsignedRemainder := c % d <span class="comment">// 取模运算  </span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Sum:&quot;</span>, unsignedSum)          <span class="comment">// 输出: Unsigned Sum: 22  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Difference:&quot;</span>, unsignedDiff)   <span class="comment">// 输出: Unsigned Difference: 8  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Product:&quot;</span>, unsignedProduct)   <span class="comment">// 输出: Unsigned Product: 105  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Quotient:&quot;</span>, unsignedQuotient) <span class="comment">// 输出: Unsigned Quotient: 2  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsigned Remainder:&quot;</span>, unsignedRemainder) <span class="comment">// 输出: Unsigned Remainder: 1  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-浮点数类型"><a href="#5-3-浮点数类型" class="headerlink" title="5.3 浮点数类型"></a>5.3 浮点数类型</h3><p>float32是32位的浮点数类型，它可以表示大约6个小数位的精度。这种类型适用于对内存占用有限且精度要求不高的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="type">float32</span> = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>float64是64位的浮点数类型，它可以表示大约15个小数位的精度。这种类型适用于需要更高精度的计算或涉及较大数值范围的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num2 <span class="type">float64</span> = <span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><p>注意，如果没有指定具体的浮点数类型，默认情况下，Go语言会将浮点数值视为float64类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num3 = <span class="number">3.14</span> <span class="comment">//默认为float64类型</span></span><br></pre></td></tr></table></figure><p>简单四则运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="type">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">    b := <span class="type">float32</span>(<span class="number">2.5</span>)</span><br><span class="line">    sum := a + b            <span class="comment">// 加法运算</span></span><br><span class="line">    diff := a - b           <span class="comment">// 减法运算</span></span><br><span class="line">    product := a * b        <span class="comment">// 乘法运算</span></span><br><span class="line">    quotient := a / b       <span class="comment">// 除法运算</span></span><br><span class="line">    fmt.Println(sum)        <span class="comment">// 输出: 5.6400003</span></span><br><span class="line">    fmt.Println(diff)       <span class="comment">// 输出: 0.6400001</span></span><br><span class="line">    fmt.Println(product)    <span class="comment">// 输出: 7.8500004</span></span><br><span class="line">    fmt.Println(quotient)   <span class="comment">// 输出: 1.256</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-1-注意事项"><a href="#5-3-1-注意事项" class="headerlink" title="5.3.1 注意事项"></a>5.3.1 注意事项</h4><ul><li>浮点数不适合用于精确计算，因为它们是基于二进制表示的近似值。在进行计算时可能会出现舍入误差。</li><li>不要使用等号（&#x3D;&#x3D;）来比较两个浮点数是否相等，因为舍入误差可能导致结果不准确。通过定义一个误差范围来判断浮点数是否接近。例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">epsilon := <span class="number">1e-9</span> <span class="comment">// 定义一个小的误差范围</span></span><br><span class="line"><span class="keyword">if</span> math.Abs(f1-f2) &lt; epsilon &#123;</span><br><span class="line">    <span class="comment">// 浮点数接近</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>浮点数运算可能会导致溢出或下溢。务必注意结果是否在所选类型的范围内。</li><li>避免在循环中使用浮点数作为循环控制条件，因为舍入误差可能导致无限循环或提前退出循环。</li><li>在使用浮点数进行计算时，可以通过引入math包来执行更复杂的数学操作，例如开方、幂等等。</li><li>尽量使用float64类型，除非有特别的需求。虽然float32占用的内存更小，但float64提供了更高的精度，并且在大多数情况下，性能影响不大。</li></ul><p>总结起来，虽然Go提供了浮点类型进行小数运算，但需要注意浮点数的近似性、舍入误差和比较等问题。如果需要精确计算，应考虑使用整数类型或专门的十进制数库。</p><h3 id="5-4-复数类型"><a href="#5-4-复数类型" class="headerlink" title="5.4 复数类型"></a>5.4 复数类型</h3><p>在Go语言中，复数类型用于表示复数数值。Go语言中的复数类型是内置的，由complex64和complex128两种类型组成。</p><blockquote><p>complex64类型表示一个复数，其中实部和虚部都是float32类型。complex128类型表示一个复数，其中实部和虚部都是float64类型。</p></blockquote><p>复数有两种定义方式，一种是通过complex(a, b)声明，其中a是实部，b是虚部，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// complex</span></span><br><span class="line"><span class="keyword">var</span> c1 <span class="type">complex64</span> = <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">6</span>) </span><br></pre></td></tr></table></figure><p>另外一种是通过a + bi方式声明，其中a是实部，b是虚部，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a + bi</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">complex64</span> = <span class="number">2</span> + <span class="number">3i</span></span><br></pre></td></tr></table></figure><p>然后我们看一些关于复数的一些计算操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c1 <span class="type">complex64</span> = <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">var</span> c2 <span class="type">complex64</span> = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;real(c1) =&quot;</span>, <span class="built_in">real</span>(c1)) <span class="comment">// 获取实部，输出: 4</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;imag(c1) =&quot;</span>, <span class="built_in">imag</span>(c1)) <span class="comment">// 获取虚部，输出: 6</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mod(c1) =&quot;</span>, Mod(c1))   <span class="comment">// 获取模长，输出：7.211102550927978</span></span><br><span class="line">    sum := c1 + c2</span><br><span class="line">    diff := c1 - c2</span><br><span class="line">    product := c1 * c2</span><br><span class="line">    quotient := c1 / c2</span><br><span class="line">    fmt.Println(sum)      <span class="comment">// 输出: 6+9i</span></span><br><span class="line">    fmt.Println(diff)     <span class="comment">// 输出: 2+3i</span></span><br><span class="line">    fmt.Println(product)  <span class="comment">// 输出: -10+24i</span></span><br><span class="line">    fmt.Println(quotient) <span class="comment">// 输出: 2+0i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算复数的模</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mod</span><span class="params">(c <span class="type">complex64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    a := <span class="built_in">real</span>(c) * <span class="built_in">real</span>(c)</span><br><span class="line">    b := <span class="built_in">imag</span>(c) * <span class="built_in">imag</span>(c)</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(<span class="type">float64</span>(a + b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意精度：在使用复数进行计算时，需要注意浮点数的精度问题。由于浮点数精度的限制，复数计算可能会产生舍入误差。因此，在比较复数是否相等时，不应该直接使用&#x3D;&#x3D;运算符，而应该使用近似判断方法，如判断实部和虚部的差值是否在允许的误差范围内。</p></blockquote><p>Go语言还提供了math&#x2F;cmplx包，其中包含一些用于复数计算的函数，如求模、幅角、共轭等。你可以根据需要使用这些函数来进行更复杂的复数计算。</p><p>总之，复数类型在Go语言中提供了处理复数数值的能力，可以进行基本的复数计算操作，用于涉及复数计算、信号处理、物理模拟、图像处理和控制系统等领域。但需要注意浮点数精度和比较的问题，以及根据需求使用适当的复数运算函数和库。</p><h3 id="5-5-字符类型"><a href="#5-5-字符类型" class="headerlink" title="5.5 字符类型"></a>5.5 字符类型</h3><p>字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。</p><p>Go语言的字符有以下两种：</p><ul><li>一种是byte类型，或者叫uint8型，代表了ASCII码的一个字符。</li><li>一种是rune类型，代表一个UTF-8字符，当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型等价于int32类型。它实际上是一个32位的整数类型。rune类型可以用来存储Unicode码点（Unicode code point）。要定义一个字符变量，可以使用单引号将字符括起来。</li></ul><p>byte类型是uint8的别名，对于只占用1个字节的传统ASCII编码的字符来说，完全没有问题，例如 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;A&#x27;</span> <span class="comment">//字符使用单引号括起来</span></span><br></pre></td></tr></table></figure><p>在ASCII码表中，A的值是65，使用16进制表示则为41，所以下面的写法是等效的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span> = <span class="number">65</span> 或 <span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;\x41&#x27;</span>  <span class="comment">//（\x 总是紧跟着长度为2的16进制数）</span></span><br></pre></td></tr></table></figure><p>另外一种可能的写法是\后面紧跟着长度为3的八进制数，例如\377。</p><p>Go语言同样支持Unicode（UTF-8），因此字符同样称为Unicode代码点或者runes，并在内存中使用int来表示。在文档中，一般使用格式U+hhhh来表示，其中h表示一个16进制数。</p><p>在书写Unicode字符时，需要在16进制数之前加上前缀\u或者\U。因为Unicode至少占用2个字节，所以我们使用 int16或者int类型来表示。如果需要使用到4字节，则使用\u前缀，如果需要使用到8个字节，则使用\U前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">int</span> = <span class="string">&#x27;\u0041&#x27;</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="type">int</span> = <span class="string">&#x27;\u03B2&#x27;</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="type">int</span> = <span class="string">&#x27;\U00101234&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d - %d - %d\n&quot;</span>, ch, ch2, ch3) <span class="comment">// integer</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c - %c - %c\n&quot;</span>, ch, ch2, ch3) <span class="comment">// character</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X - %X - %X\n&quot;</span>, ch, ch2, ch3) <span class="comment">// UTF-8 bytes</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%U - %U - %U&quot;</span>, ch, ch2, ch3)   <span class="comment">// UTF-8 code point</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">65</span> - <span class="number">946</span> - <span class="number">1053236</span></span><br><span class="line">A - β - r</span><br><span class="line"><span class="number">41</span> - <span class="number">3</span>B2 - <span class="number">101234</span></span><br><span class="line">U+<span class="number">0041</span> - U+<span class="number">03</span>B2 - U+<span class="number">101234</span></span><br></pre></td></tr></table></figure><p>格式化说明符%c用于表示字符，当和字符配合使用时，%v或%d会输出用于表示该字符的整数，%U输出格式为U+hhhh的字符串。</p><p>Unicode包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中ch代表字符）：<br>判断是否为字母：<code>unicode.IsLetter(ch)</code><br>判断是否为数字：<code>unicode.IsDigit(ch)</code><br>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></p><p>Unicode与ASCII类似，都是一种字符集。</p><p>字符集为每个字符分配一个唯一的ID，我们使用到的所有字符在Unicode字符集中都有一个唯一的 ID，例如上面例子中的 a 在 Unicode 与 ASCII 中的编码都是 97。汉字“你”在 Unicode 中的编码为 20320，在不同国家的字符集中，字符所对应的 ID 也会不同。而无论任何情况下，Unicode 中的字符的 ID 都是不会变化的。</p><p>UTF-8是编码规则，将Unicode中字符的ID以某种方式进行编码，UTF-8是一种变长编码规则，从1到4个字节不等。编码规则如下：<br>0xxxxxx表示文字符号0～127，兼容ASCII字符集。<br>从128到0x10ffff表示其他字符。</p><p>根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用3个字节。</p><p>广义的Unicode指的是一个标准，它定义了字符集及编码规则，即Unicode字符集和UTF-8、UTF-16编码等。</p><h3 id="5-6-字符串类型"><a href="#5-6-字符串类型" class="headerlink" title="5.6 字符串类型"></a>5.6 字符串类型</h3><p>Go语言中的字符串类型用string关键字表示。字符串是不可变的序列，可以包含任意Unicode字符。可以使用双引号或反引号将字符串括起来。</p><p>在Go中，字符串是一种基本数据类型，其值是Unicode码点（code point）序列，通常被解释为UTF-8编码的字节序列。在Go语言中，字符串的底层数据结构是一个只读的字节数组，也就是一组连续的字节。</p><p>一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8字符的一个序列（当字符为ASCII码表上的字符时则占用1个字节，其它字符根据需要占用2-4个字节）。</p><p>字符串类型在Go语言中使用双引号（”）或反引号（&#96;）括起来，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;Hello, World!&quot;</span> <span class="comment">// 使用双引号括起来的字符串</span></span><br><span class="line">str2 := <span class="string">`This is a multiline </span></span><br><span class="line"><span class="string">string using backticks`</span>  <span class="comment">// 使用反引号括起来的多行字符串</span></span><br></pre></td></tr></table></figure><p>字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\n：换行符</span><br><span class="line">\r：回车符</span><br><span class="line">\t：TAB键</span><br><span class="line">\u或\U：Unicode字符</span><br><span class="line">\\：反斜杠自身</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;这是我的\nGo语言教程&quot;</span></span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是我的</span><br><span class="line">Go语言教程</span><br></pre></td></tr></table></figure><p>以下是一些常见的字符串操作：</p><p>1.字符串长度：可以使用内置函数<code>len()</code>获取字符串的长度，即字符的个数。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">length := <span class="built_in">len</span>(str) <span class="comment">// 获取字符串的长度</span></span><br><span class="line">fmt.Println(length) <span class="comment">// 输出：13</span></span><br></pre></td></tr></table></figure><p>2.字符串索引和切片：可以通过索引访问字符串中的单个字符，索引从0开始。还可以使用切片操作提取子字符串，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">char := str[<span class="number">0</span>] <span class="comment">// 获取第一个字符&#x27;H&#x27;</span></span><br><span class="line">substr := str[<span class="number">7</span>:<span class="number">12</span>] <span class="comment">// 提取子字符串&quot;World&quot;</span></span><br></pre></td></tr></table></figure><p>3.字符串拼接：可以使用加号（+）运算符将两个字符串连接起来，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;World&quot;</span></span><br><span class="line">result := str1 + <span class="string">&quot; &quot;</span> + str2 <span class="comment">// 拼接字符串为&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>4.字符串比较：可以使用比较运算符（&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;）对字符串进行比较，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="keyword">if</span> str1 == str2 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Strings are equal&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Strings are not equal&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.字符串遍历：可以使用<code>for range</code>循环遍历字符串中的字符。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>, char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.其他类型转化成字符串<br><strong>strconv</strong>包是关于字符串转化的工具集。</p><ul><li>整数转字符串：使用<code>strconv.Itoa()</code>函数将整数类型转换为字符串。</li><li>浮点数转字符串：使用<code>strconv.FormatFloat()</code>函数将浮点数类型转换为字符串。</li><li>布尔值转字符串：可以直接使用<code>strconv.FormatBool()</code>将布尔值转换为字符串。</li><li>其他类型转字符串：可以使用<code>fmt.Sprintf()</code>函数将其他类型转换为字符串。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将整数转换为字符串</span></span><br><span class="line">    str1 := strconv.Itoa(<span class="number">42</span>) </span><br><span class="line">    <span class="comment">// 将浮点数转换为字符串, 第一个参数是要转换的浮点数，第二个参数是格式，第三个参数是小数点的精度（-1表示不限制），最后一个参数是指定浮点数的位数（32或64）。</span></span><br><span class="line">    str2 := strconv.FormatFloat(num, <span class="string">&#x27;f&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="comment">// 将布尔值转换为字符串</span></span><br><span class="line">    str3 := strconv.FormatBool(<span class="literal">true</span>) </span><br><span class="line">    <span class="comment">// 将其他类型转换为字符串，其中%d是格式化字符串中的占位符，用于指定要转换的类型。</span></span><br><span class="line">    str4 := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, num) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go语言中，<code>fmt.Sprintf</code>函数可以使用不同的数据类型的占位符来格式化字符串。以下是一些常见的占位符及其对应的类型：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%d：表示整数类型（int、int8、int16、int32、int64等）。</span><br><span class="line">%f：表示浮点数类型（float32、float64）。</span><br><span class="line">%s：表示字符串类型（string）。</span><br><span class="line">%t：表示布尔类型（bool）。</span><br><span class="line">%v：表示通用占位符，可以用于任何类型。它会根据值的类型进行适当的格式化。</span><br></pre></td></tr></table></figure><p>除了这些常见的占位符之外，还有一些其他的占位符可以用于特定类型的数据。以下是一些额外的占位符：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%b：表示二进制数（整数类型以二进制格式输出）。</span><br><span class="line">%x：表示十六进制数（整数类型以十六进制格式输出）。</span><br><span class="line">%X：表示大写十六进制数（整数类型以大写格式的十六进制输出）。</span><br><span class="line">%o：表示八进制数（整数类型以八进制格式输出）。</span><br><span class="line">%u：表示无符号整数类型（如uint、uintptr等）。</span><br><span class="line">%c：表示字符类型（rune类型，Unicode码点）。</span><br></pre></td></tr></table></figure><p>这些占位符可以用于格式化字符串中的特定类型的数据。通过使用适当的占位符，你可以控制数据的输出格式，以满足你的需求。</p><blockquote><p>需要注意的是，以上方法适用于将基本类型转换为字符串。如果需要将自定义类型转换为字符串，可以在自定义类型的方法中实现String()函数来定义其字符串表示形式。</p></blockquote><p>7.字符串转化成其他类型</p><ul><li>字符串转整数：使用<code>strconv.Atoi()</code>函数将字符串转换为整数类型。</li><li>字符串转浮点数：使用<code>strconv.ParseFloat()</code>函数将字符串转换为浮点数类型。</li><li>字符串转布尔值：使用<code>strconv.ParseBool()</code>将字符串转换为布尔类型。</li><li>字符串转复数类型：使用<code>strconv.ParseComplex()</code>函数将字符串转换为复数类型。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num1, err := strconv.Atoi(<span class="string">&quot;54&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;转换失败:&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;转换结果:&quot;</span>, num1)  </span><br><span class="line"></span><br><span class="line">    num2, err := strconv.ParseFloat(<span class="string">&quot;3.14&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;转换失败:&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;转换结果:&quot;</span>, num2) </span><br><span class="line"></span><br><span class="line">    num3, err := strconv.ParseBool(<span class="string">&quot;true&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;转换失败:&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;转换结果:&quot;</span>, num3) </span><br><span class="line">    </span><br><span class="line">    num4, err := strconv.ParseComplex(<span class="string">&quot;1+2i&quot;</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        fmt.Println(<span class="string">&quot;转换失败:&quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;转换结果:&quot;</span>, num4) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>以上这些函数尝试将字符串解析为指定的类型，并返回解析后的值和可能的错误。在使用这些函数时，记得检查返回的错误以确保转换成功。<br>8.字符串、byte、rune关系和转换</p></blockquote></li></ul><p>在Go语言中，字符串底层是一个只读的字节数组，也就是[]byte类型，但是因为字符串是只读的，所以需要使用 rune类型来表示Unicode字符，而不是byte类型。因此，我们可以简单地把string类型看成是一个包含了若干个 rune类型的数组，其中每个rune表示一个Unicode字符。</p><ul><li>[]byte 转 string：使用 string() 方法将字节数组转为字符串类型。</li><li>string 转 []byte：使用 []byte() 方法将字符串类型转为字节数组。</li><li>string 转 []rune：使用 []rune() 方法将字符串类型转为rune数组。</li><li>[]rune 转 string：使用 string() 方法将rune数组转为字符串类型。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// []byte 转 string</span></span><br><span class="line">bytes := []<span class="type">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(bytes)  <span class="comment">// &quot;ABCD&quot;</span></span><br><span class="line"><span class="comment">// string 转 []byte</span></span><br><span class="line">str := <span class="string">&quot;ABCD&quot;</span></span><br><span class="line">bytes := []<span class="type">byte</span>(str)  <span class="comment">// [65 66 67 68]</span></span><br><span class="line"><span class="comment">// string 转 []rune</span></span><br><span class="line">str := <span class="string">&quot;ABCD&quot;</span></span><br><span class="line">runes := []<span class="type">rune</span>(str)  <span class="comment">// [65 66 67 68]</span></span><br><span class="line"><span class="comment">// []rune 转 string</span></span><br><span class="line">runes := []<span class="type">rune</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>&#125;</span><br><span class="line">str := <span class="type">string</span>(runes)  <span class="comment">// &quot;ABCD&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，虽然Go语言的字符串是Unicode编码的，但是它并不是固定长度的。因为一个 Unicode 字符可能由多个字节组成，所以在Go语言中，使用UTF-8编码来表示 Unicode 字符，一个字符可能由1到4个字节组成。因此，在处理字符串时，需要注意字符的长度和字节的长度并不是一一对应的关系。</p></blockquote></li></ul><p>另外，<strong>strings</strong>包中提供了很多关于字符串操作的方法，总而言之，Go语言的字符串类型提供了一系列的操作和函数，可用于处理文本、字符串拼接、搜索和解析等任务。</p><h3 id="5-7-引用类型和非引用类型"><a href="#5-7-引用类型和非引用类型" class="headerlink" title="5.7 引用类型和非引用类型"></a>5.7 引用类型和非引用类型</h3><p>在Go语言中，有两种类型的数据类型：引用类型和非引用类型。</p><ul><li><p>基本数据类型（如int、float、bool、string等）是<strong>非引用类型</strong>。这些类型的变量在内存中分配的是实际值的空间。当传递这些变量时，函数会复制实际值而不是变量本身。在处理基本数据类型时，我们使用值传递。</p></li><li><p>引用类型（如slice、map、channel、interface和函数类型）则是指向底层数据结构的指针的包装器。这些类型的变量在内存中分配的是指向底层数据结构的指针，而不是实际值的空间。在处理引用类型时，我们使用指针传递。</p></li><li><p>指针类型是一种特殊的引用类型，用于指向变量的内存地址。指针变量保存的是变量的地址，而不是实际值。使用指针类型可以通过指针间接访问变量，也可以在函数中传递指针以通过指针访问原始变量。</p></li></ul><h2 id="6-编码"><a href="#6-编码" class="headerlink" title="6 编码"></a>6 编码</h2><p>在计算机中，编码是将一种形式的数据转换为另一种形式的过程。</p><p>在Golang中，编码是指将一组字符或字符串转换为一组字节或二进制数据的过程，通常用于将数据在网络或存储介质中进行传输或存储。</p><p>Golang中支持的编码方式有多种，包括ASCII、UTF-8、UTF-16、UTF-32等。下面简要介绍几种常见的编码方式：</p><ul><li>ASCII 编码：ASCII编码使用一个字节来表示一个字符，即采用8位二进制数表示一个字符，共可以表示2^8 &#x3D; 256 种不同的字符。</li><li>UTF-8 编码：UTF-8 是一种可变长度的编码方式，使用1~4个字节来表示一个字符。对于ASCII字符，使用一个字节表示；对于中文、韩文等字符，使用3个字节表示；对于某些特殊字符，如表情符号等，需要使用4个字节表示。因此，一个字符串的长度并不等于它所占用的字节数，它由其中的字符数量决定。</li><li>UTF-16 编码：UTF-16使用2个字节来表示一个字符，对于 ASCII 字符，使用一个字节表示；对于大多数中文、日文、韩文等字符，使用2个字节表示；对于某些特殊字符，需要使用4个字节表示。</li><li>UTF-32 编码：UTF-32使用4个字节来表示一个字符，无需考虑可变长度的问题，但对于大部分字符而言，会造成空间浪费。<br>在Golang中，字符串默认采用UTF-8编码，每个字符占用1~4个字节。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于ASCII字符，使用一个字节表示；</span><br><span class="line">对于中文、韩文等字符，使用3个字节表示；</span><br><span class="line">对于某些特殊字符，如表情符号等，需要使用4个字节表示。</span><br></pre></td></tr></table></figure>Go中还提供了很多用于处理不同编码方式的库和函数，如encoding&#x2F;json、encoding&#x2F;base64、unicode&#x2F;utf8等。这些库和函数可以帮助开发者在不同编码方式之间进行转换和处理。</li></ul><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><p>什么是指针？有过C\C++开发经验的同学一定非常熟悉指针，同样在Go语言中也一样，指针是一个变量，它存储了另一个变量的内存地址。因此，指针变量指向的是另一个变量的内存地址，后面我们会说明Go语言中指针和C\C++指针有啥区别。</p><p>定义指针变量时，需要在变量名前加上*，表示这是一个指针变量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br></pre></td></tr></table></figure><p>这表示定义了一个名为p的指向整型变量的指针。使用&amp;运算符可以取得一个变量的地址，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line">p := &amp;x</span><br></pre></td></tr></table></figure><p>这表示取得变量x的地址，并将地址赋给指针变量p。<br>使用指针访问变量时，需要使用*运算符，它表示解引用操作符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line">p := &amp;x</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>这表示打印出指针变量p指向的变量的值，即变量x的值。</p><p>除了定义指针变量和获取变量的地址之外，还可以使用new函数来创建指针变量。例如，创建一个指向整型变量的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>这将创建一个新的整型变量，并返回它的地址，然后将地址赋给指针变量p。</p><p>指针还可以用于函数参数和返回值，以便在函数调用之间共享数据。</p><p>在使用指针时需要小心，因为如果指针指向一个无效的内存地址，程序可能会崩溃或产生不可预测的行为。因此，使用指针时需要确保指针指向的内存地址是有效的。</p><h3 id="7-1-指针函数传参"><a href="#7-1-指针函数传参" class="headerlink" title="7.1 指针函数传参"></a>7.1 指针函数传参</h3><p>指针可以用于函数参数的传递，当一个函数需要修改实参的值时，可以将实参的地址作为形参传递给函数，通过操作指针来达到修改实参的值的目的。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(str *<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    *str = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    modify(&amp;str)</span><br><span class="line">    fmt.Println(str) <span class="comment">// 输出：hello, world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-指针访问结构体字段"><a href="#7-2-指针访问结构体字段" class="headerlink" title="7.2 指针访问结构体字段"></a>7.2 指针访问结构体字段</h3><p>通过指针可以更方便地访问结构体中的字段，特别是当结构体很大时，传递指针比较传递整个结构体更高效。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := &amp;Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        Age:  <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    p.Name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    fmt.Println(p) <span class="comment">// 输出：&amp;&#123;Bob 18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-通过指针动态分配内存"><a href="#7-3-通过指针动态分配内存" class="headerlink" title="7.3 通过指针动态分配内存"></a>7.3 通过指针动态分配内存</h3><p>通过指针可以在运行时动态地分配内存，比如使用<code>new()</code>函数创建一个新的变量并返回它的地址。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *p = <span class="number">42</span></span><br><span class="line">    fmt.Println(*p) <span class="comment">// 输出：42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-传递可变参数"><a href="#7-4-传递可变参数" class="headerlink" title="7.4 传递可变参数"></a>7.4 传递可变参数</h3><p>在Golang中，可以使用指针传递可变参数。这是因为在使用可变参数时，传递的是一个切片（slice），而切片本身就是指向一个数组的指针。这样的操作，可以避免拷贝大量的数据。</p><p>例如，考虑以下函数，它接受一个可变参数并将其打印出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArgs</span><span class="params">(args ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果要将切片作为参数传递给另一个函数，可以使用指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArgsPtr</span><span class="params">(args *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> *args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    args := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    printArgsPtr(&amp;args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个新函数printArgsPtr，它使用指针作为参数来接收切片。函数体内，我们使用*args来解引用指针，从而得到实际的切片，并遍历它以打印每个元素。在主函数中，我们创建了一个切片，并将其地址传递给printArgsPtr函数。</p><blockquote><p>需要注意的是，在使用指针传递变长参数时，如果切片为空，则不能传递nil指针，而应该传递一个空的切片。这是因为在Golang中，使用空的切片和nil指针的含义不同，后面会介绍。</p></blockquote><p>除了上述几个方面，指针在一些特定的场景下也非常有用，比如在处理数据结构时，通过指针可以更高效地操作链表、树等数据结构。但需要注意，过度使用指针可能会导致代码难以维护，需要谨慎使用。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>通过深入学习Go语言基本数据类型，您将能够更好地理解和掌握这些基本数据类型的特性和用法。无论您是初学者还是有经验的开发人员，对基本数据类型的深入理解都是成为一位优秀的Go语言程序员的关键，下一张我们将讲解复合数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础语法 </tag>
            
            <tag> 基本数据类型 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试重点</title>
      <link href="/article/9351.html"/>
      <url>/article/9351.html</url>
      
        <content type="html"><![CDATA[<h3 id="1）Redis为什么使用单进程单线程方式也这么快"><a href="#1）Redis为什么使用单进程单线程方式也这么快" class="headerlink" title="1）Redis为什么使用单进程单线程方式也这么快"></a>1）Redis为什么使用单进程单线程方式也这么快</h3><p>Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。</p><span id="more"></span><p>Redis快的主要原因是：</p><ol><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I&#x2F;O 复用模型</li></ol><p>多路 I&#x2F;O 复用模型是利用select、poll、epoll可以同时监察多个流的 I&#x2F;O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I&#x2F;O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p>和Memcached不同，Redis并没有直接使用Libevent，而是自己完成了一个非常轻量级的对select、epoll、evport、kqueue这些通用的接口的实现。在不同的系统调用选用适合的接口，linux下默认是epoll。因为Libevent比较重更通用代码量也就很庞大，拥有很多Redis用不上的功能，Redis为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。</p><h4 id="单进程单线程好处"><a href="#单进程单线程好处" class="headerlink" title="单进程单线程好处"></a>单进程单线程好处</h4><ul><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ul><h4 id="单进程单线程弊端"><a href="#单进程单线程弊端" class="headerlink" title="单进程单线程弊端"></a>单进程单线程弊端</h4><p>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</p><h4 id="其他一些优秀的开源软件采用的模型"><a href="#其他一些优秀的开源软件采用的模型" class="headerlink" title="其他一些优秀的开源软件采用的模型"></a>其他一些优秀的开源软件采用的模型</h4><ul><li>多进程单线程模型：Nginx</li><li>单进程多线程模型：Memcached</li></ul><h3 id="2）五种类型数据类型"><a href="#2）五种类型数据类型" class="headerlink" title="2）五种类型数据类型"></a>2）五种类型数据类型</h3><p>字符串、列表、散列表，集合、有序集合</p><h3 id="3）内存中数据持久化"><a href="#3）内存中数据持久化" class="headerlink" title="3）内存中数据持久化"></a>3）内存中数据持久化</h3><p>使用复制来扩展读性能：复制到多台服务器、提高读性能和可用性</p><p>使用分区来扩展写性能【hash一致性算法】：当数据量大的时候,把数据分散存入多个数据库中,减少单节点的连接压力</p><p>特点</p><ul><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I&#x2F;O 复用模型</li></ul><h3 id="4）Redis-适用场景"><a href="#4）Redis-适用场景" class="headerlink" title="4）Redis 适用场景"></a>4）Redis 适用场景</h3><ol><li>缓存 将热点数据放到内存中</li><li>消息队列 List 类型是双向链表，很适合用于消息队列</li><li>计数器 快速、频繁读写操作；string的单线性自增减 ++ –</li><li>共同好友关系 set 交集运算，很容易就可以知道用户的共同好友</li><li>排名 zset有序集合</li></ol><h3 id="5）持久化"><a href="#5）持久化" class="headerlink" title="5）持久化"></a>5）持久化</h3><p>快照持久化</p><p>将某个时间点的所有数据都存放到硬盘上</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本</p><p>缺点：故障可能丢失最后一次创建快照之后的数据；如果数据量很大，保存快照的时间也会很长。</p><p>AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾</p><ul><li>always： 每个写命令都同步，严重减低服务器的性能；</li><li>everysec ：每秒同步一次，比较合适，保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no ：让操作系统来决定何时同步，不能给性能带来提升，且会增加奔溃时数据丢失量</li></ul><p> </p><p>随着服务器写请求的增多，AOF 文件会越来越大；Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><p>对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，操作系统决定何时写</p><p>用户可以调用 file.flush() 方法请求尽快将缓冲区存储的数据同步到硬盘</p><p>redis主从复制 分布式数据同步方式</p><p>slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器</p><p>从服务器连接主服务器的过程</p><ul><li>主服务器创建快照文件，发送给从服务器。同时记录其间执行的写命令，发送完毕后，开始向从服务器发送写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器的快照文件，然后开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令</li></ul><p>主从链 创建一个中间层来分担主服务器的复制工作</p><ul><li>随着负载不断上升，主服务器可能无法很快地更新所有从服务器</li><li>重新连接和重新同步从服务器将导致系统超载</li><li>中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器</li></ul><h3 id="6）redis-主服务器-故障-处理"><a href="#6）redis-主服务器-故障-处理" class="headerlink" title="6）redis 主服务器 故障 处理"></a>6）redis 主服务器 故障 处理</h3><p>当主服务器出现故障时，Redis 常用的做法是新开一台服务器作为主服务器，具体步骤如下：假设 A 为主服务器，B 为从服务器，当 A 出现故障时，让 B 生成一个快照文件，将快照文件发送给 C，并让 C 恢复快照文件的数据。最后，让 B 成为 C 的从服务器。</p><h3 id="7）分片-集群-读并发"><a href="#7）分片-集群-读并发" class="headerlink" title="7）分片 集群 读并发"></a>7）分片 集群 读并发</h3><p>数据划分为多个部分，可以将数据存储到多台机器里，作用：负载均衡、线性级别的性能提升</p><h3 id="8）分片方式："><a href="#8）分片方式：" class="headerlink" title="8）分片方式："></a>8）分片方式：</h3><p>客户端代码分片</p><ul><li>Redis Sharding，对Redis数据的key进行hash，相同的key到相同的节点上</li><li>一致性哈希算法</li><li>代理服务器分片 轮询round-bin</li></ul><h3 id="9）redis与数据库的同步-数据一致"><a href="#9）redis与数据库的同步-数据一致" class="headerlink" title="9）redis与数据库的同步 数据一致"></a>9）redis与数据库的同步 数据一致</h3><ul><li><p>一致性要求高场景，实时同步方案，即查询redis，若查询不到再从DB查询，保存到redis；</p></li><li><p>更新redis时，先更新数据库，再将redis内容设置为过期(建议不要去更新缓存内容，直接设置缓存过期)，再用ZINCRBY增量修正redis数据</p></li><li><p>并发程度高的，采用异步队列的方式，采用kafka等消息中间件处理消息生产和消费</p></li><li><p>阿里的同步工具canal，实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发redis的更新，解放程序员双手，减少工作量</p></li><li><p>利用mysql触发器的API进行编程,c&#x2F;c++语言实现，学习成本高。</p></li></ul><h3 id="10）热数据与Mysql的同步编码实现-数据库上锁"><a href="#10）热数据与Mysql的同步编码实现-数据库上锁" class="headerlink" title="10）热数据与Mysql的同步编码实现 数据库上锁"></a>10）热数据与Mysql的同步编码实现 数据库上锁</h3><p>热点数据（经常会被查询，但是不经常被修改或者删除的数据），首选是使用redis缓存</p><p>用spring的AOP来构建redis缓存的自动生产和清除，过程如下：</p><ul><li>Select 数据库前查询redis，有的话使用redis数据，放弃select 数据库，没有的话，select 数据库，然后将数据插入redis</li><li>update或者delete 数据库数据<ul><li>高并发的情况下：先对数据库加锁，再删除redis</li><li>查询redis是否存在该数据，若存在则先对数据库加行锁，再删除redis，再update或者delete数据库中数据</li></ul></li><li>update或者delete redis，先更新数据库，再将redis内容设置为过期(建议不要去更新缓存内容，直接设置缓存过期)</li></ul><p> </p><p>出错场景：update先删掉了redis中的该数据，这时另一个线程执行查询，发现redis中没有，瞬间执行了查询SQL，并且插入到redis</p><h3 id="11）缓存穿透，缓存击穿，缓存雪崩解决方案分析"><a href="#11）缓存穿透，缓存击穿，缓存雪崩解决方案分析" class="headerlink" title="11）缓存穿透，缓存击穿，缓存雪崩解决方案分析"></a>11）缓存穿透，缓存击穿，缓存雪崩解决方案分析</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>我们的目标是：尽量少的线程构建缓存(甚至是一个) + 数据一致性 + 较少的潜在危险</p><p><a href="https://www.cnblogs.com/raichen/p/7750165.html">https://www.cnblogs.com/raichen/p/7750165.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引使用和优化</title>
      <link href="/article/52980.html"/>
      <url>/article/52980.html</url>
      
        <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引； </p><span id="more"></span><p>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替： </p><ul><li>正确选择复合索引中的主列字段，一般是选择性较好的字段； </li><li>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否  极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； </li><li>如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； </li><li>如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； </li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；<br>8、频繁进行数据操作的表，不要建立太多的索引；<br>9、删除无用的索引，避免对执行计划造成负面影响；</li></ul><p>以上是一些普遍的建立索引时的判断依据。索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。</p><p> 因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。 另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 </p><p>总的来说，小型表肯定不建索引，或者数据库记录在亿条数据级以上，还是建议使用非关系型数据库。 还有些特殊字段的数据库，比如BLOB，CLOB字段肯定也不适合建索引。</p><h3 id="对千万级MySQL数据库建立索引的事项及提高性能的手段"><a href="#对千万级MySQL数据库建立索引的事项及提高性能的手段" class="headerlink" title="对千万级MySQL数据库建立索引的事项及提高性能的手段"></a>对千万级MySQL数据库建立索引的事项及提高性能的手段</h3><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>首先，应当考虑表空间和磁盘空间是否足够。我们知道索引也是一种数据，在建立索引的时候势必也会占用大量表空间。因此在对一大表建立索引的时候首先应当考虑的是空间容量问题。<br>其次，在对建立索引的时候要对表进行加锁，因此应当注意操作在业务空闲的时候进行。</p><h4 id="性能调整方面"><a href="#性能调整方面" class="headerlink" title="性能调整方面"></a>性能调整方面</h4><p>首当其冲的考虑因素便是磁盘I&#x2F;O。物理上，应当尽量把索引与数据分散到不同的磁盘上（不考虑阵列的情况）。逻辑上，数据表空间与索引表空间分开。这是在建索引时应当遵守的基本准则。<br>其次，我们知道，在建立索引的时候要对表进行全表的扫描工作，因此，应当考虑调大初始化参数db_file_multiblock_read_count的值。一般设置为32或更大。</p><p>再次，建立索引除了要进行全表扫描外同时还要对数据进行大量的排序操作，因此，应当调整排序区的大小。<br>    9i之前，可以在session级别上加大sort_area_size的大小，比如设置为100m或者更大。<br>    9i以后，如果初始化参数workarea_size_policy的值为TRUE，则排序区从pga_aggregate_target里自动分配获得。<br>最后，建立索引的时候，可以加上nologging选项。以减少在建立索引过程中产生的大量redo，从而提高执行的速度。</p><h3 id="MySql在建立索引优化时需要注意的问题"><a href="#MySql在建立索引优化时需要注意的问题" class="headerlink" title="MySql在建立索引优化时需要注意的问题"></a>MySql在建立索引优化时需要注意的问题</h3><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>比如有一条语句是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where area=’beijing’ and age=22;</span><br></pre></td></tr></table></figure><p>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</p><h4 id="索引不会包含有NULL值的列"><a href="#索引不会包含有NULL值的列" class="headerlink" title="索引不会包含有NULL值的列"></a>索引不会包含有NULL值的列</h4><p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p><h4 id="使用短索引"><a href="#使用短索引" class="headerlink" title="使用短索引"></a>使用短索引</h4><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。</p><h4 id="排序的索引问题"><a href="#排序的索引问题" class="headerlink" title="排序的索引问题"></a>排序的索引问题</h4><p>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><h4 id="like语句操作"><a href="#like语句操作" class="headerlink" title="like语句操作"></a>like语句操作</h4><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%a%” 不会使用索引而like “aaa%”可以使用索引。</p><h4 id="不要在列上进行运算"><a href="#不要在列上进行运算" class="headerlink" title="不要在列上进行运算"></a>不要在列上进行运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where YEAR(adddate)</span><br></pre></td></tr></table></figure><h4 id="不使用NOT-IN和操作"><a href="#不使用NOT-IN和操作" class="headerlink" title="不使用NOT IN和操作"></a>不使用NOT IN和操作</h4><p>NOT IN和操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id3则可使用id&gt;3 or id</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之ConcurrentHashMap原理分析</title>
      <link href="/article/40616.html"/>
      <url>/article/40616.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在并发编程实践中，ConcurrentHashMap是一个经常被使用的数据结构，相比于Hashtable和Collections.synchronizedMap()，前者在线程安全的基础上提供了更好的写并发能力，但同时降低了对读一致性的要求。ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS和锁分段的技术来减少锁竞争对于性能的影响，接下来我将分别阐述ConcurrentHashMap在JDK6&#x2F;7&#x2F;8分别是如何实现的。</p><span id="more"></span><h2 id="1-JDK1-6和1-7中的实现"><a href="#1-JDK1-6和1-7中的实现" class="headerlink" title="1. JDK1.6和1.7中的实现"></a>1. JDK1.6和1.7中的实现</h2><h3 id="1-1-设计思路"><a href="#1-1-设计思路" class="headerlink" title="1.1 设计思路"></a>1.1 设计思路</h3><p>在jdk1.6和1.7中采用了锁分段的技术实现，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争，相比于HashTable对整个map加锁的设计，分段锁大大的提高了高并发环境下的处理能力，正因为不是对整个map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如clear()）甚至放弃了对一致性的要求（ConcurrentHashMap是弱一致性的；</p><p>ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，代码如下：</p><pre><code>static final class HashEntry&lt;K,V&gt; &#123;    final int hash;    final K key;    volatile V value;    volatile HashEntry&lt;K,V&gt; next;</code></pre><h3 id="1-2-并发度（Concurrency-Level）"><a href="#1-2-并发度（Concurrency-Level）" class="headerlink" title="1.2 并发度（Concurrency Level）"></a>1.2 并发度（Concurrency Level）</h3><p>并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，但用户也可以在构造函数中设置并发度。当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。运行时通过将key的高n位（n &#x3D; 32 – segmentShift）和并发度减1（segmentMask）做位与运算定位到所在的Segment。segmentShift与segmentMask都是在构造过程中根据concurrency level被相应的计算出来。</p><p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。（文档的说法是根据你并发的线程数量决定，太多会导性能降低）。</p><h3 id="1-3-创建分段锁"><a href="#1-3-创建分段锁" class="headerlink" title="1.3 创建分段锁"></a>1.3 创建分段锁</h3><p>和JDK6不同，JDK7中除了第一个Segment之外，剩余的Segments采用的是延迟初始化的机制：每次put之前都需要检查key对应的Segment是否为null，如果是则调用ensureSegment()以确保对应的Segment被创建。</p><p>ensureSegment可能在并发环境下被调用，但与想象中不同，ensureSegment并未使用锁来控制竞争，而是使用了Unsafe对象的getObjectVolatile()提供的原子读语义结合CAS来确保Segment创建的原子性。代码段如下：<br>    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                &#x3D;&#x3D; null) { &#x2F;&#x2F; recheck<br>                Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);<br>                while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                       &#x3D;&#x3D; null) {<br>                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))<br>                        break;<br>                }<br>}</p><h3 id="1-4-put-putIfAbsent-putAll"><a href="#1-4-put-putIfAbsent-putAll" class="headerlink" title="1.4 put&#x2F;putIfAbsent&#x2F;putAll"></a>1.4 put&#x2F;putIfAbsent&#x2F;putAll</h3><p>和JDK6一样，ConcurrentHashMap的put方法被代理到了对应的Segment（定位Segment的原理之前已经描述过）中。与JDK6不同的是，JDK7版本的ConcurrentHashMap在获得Segment锁的过程中，做了一定的优化 - 在真正申请锁之前，put方法会通过tryLock()方法尝试获得锁，在尝试获得锁的过程中会对对应hashcode的链表进行遍历，如果遍历完毕仍然找不到与key相同的HashEntry节点，则为后续的put操作提前创建一个HashEntry。当tryLock一定次数后仍无法获得锁，则通过lock申请锁。</p><p>需要注意的是，由于在并发环境下，其他线程的put，rehash或者remove操作可能会导致链表头结点的变化，因此在过程中需要进行检查，如果头结点发生变化则重新对表进行遍历。而如果其他线程引起了链表中的某个节点被删除，即使该变化因为是非原子写操作（删除节点后链接后续节点调用的是Unsafe.putOrderedObject()，该方法不提供原子写语义）可能导致当前线程无法观察到，但因为不影响遍历的正确性所以忽略不计。</p><p>之所以在获取锁的过程中对整个链表进行遍历，主要目的是希望遍历的链表被CPU cache所缓存，为后续实际put过程中的链表遍历操作提升性能。</p><p>在获得锁之后，Segment对链表进行遍历，如果某个HashEntry节点具有相同的key，则更新该HashEntry的value值，否则新建一个HashEntry节点，将它设置为链表的新head节点并将原头节点设为新head的下一个节点。新建过程中如果节点总数（含新建的HashEntry）超过threshold，则调用rehash()方法对Segment进行扩容，最后将新建HashEntry写入到数组中。</p><p>put方法中，链接新节点的下一个节点（HashEntry.setNext()）以及将链表写入到数组中（setEntryAt()）都是通过Unsafe的putOrderedObject()方法来实现，这里并未使用具有原子写语义的putObjectVolatile()的原因是：JMM会保证获得锁到释放锁之间所有对象的状态更新都会在锁被释放之后更新到主存，从而保证这些变更对其他线程是可见的。</p><h3 id="1-5-rehash"><a href="#1-5-rehash" class="headerlink" title="1.5 rehash"></a>1.5 rehash</h3><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。这部分代码如下：<br>    private void rehash(HashEntry&lt;K,V&gt; node) {<br>           HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;<br>           int oldCapacity &#x3D; oldTable.length;<br>           int newCapacity &#x3D; oldCapacity &lt;&lt; 1;<br>           threshold &#x3D; (int)(newCapacity * loadFactor);<br>           HashEntry&lt;K,V&gt;[] newTable &#x3D;<br>               (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];<br>           int sizeMask &#x3D; newCapacity - 1;<br>           for (int i &#x3D; 0; i &lt; oldCapacity ; i++) {<br>               HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];<br>               if (e !&#x3D; null) {<br>                   HashEntry&lt;K,V&gt; next &#x3D; e.next;<br>                   int idx &#x3D; e.hash &amp; sizeMask;<br>                   if (next &#x3D;&#x3D; null)   &#x2F;&#x2F;  Single node on list<br>                       newTable[idx] &#x3D; e;<br>                   else { &#x2F;&#x2F; Reuse consecutive sequence at same slot<br>                       HashEntry&lt;K,V&gt; lastRun &#x3D; e;<br>                       int lastIdx &#x3D; idx;<br>                       for (HashEntry&lt;K,V&gt; last &#x3D; next;<br>                            last !&#x3D; null;<br>                            last &#x3D; last.next) {<br>                           int k &#x3D; last.hash &amp; sizeMask;<br>                           if (k !&#x3D; lastIdx) {<br>                               lastIdx &#x3D; k;<br>                               lastRun &#x3D; last;<br>                           }<br>                       }<br>                       newTable[lastIdx] &#x3D; lastRun;<br>                       &#x2F;&#x2F; Clone remaining nodes<br>                       for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) {<br>                           V v &#x3D; p.value;<br>                           int h &#x3D; p.hash;<br>                           int k &#x3D; h &amp; sizeMask;<br>                           HashEntry&lt;K,V&gt; n &#x3D; newTable[k];<br>                           newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);<br>                       }<br>                   }<br>               }<br>           }<br>           int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node<br>           node.setNext(newTable[nodeIndex]);<br>           newTable[nodeIndex] &#x3D; node;<br>           table &#x3D; newTable;<br>       }</p><h3 id="1-6-remove"><a href="#1-6-remove" class="headerlink" title="1.6 remove"></a>1.6 remove</h3><p>和put类似，remove在真正获得锁之前，也会对链表进行遍历以提高缓存命中率。</p><h3 id="1-7-get与containsKey"><a href="#1-7-get与containsKey" class="headerlink" title="1.7 get与containsKey"></a>1.7 get与containsKey</h3><p>get与containsKey两个方法几乎完全一致：他们都没有使用锁，而是通过Unsafe对象的getObjectVolatile()方法提供的原子读语义，来获得Segment以及对应的链表，然后对链表遍历判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p><h3 id="1-8-size、containsValue"><a href="#1-8-size、containsValue" class="headerlink" title="1.8 size、containsValue"></a>1.8 size、containsValue</h3><p>这些方法都是基于整个ConcurrentHashMap来进行操作的，他们的原理也基本类似：首先不加锁循环执行以下操作：循环所有的Segment（通过Unsafe的getObjectVolatile()以保证原子读语义），获得对应的值以及所有Segment的modcount之和。如果连续两次所有Segment的modcount和相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p><p>当循环次数超过预定义的值时，这时需要对所有的Segment依次进行加锁，获取返回值后再依次解锁。值得注意的是，加锁过程中要强制创建所有的Segment，否则容易出现其他线程创建Segment并进行put，remove等操作。代码如下：</p><pre><code>for(int j =0; j &lt; segments.length; ++j)     ensureSegment(j).lock();// force creation</code></pre><p>一般来说，应该避免在多线程环境下使用size和containsValue方法。</p><blockquote><p>注1：modcount在put, replace, remove以及clear等方法中都会被修改。</p></blockquote><blockquote><p>注2：对于containsValue方法来说，如果在循环过程中发现匹配value的HashEntry，则直接返回true。</p></blockquote><p>最后，与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照Doug Lea的说法，这么设计的原因是在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key&#x2F;value没有映射完成就被其他线程所见，需要特殊处理。在JDK6中，get方法的实现中就有一段对HashEntry.value &#x3D;&#x3D; null的防御性判断。但Doug Lea也承认实际运行过程中，这种情况似乎不可能发生。</p><h2 id="2-JDK8中的实现"><a href="#2-JDK8中的实现" class="headerlink" title="2. JDK8中的实现"></a>2. JDK8中的实现</h2>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么String类是不可变的</title>
      <link href="/article/35558.html"/>
      <url>/article/35558.html</url>
      
        <content type="html"><![CDATA[<p>String是所有语言中最常用的一个类。我们知道在Java中，String是不可变的、final的。Java在运行时也保存了一个字符串池(String pool)，这使得String成为了一个特别的类。</p><span id="more"></span><h3 id="String类不可变性的好处"><a href="#String类不可变性的好处" class="headerlink" title="String类不可变性的好处"></a>String类不可变性的好处</h3><ul><li><p>只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(译者注：String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串。)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</p></li><li><p>如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p></li><li><p>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p></li><li><p>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p></li><li><p>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串</p></li></ul><blockquote><p>如果觉得翻译不好的，可以查看原文<a href="https://www.journaldev.com/802/string-immutable-final-java">原文链接</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Consulu服务注册和发现</title>
      <link href="/article/28579.html"/>
      <url>/article/28579.html</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction-to-Consul"><a href="#Introduction-to-Consul" class="headerlink" title="Introduction to Consul"></a>Introduction to Consul</h3><p>欢迎来到Consul导览!这本指南是我们从Consul开始的最好地方。我们将介绍Consul是什么，它可以解决什么问题，它如何与现有的软件进行比较，以及如何开始使用它。如果您熟悉Consul的基本知识，那么文档将提供可用特性的更详细参考.</p><span id="more"></span><h3 id="What-is-Consul"><a href="#What-is-Consul" class="headerlink" title="What is Consul?"></a>What is Consul?</h3><p>Consul(<a href="https://www.consul.io/">https://www.consul.io/</a>) 是一个服务网格解决方案，提供了一个功能齐全的控制平面与服务发现，配置，和分割功能。这些特性可以根据需要单独使用，也可以一起使用来构建一个完整的服务网格。Consul需要一个数据平面，并支持代理和本地集成模型。Consul船与一个简单的内置代理，使一切工作开箱，但也支持第三方代理集成，如特使</p><p>其官方网站上列出了它的五点主要功能：</p><ul><li>服务发现<br>Consul的客户端可以注册服务，如api或mysql，其他客户端可以使用Consul来发现给定服务的提供者。使用DNS或HTTP，应用程序可以很容易地找到它们所依赖的服务</li><li>健康检查<br>Consul客户端可以提供任意数量的健康检查，要么与给定的服务关联(“web服务器是否返回200 OK”)，要么与本地节点关联(“内存利用率是否低于90%”)。操作员可以使用这些信息来监视集群的健康状况，服务发现组件可以使用这些信息来将流量路由到不健康的主机,关于健康检查的更多信息，可以参考 <a href="https://www.consul.io/docs/agent/checks.html%E3%80%82">https://www.consul.io/docs/agent/checks.html。</a></li><li>KV 存储<br>应用程序可以使用Consul的分层密钥&#x2F;值存储用于任何目的，包括动态配置、特性标记、协调、领导人选举等。简单的HTTP API使其易于使用。</li><li>安全服务通信<br>Consul可以为服务生成和分发TLS证书，以建立相互的TLS连接。意图可以用来定义允许哪些服务进行通信。服务细分可以很容易地管理，其意图可以实时更改，而无需使用复杂的网络拓扑和静态防火墙规则。</li><li>多数据中心支持<br>Consul支持多个数据中心开箱即用。这意味着Consul的用户不必担心构建额外的抽象层来扩展到多个区域。</li></ul><h3 id="Consul的基本机构"><a href="#Consul的基本机构" class="headerlink" title="Consul的基本机构"></a>Consul的基本机构</h3><p>Consul是一个分布式的，高度可用的系统。本节将介绍基本知识，有意省略一些不必要的细节，以便您能够快速了解Consul是如何工作的。有关更多细节，请参阅深入的体系结构概述。</p><p>为Consul提供服务的每个节点都运行一个Consul代理。运行代理不需要发现其他服务或获取&#x2F;设置键&#x2F;值数据。代理负责对节点上的服务以及节点本身进行健康检查。</p><p>代理与一个或多个Consul服务器通信。Consul服务器是存储和复制数据的地方。服务器自己选举一个领导者。虽然Consul可以与一台服务器一起工作，但建议使用3到5来避免导致数据丢失的故障场景。对于每个数据中心，建议使用一组Consul服务器。</p><p>需要发现其他服务或节点的基础设施组件可以查询任何Consul服务器或任何Consul代理。代理自动将查询转发到服务器。</p><p>每个数据中心运行一个Consul服务器集群。当跨数据中心服务发现或配置请求发出时，本地Consul服务器将请求转发到远程数据中心并返回结果。</p><h3 id="Consul的安装和启动"><a href="#Consul的安装和启动" class="headerlink" title="Consul的安装和启动"></a>Consul的安装和启动</h3><p>要使用Consul，我们需要先安装它。Consul是用golang开发的(GitHub 地址为：<a href="https://github.com/hashicorp/consul">https://github.com/hashicorp/consul</a> ),其分发的安装包里包含的是针<br>对各个不同平台预先编译好的二进制文件，解压即可使用。安装包可以到<a href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a> 下载获得。以 Linux 为例，我们可以<br>通过一下命令来完成安装：</p><h5 id="1-下载-consul，这里用-linux-64bit-的-1-0-7-版本"><a href="#1-下载-consul，这里用-linux-64bit-的-1-0-7-版本" class="headerlink" title="1.下载 consul，这里用 linux 64bit 的 1.0.7 版本"></a>1.下载 consul，这里用 linux 64bit 的 1.0.7 版本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -LO https://releases.hashicorp.com/consul/1.0.7/</span><br><span class="line">consul_1.0.7_linux_amd64.zip</span><br><span class="line">% Total % Received % Xferd Average Speed Time Time Time Current</span><br><span class="line">Dload Upload Total Spent Left Speed</span><br><span class="line">100 11.7M 100 11.7M 0 0 1477k 0 0:00:08 0:00:08 --:--:-- 2466k</span><br></pre></td></tr></table></figure><h5 id="2-解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）"><a href="#2-解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）" class="headerlink" title="2.解压（zip 包里面只包含了一个可执行&#x2F;绿色的文件，名字就叫 consul）"></a>2.解压（zip 包里面只包含了一个可执行&#x2F;绿色的文件，名字就叫 consul）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ unzip consul_1.0.7_linux_amd64.zip</span><br><span class="line">Archive: consul_1.0.7_linux_amd64.zip</span><br><span class="line">inflating: consul</span><br></pre></td></tr></table></figure><h5 id="3-将-consul-移动到-PATH-中，方便后续敲命令"><a href="#3-将-consul-移动到-PATH-中，方便后续敲命令" class="headerlink" title="3.将 consul 移动到$PATH 中，方便后续敲命令"></a>3.将 consul 移动到$PATH 中，方便后续敲命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> consul /usr/local/bin 完成后，我们可以用 consul --version 命令来验证一下：</span><br><span class="line">$ consul --version</span><br><span class="line">Consul v1.0.7 Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when</span><br><span class="line">speaking to compatible agents)</span><br></pre></td></tr></table></figure><p>好了，consul 安装成功了。接下来我们启动 consul。Consul agent 是 Consul的核心进程，它可以工作在client或server模式下。关于Consul的架构以及如何搭建 Consul 集群超出了本文要讨论的范围，感兴趣的读者可以参考 <a href="https://www.consul.io/docs/internals/architecture.html%E3%80%82">https://www.consul.io/docs/internals/architecture.html。</a> 这里，我们采用一种简单(不推荐在生产环境使用）的方式来启动一个Consul agent:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ consul agent -data-dir=/tmp/consul -dev -<span class="built_in">bind</span>=127.0.0.1</span><br><span class="line">==&gt; Starting Consul agent...</span><br><span class="line">==&gt; Consul agent running!</span><br><span class="line">Version: <span class="string">&#x27;v1.0.7&#x27;</span></span><br><span class="line">Node ID: <span class="string">&#x27;17028164-ad99-b9f4-6769-b74fcfce6f96&#x27;</span></span><br><span class="line">Node name: <span class="string">&#x27;brian-pc&#x27;</span></span><br><span class="line">Datacenter: <span class="string">&#x27;dc1&#x27;</span> (Segment: <span class="string">&#x27;&lt;all&gt;&#x27;</span>)</span><br><span class="line">Server: <span class="literal">true</span> (Bootstrap: <span class="literal">false</span>)</span><br><span class="line">Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, DNS: 8600)</span><br><span class="line">Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)</span><br><span class="line">Encrypt: Gossip: <span class="literal">false</span>, TLS-Outgoing: <span class="literal">false</span>, TLS-Incoming: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>从输出的日志，我们可以看到这个agent工作在 Server模式下(Server:true），并监听了8500端口。在浏览器中输入 <a href="http://127.0.0.1:8500/">http://127.0.0.1:8500</a> 我们可以看到<br>如下界面：</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Consul </tag>
            
            <tag> Java </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/article/22092.html"/>
      <url>/article/22092.html</url>
      
        <content type="html"><![CDATA[<p>我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。排序算法大体可分为两种：一种是比较排序，时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。另一种是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。这里我们来探讨一下常用的算法。</p><span id="more"></span><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><a href="https://github.com/whd-mtt/interview-preparation/blob/master/src/main/java/com/whd/interview/preparation/sortalgorithm/BubbleSort.java">1.冒泡排序</a></p><blockquote><p>算法思想：从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端</p></blockquote><p>算法步骤：<br>（1）从数组中第一个数开始，依次与下一个数比较并次交换比自己小的数，直到最后一个数。如果发生交换，则继续下面的步骤，如果未发生交换，则数组有序，排序结束，此时时间复杂度为O(n)；<br>（2）每一轮”冒泡”结束后，最大的数将出现在乱序数列的最后一位。重复步骤（1）。</p><p>稳定性：稳定排序。</p><p>时间复杂度： O(n)至O(n2)，平均时间复杂度为O(n2)。<br>最好的情况：如果待排序数据序列为正序，则一趟冒泡就可完成排序，排序码的比较次数为n-1次，且没有移动，时间复杂度为O(n)。<br>最坏的情况：如果待排序数据序列为逆序，则冒泡排序需要n-1次趟起泡，每趟进行n-i次排序码的比较和移动，即比较和移动次数均达到最大值：<br>比较次数:Cmax&#x3D;∑i&#x3D;1n−1(n−i)&#x3D;n(n−1)&#x2F;2&#x3D;O(n2)<br>移动次数等于比较次数，因此最坏时间复杂度为O(n2)。</p><p><a href="https://github.com/whd-mtt/interview-preparation/blob/master/src/main/java/com/whd/interview/preparation/sortalgorithm/QuickSort.java">2.快速排序</a><br>快速排序（Quicksort）是对冒泡排序的一种改进</p><blockquote><p>算法思想： 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><p>(1)设置两个变量i、j，排序开始的时候：i&#x3D;0，j&#x3D;N-1；<br>(2)以第一个数组元素作为关键数据，赋值给key，即key&#x3D;A[0]；<br>(3)从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>(4)从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>(5)重复第3、4步，直到i&#x3D;j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j&#x3D;j-1，i&#x3D;i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i&#x3D;&#x3D;j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><p>稳定性：不稳定排序。</p><p>时间复杂度： O（nlog2n）至O(n2)，平均时间复杂度为O（nlgn）。<br>最好的情况：是每趟排序结束后，每次划分使两个子文件的长度大致相等，时间复杂度为O（nlog2n）。<br>最坏的情况：是待排序记录已经排好序，第一趟经过n-1次比较后第一个记录保持位置不变，并得到一个n-1个元素的子记录；第二趟经过n-2次比较，将第二个记录定位在原来的位置上，并得到一个包括n-2个记录的子文件，依次类推，这样总的比较次数是：<br>Cmax&#x3D;∑i&#x3D;1n−1(n−i)&#x3D;n(n−1)&#x2F;2&#x3D;O(n2)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA的使用</title>
      <link href="/article/15457.html"/>
      <url>/article/15457.html</url>
      
        <content type="html"><![CDATA[<p>IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言，对于这样一个强大的代码编辑器，我们势必要了解他的快捷键操作，方便我们快速的编写实现代码。</p><span id="more"></span><h2 id="快捷键的使用"><a href="#快捷键的使用" class="headerlink" title="快捷键的使用"></a>快捷键的使用</h2><blockquote><p>注意：以下快捷键的使用仅针对于Windows平台的操作，对于MAC和LINUX大家自己对照windows平台idea的使用</p></blockquote><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><ul><li>项目之间的跳转（项目分别位于不同的idea窗口）：<br>  Ctrl + Alt + [ : 跳转到上一个idea窗口<br>  Ctrl + Alt + ] : 跳转到下一个idea窗口</li><li>文件之间的跳转<br>  Ctrl + E : 多个文件之间的跳转（最近打开文件）<br>  Ctrl + Shift + E : 多个文件之间的跳转（最近编辑修改文件）</li><li>浏览修改位置的跳转<br>  Ctrl + Shift + BackSpace : 跳转到上一次编辑的文件 </li><li>浏览位置的跳转<br>  Ctrl + Alt + ← : 跳转到上一次浏览文件的位置<br>  Ctrl + Alt + → : 跳转到下一次浏览文件的位置</li><li>最近两个文件之间的跳转（windows自带）<br>  Ctrl + Tab : 最近两个文件之间随意切换</li><li>根据书签进行跳转<br>  首先要针对你要标记的代码行作为书签，F11或者Ctrl + F11,其中后者可以使用数字进行标记，但我们要跳转的时候就可以<br>   使用Ctrl + 你标记的数字 进行跳转定位</li><li>使用收藏夹<br>   通过Shift + Alt + F : 可以将当前文件（类），当前函数方法 加入到收藏列表<br>   然后Alt + 2 : 可以打开你的收藏的文件和书签</li><li>字符跳转插件emacsIDEAs跳转<br>  1.首先要安装这个插件，自行安装<br>  2.设置快捷键</li><li>编辑区和文件区的来回跳转<br>  Alt + 1 : 通过右边的编辑区定位该文件在文件区的位置</li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li>通过输入类名称搜索<br>  Ctrl + N : 通过输入类名称搜索类文件，如果要搜索jar包里面的类，直接勾选上include non-project classes即可</li><li>通过输入文件名搜索<br>  Ctrl + Shift + N : 通过输入文件名称搜索文件，如果要搜索jar包里面的文件，直接勾选上include non-project classes即可</li><li>通过输入字符串搜索<br>  Ctrl + Shift + Alt + N : 通过输入字符串搜索（这里的字符串可以是函数，属性，类名，其他文件名称），如果要搜索jar包里面的内容，直接勾选上include non-project symbols即可</li><li>通过输入查找普通字符串<br>  Ctrl + Shift + F ：通过输入字符串搜索所有的东西</li></ul><h3 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h3><ul><li>列选<br> Ctrl + Shift + Alt + J : 列选</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ idea </tag>
            
            <tag> Jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解的原理和应用</title>
      <link href="/article/36936.html"/>
      <url>/article/36936.html</url>
      
        <content type="html"><![CDATA[<p>注解（Annotation）也叫元数据,即一种描述数据的数据，一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明。</p><span id="more"></span><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><p>一般的注解护照要分为三类：</p><h4 id="Java自带的标准注解"><a href="#Java自带的标准注解" class="headerlink" title="Java自带的标准注解"></a>Java自带的标准注解</h4><p>Java自带的标准注解主要包括包括@Override、@Deprecated和@SuppressWarnings三类，用这些注解标明后编译器就会进行检查；</p><ul><li>@Override 用于标明重写某个方法；</li><li>@Deprecated 用于标明某个类或方法过时、标明要忽略的警告；</li><li>@SuppressWarnings 用于申明要忽略的警告；</li></ul><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解是用于定义注解的注解，主要包括@Retention、@Target、@Inherited、@Documented四个；</p><ul><li>@Retention 用于标明注解被保留的阶段;</li><li>@Target  用于标明注解使用的范围;</li><li>@Inherited 用于标明注解可继承;</li><li>@Documented   用于标明是否生成javadoc文档；</li></ul><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>自定义注解，程序员可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p><h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>它主要的作用有以下四方面：</p><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>注解的使用大体分为三部分：定义注解，使用注解和解析注解，标准注解非常简单，大家可以自己实现，同时现在存在很多的java框架（Spring,SpringBoot,SpringCloud,Hibernate）中间的注解，大家使用的比较多，框架中的注解一般已经做好注解的定义和注解的解析，我们程序员只需要使用它就是了，这里主要说明自定义注解的使用。</p><h4 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h4><p>注解的定义通过@interface定义，然后在注解内部可以定义方法，很类似接口中的方法，但是在注解中他是一个成员变量，定义成员变量要遵守一些规则：<br>1.成员类型是受限制的，合法的类型包括基本的数据类型以及String，Class，Annotation,Enumeration等。<br>2.如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（&#x3D;）。<br>3.注解类可以没有成员，没有成员的注解称为标识注解<br>现在我们定义一个在方法上注解，里面有两个String类型的成员变量</p><pre><code>@Documented@Target(ElementType.METHOD)@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface AuthorAPI &#123;    String author() default &quot;whd&quot;;    String comments() default  &quot;no comments&quot;;    int age() default 23;&#125;</code></pre><h4 id="注解的使用-1"><a href="#注解的使用-1" class="headerlink" title="注解的使用"></a>注解的使用</h4><pre><code>public class UseAnnotation &#123;    @AuthorAPI    public void getInfo(String name)&#123;        System.out.println(name);    &#125;    @AuthorAPI(author = &quot;mtt&quot;, comments = &quot;you are pretty good&quot;, age = 20)    public void getDetail(String name)&#123;        System.out.println(name);    &#125;    public void getInfomation(String name)&#123;        System.out.println(name);    &#125;&#125;</code></pre><h4 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h4><pre><code>public class TestAnnotation &#123;    public static void main(String[] args) &#123;        getSomeAuthorInfo(UseAnnotation.class);    &#125;    private static void getSomeAuthorInfo(Class&lt;?&gt; clazz)  &#123;        Method[] methods = clazz.getDeclaredMethods();        for (Method method : methods) &#123;            if (method.isAnnotationPresent(AuthorAPI.class))&#123;                AuthorAPI annotation = method.getDeclaredAnnotation(AuthorAPI.class);                System.out.println(annotation.author() +&quot; &quot;+ annotation.comments() +&quot; &quot;+ annotation.age());                try &#123;                    method.invoke(new UseAnnotation(), &quot;hello, baby&quot;);                &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果：</p><pre><code>mtt you are pretty good 20hello, babywhd no comments 23hello, baby</code></pre><p>我们发现只有添加AuthorAPI注解的方法才能获取到注解成员变量的值，当然你也可以实现其他的逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性之Optional</title>
      <link href="/article/32452.html"/>
      <url>/article/32452.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在我们的开发中，NullPointerException可谓是所有java程序员随时随处可见的一种异常，为了避免空指针异常，我们常常需要进行非空检查，如果你厌倦了空指针异常，可以考虑使用java8的Optional,它能够让你的代码更具有可读性，并保护其不受空指针异常的影响。</p><span id="more"></span>ds<blockquote><p><a href="https://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html">官方原文</a></p></blockquote><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>一位智者曾经说过，除非你处理过空指针异常，否则你不是一个真正的Java程序员。顺便说一句，null引用是许多问题的根源，因为它通常用于表示没有值，其实早在在Google Guava 中就有Optional，在Swift语言中也有这样类似的语法，因此Java SE 8引入了一个名为Java.util.Optional的新类，用来减轻这些问题。</p><h3 id="2-类的说明"><a href="#2-类的说明" class="headerlink" title="2.类的说明"></a>2.类的说明</h3><h4 id="2-1-类中的所有属性和方法"><a href="#2-1-类中的所有属性和方法" class="headerlink" title="2.1 类中的所有属性和方法"></a>2.1 类中的所有属性和方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Optional</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common instance for &#123;<span class="doctag">@code</span> empty()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If non-null, the value; if null, indicates no value is present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an empty &#123;<span class="doctag">@code</span> Optional&#125; instance.  No value is present for this</span></span><br><span class="line"><span class="comment">     * Optional.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an instance with the value present.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an &#123;<span class="doctag">@code</span> Optional&#125; with the specified present non-null value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an &#123;<span class="doctag">@code</span> Optional&#125; describing the specified value, if non-null,</span></span><br><span class="line"><span class="comment">     * otherwise returns an empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present in this &#123;<span class="doctag">@code</span> Optional&#125;, returns the value,</span></span><br><span class="line"><span class="comment">     * otherwise throws &#123;<span class="doctag">@code</span> NoSuchElementException&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Optional#isPresent()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return &#123;<span class="doctag">@code</span> true&#125; if there is a value present, otherwise &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, invoke the specified consumer with the value,</span></span><br><span class="line"><span class="comment">     * otherwise do nothing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">            consumer.accept(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is pre``sent, and the value matches the given predicate,</span></span><br><span class="line"><span class="comment">     * return an &#123;<span class="doctag">@code</span> Optional&#125; describing the value, otherwise return an</span></span><br><span class="line"><span class="comment">     * empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, apply the provided mapping function to it,</span></span><br><span class="line"><span class="comment">     * and if the result is non-null, return an &#123;<span class="doctag">@code</span> Optional&#125; describing the</span></span><br><span class="line"><span class="comment">     * result.  Otherwise return an empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> This method supports post-processing on optional values, without</span></span><br><span class="line"><span class="comment">     * the need to explicitly check for a return status.  For example, the</span></span><br><span class="line"><span class="comment">     * following code traverses a stream of file names, selects one that has</span></span><br><span class="line"><span class="comment">     * not yet been processed, and then opens that file, returning an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Optional&lt;FileInputStream&gt;&#125;:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     *     Optional&lt;FileInputStream&gt; fis =</span></span><br><span class="line"><span class="comment">     *         names.stream().filter(name -&gt; !isProcessedYet(name))</span></span><br><span class="line"><span class="comment">     *                       .findFirst()</span></span><br><span class="line"><span class="comment">     *                       .map(name -&gt; new FileInputStream(name));</span></span><br><span class="line"><span class="comment">     * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(mapper);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, apply the provided &#123;<span class="doctag">@code</span> Optional&#125;-bearing</span></span><br><span class="line"><span class="comment">     * mapping function to it, return that result, otherwise return an empty</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Optional&#125;.  This method is similar to &#123;<span class="doctag">@link</span> #map(Function)&#125;,</span></span><br><span class="line"><span class="comment">     * but the provided mapper is one whose result is already an &#123;<span class="doctag">@code</span> Optional&#125;,</span></span><br><span class="line"><span class="comment">     * and if invoked, &#123;<span class="doctag">@code</span> flatMap&#125; does not wrap it with an additional</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(mapper);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the value if present, otherwise return &#123;<span class="doctag">@code</span> other&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment">     * the result of that invocation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the contained value, if present, otherwise throw an exception</span></span><br><span class="line"><span class="comment">     * to be created by the provided supplier.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> A method reference to the exception constructor with an empty</span></span><br><span class="line"><span class="comment">     * argument list can be used as the supplier. For example,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> IllegalStateException::new&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether some other object is &quot;equal to&quot; this Optional. The</span></span><br><span class="line"><span class="comment">     * other object is considered equal if:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;it is also an &#123;<span class="doctag">@code</span> Optional&#125; and;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;both instances have no value present or;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;the present values are &quot;equal to&quot; each other via &#123;<span class="doctag">@code</span> equals()&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Optional)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(value, other.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the hash code value of the present value, if any, or 0 (zero) if</span></span><br><span class="line"><span class="comment">     * no value is present.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a non-empty string representation of this Optional suitable for</span></span><br><span class="line"><span class="comment">     * debugging. The exact presentation format is unspecified and may vary</span></span><br><span class="line"><span class="comment">     * between implementations and versions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span> If a value is present the result must include its string</span></span><br><span class="line"><span class="comment">     * representation in the result. Empty and present Optionals must be</span></span><br><span class="line"><span class="comment">     * unambiguously differentiable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span></span><br><span class="line">            ? String.format(<span class="string">&quot;Optional[%s]&quot;</span>, value)</span><br><span class="line">            : <span class="string">&quot;Optional.empty&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-属性和方法解释"><a href="#2-2-属性和方法解释" class="headerlink" title="2.2 属性和方法解释"></a>2.2 属性和方法解释</h4><p>建议大家在学习新的知识的时候，先打开源码看看每个方法的注释说明，介绍了每个方法的作用，刚开始英语不好没关系，看得多了慢慢就会适应了，所以英语对程序员来讲是一个很重要的技能喔，接下来我们看哈每个方法的作用。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public static <T> Optional<T> of(T value)</td><td>把指定的值封装为Optional对象，如果指定的值为null，则抛出NullPointerException</td></tr><tr><td>public static<T> Optional<T> empty()</td><td>创建一个空的Optional对象</td></tr><tr><td>public static <T> Optional<T> ofNullable(T value)</td><td>把指定的值封装为Optional对象，如果指定的值为null，则创建一个空的Optional对象</td></tr><tr><td>public T get()</td><td>如果创建的Optional中有值存在，则返回此值，否则抛出NoSuchElementException</td></tr><tr><td>public T orElse(T other)</td><td>如果创建的Optional中有值存在，则返回此值，否则返回一个默认值</td></tr><tr><td>public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td>如果创建的Optional中有值存在，则返回此值，否则返回一个由Supplier接口生成的值</td></tr><tr><td>public <X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</td><td>如果创建的Optional中有值存在，则返回此值，否则抛出一个由指定的Supplier接口生成的异常</td></tr><tr><td>public Optional<T> filter(Predicate&lt;? super T&gt; predicate)</td><td>如果创建的Optional中的值满足filter中的条件，则返回包含该值的Optional对象，否则返回一个空的Optional对象</td></tr><tr><td>public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td>如果创建的Optional中的值存在，对该值执行提供的Function函数调用</td></tr><tr><td>public<U> Optional<U> flatMap(Function&lt;? super T, Optional<U>&gt; mapper)</td><td>如果创建的Optional中的值存在，就对该值执行提供的Function函数调用，返回一个Optional类型的值，否则就返回一个空的Optional对象</td></tr><tr><td>public boolean isPresent()</td><td>如果创建的Optional中的值存在，返回true，否则返回false</td></tr><tr><td>public void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>如果创建的Optional中的值存在，则执行该方法的调用，否则什么也不做</td></tr></tbody></table><h3 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3.基本使用"></a>3.基本使用</h3><h4 id="3-1-对象创建"><a href="#3-1-对象创建" class="headerlink" title="3.1 对象创建"></a>3.1 对象创建</h4><ul><li>创建一个空对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空的Optional&lt;User&gt;对象</span></span><br><span class="line">Optional&lt;User&gt; optStr = Optional.empty();</span><br></pre></td></tr></table></figure></li><li>创建对象：不允许为空<br>Optional提供了方法of()用于创建非空对象，该方法要求传入的参数不能为空，否则抛NullPointException，示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当user为null的时候，将抛出NullPointException</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optionals =  Optional.of(user); </span><br></pre></td></tr></table></figure><img src="http://120.78.190.213/images/learn-java8/optional-of.png" alt="如图示例"></li><li>创建对象：允许为空<br>如果不能确定传入的参数是否存在null值的可能性，则可以用Optional的ofNullable()方法创建对象，如果入参为null，则创建一个空对象。示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果user是null，则创建一个空对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optStr = Optional.ofNullable(user);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-存在则返回"><a href="#3-2-存在则返回" class="headerlink" title="3.2 存在则返回"></a>3.2 存在则返回</h4><ul><li>get() 如果创建的Optional中有值存在，则返回此值，否则抛出NoSuchElementException，示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optional2 = Optional.ofNullable(user);</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> optional2.get();</span><br></pre></td></tr></table></figure><img src="http://120.78.190.213/images/learn-java8/optional-get.png" alt="如图示例"></li><li>orElse(T other) 如果创建的Optional中有值存在，则返回此值，否则返回一个默认值（默认值就是入参参入的值，这里传入null），示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optional2 = Optional.ofNullable(user);</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> optional2.orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><img src="http://120.78.190.213/images/learn-java8/optional-orElse.png" alt="如图示例"></li><li>orElseGet(Supplier&lt;? extends T&gt; other) 如果创建的Optional中有值存在，则返回此值，否则返回一个由Supplier接口生成的值（这个生成的值可为空），示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> optional2.orElseGet(() -&gt; <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user3: &quot;</span> + user3);</span><br></pre></td></tr></table></figure><img src="http://120.78.190.213/images/learn-java8/optional-orElseGet.png" alt="如图示例"></li><li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)  如果创建的Optional中有值存在，则返回此值，否则抛出一个由指定的Supplier接口生成的异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> optional2.orElseThrow(() -&gt; <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user4: &quot;</span> + user4);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-Streams"><a href="#3-3-Streams" class="headerlink" title="3.3 Streams"></a>3.3 Streams</h4>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Optional </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之线程顺序执行</title>
      <link href="/article/30518.html"/>
      <url>/article/30518.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;我们知道在多线程中，线程在启动的时候不是马上去执行任务的，而是由cpu调度让哪一个线程执行，通常情况下多线程的执行顺序是随机的，如果我们想要让线程按照一定的顺序让线程执行，怎么做呢？</p><span id="more"></span><h3 id="1-初见"><a href="#1-初见" class="headerlink" title="1.初见"></a>1.初见</h3><p>首先我们先上一段代码,看看执行效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如图所示：<br><img src="http://120.78.190.213/images/multithread/multithread-orderexecute.png" alt="如图示"><br>从代码运行结果看，线程执行的顺序是随机的，我们无法保证线程按照特定的顺序执行，线程启动之后处于就绪状态，等待CPU调度执行，也就是说如果不做处理话，我们是无法控制的。</p><h3 id="2-相恋"><a href="#2-相恋" class="headerlink" title="2.相恋"></a>2.相恋</h3><h4 id="2-1-设置线程优先级"><a href="#2-1-设置线程优先级" class="headerlink" title="2.1 设置线程优先级"></a>2.1 设置线程优先级</h4><p>线程的执行除了CPU调度外，还有一个因素就是每个线程的优先级，线程的级别有1-10个等级，级别越高表示线程越有可能拿到CPU时间片，但是并不是优先级越高的线程就一定比优先级低的线程更早获得CPU时间片执行任务呢，按但是否定的，我们只能说优先级高的线程更有可能获取的执行权，如果说优先级高的进入了等待，那么优先级低的线程就会执行，如果几个线程都处于就组状态，那毫无疑问优先级高的线程就会先执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">thread3.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">thread2.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">thread1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line">thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-priority.png" alt="如图示"></p><h4 id="2-2-Thread-join"><a href="#2-2-Thread-join" class="headerlink" title="2.2 Thread.join()"></a>2.2 Thread.join()</h4><p>我们Thread.join()方法就是让主线程等待，新线程执行完了后再继续执行主线程，让我们来看一下Thread.join()方法的源码吧<br>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>源码很清晰的告诉我们，当我们调用join()方法后，后调用join(long millis)，在millis &#x3D;&#x3D; 0的情况下，如果当前线程是存活的，就让当前线程等待，让新线程继续执行知道死亡，知道原理后就来实现下代码喔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.join();</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-join.png"></p><h4 id="2-3-Executors-newSingleThreadExecutor"><a href="#2-3-Executors-newSingleThreadExecutor" class="headerlink" title="2.3 Executors.newSingleThreadExecutor()"></a>2.3 Executors.newSingleThreadExecutor()</h4><p>Executors.newSingleThreadExecutor()就是创建一个只有一个线程线程池，让我们看了一个源码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到Executors.newSingleThreadExecutor()实际上是创建了一个单线程的线程池，并且维护了一个任务队列，我们知道队列的特点就是FIFO(先进先出)，而且线程池每次只能执行一个任务线程，其余的线程实际上放到new LinkedBlockingQueue<Runnable>()这个队列里等待CPU调度，当第一个线程执行完了后，线程池就会从队列取下一个任务线程来执行，以此类推，从而保证了线程的执行顺序，来看看代码怎么实现的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    service.execute(thread1);</span><br><span class="line">    service.execute(thread2);</span><br><span class="line">    service.execute(thread3);</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-executors.png"></p><h3 id="婚恋"><a href="#婚恋" class="headerlink" title="婚恋"></a>婚恋</h3><p>以上就是控制多线程执行顺序方法，有什么不对欢迎指正喔。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
