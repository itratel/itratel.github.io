<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>flinkCDC导入HUDI</title>
      <link href="/2023/11/05/Flink-CDC/"/>
      <url>/2023/11/05/Flink-CDC/</url>
      
        <content type="html"><![CDATA[<h1 id="flinkCDC导入HUDI"><a href="#flinkCDC导入HUDI" class="headerlink" title="flinkCDC导入HUDI"></a>flinkCDC导入HUDI</h1><h2 id="脚本提交参数"><a href="#脚本提交参数" class="headerlink" title="脚本提交参数"></a>脚本提交参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/flink-1.15.4/bin/flink run \</span><br><span class="line">-t yarn-per-job \</span><br><span class="line">-p 1 \</span><br><span class="line">-D taskmanager.memory.process.size=&quot;2048m&quot; \</span><br><span class="line">-D taskmanager.memory.managed.fraction=&quot;0.1&quot; \</span><br><span class="line">-D metrics.reporter.promgateway.css=org.apache.flink.metrics.prometheus.PrometheusPushGatewayReporter \</span><br><span class="line">-D metrics.reporter.promgateway.host=172.20.3.10 \</span><br><span class="line">-D metrics.reporter.promgateway.port=9091 \</span><br><span class="line">-D metrics.reporter.promgateway.jobName=flink15-metrics \</span><br><span class="line">-D metrics.reporter.promgateway.groupingKey=&quot;app_name=cdc_input&quot; \</span><br><span class="line">-D metrics.reporter.promgateway.randomJobNameSuffix=true \</span><br><span class="line">-D metrics.reporter.promgateway.deleteOnShutdown=false \</span><br><span class="line">-D metrics.reporter.promgateway.interval=&quot;10 SECONDS&quot; \</span><br><span class="line">cdc-source-1.0-SNAPSHOT-jar-with-dependencies.jar -f cdc_input.sql \</span><br><span class="line">-s hdfs:///hudi-warehouse/checkpoints/cdcTohudi/cdc_input/7eda7eecbf8ac7ef4420eba656afedda/chk-9</span><br></pre></td></tr></table></figure><ul><li>建议并发度不要超过2，防止消费太快，hudi写不过来，按照当前配置速度可以到1w&#x2F;s</li><li>taskmanager.memory.process.size不要低于4G</li></ul><h2 id="主键要求"><a href="#主键要求" class="headerlink" title="主键要求"></a>主键要求</h2><p>由于写入hudi需要做upsert保证数据的一致性所以必须要利用主键字段</p><ul><li>hudi会根据主键做upsert</li><li>flink增量快照并发读取也需要主键</li></ul><h2 id="kerberos认证参数"><a href="#kerberos认证参数" class="headerlink" title="kerberos认证参数"></a>kerberos认证参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--java.security.krb5.conf krb5.conf </span><br><span class="line">--security.kerberos.login.keytab dae_huize_dev.keytab </span><br><span class="line">--security.kerberos.login.principal dae_huize_dev@TPL-HADOOP-WH.COM</span><br></pre></td></tr></table></figure><h2 id="cdcSource模板"><a href="#cdcSource模板" class="headerlink" title="cdcSource模板"></a>cdcSource模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">EXECUTE CDCSOURCE cdc_input WITH (</span><br><span class="line">&#x27;source.connector&#x27; = &#x27;mysql-cdc&#x27;,</span><br><span class="line">&#x27;source.hostname&#x27; = &#x27;172.20.3.214&#x27;,</span><br><span class="line">&#x27;source.port&#x27; = &#x27;3306&#x27;,</span><br><span class="line">&#x27;source.username&#x27; = &#x27;cdc&#x27;,</span><br><span class="line">&#x27;source.password&#x27; = &#x27;123456@aA&#x27;,</span><br><span class="line">&#x27;source.scan.startup.mode&#x27; = &#x27;initial&#x27;,</span><br><span class="line">&#x27;source.database-name&#x27; = &#x27;cdc_input&#x27;,</span><br><span class="line">&#x27;source.table-name&#x27; = &#x27;cdc_input\.user1,cdc_input\.user3&#x27;,</span><br><span class="line">&#x27;sink.connector&#x27;=&#x27;hudi&#x27;,</span><br><span class="line">&#x27;sink.path&#x27;=&#x27;hdfs:///hudi-warehouse/hudi_demo/$&#123;tableName&#125;&#x27;,</span><br><span class="line">&#x27;sink.hoodie.datasource.write.recordkey.field&#x27;=&#x27;$&#123;pkList&#125;&#x27;,</span><br><span class="line">&#x27;sink.hoodie.parquet.max.file.size&#x27;=&#x27;268435456&#x27;,</span><br><span class="line">&#x27;sink.index.bootstrap.enabled&#x27;=&#x27;true&#x27;,</span><br><span class="line">&#x27;sink.index.type&#x27;=&#x27;BUCKET&#x27;,</span><br><span class="line">&#x27;sink.hoodie.index.bucket.engine&#x27;=&#x27;CONSISTENT_HASHING&#x27;,</span><br><span class="line">&#x27;sink.write.bucket_assign.tasks&#x27;=&#x27;1&#x27;,</span><br><span class="line">&#x27;sink.write.precombine&#x27;=&#x27;true&#x27;,</span><br><span class="line">&#x27;sink.write.task.max.size&#x27;=&#x27;1024&#x27;,</span><br><span class="line">&#x27;sink.write.operation&#x27;=&#x27;upsert&#x27;,</span><br><span class="line">&#x27;sink.table.type&#x27;=&#x27;MERGE_ON_READ&#x27;,</span><br><span class="line">&#x27;sink.compaction.tasks&#x27;=&#x27;1&#x27;,</span><br><span class="line">&#x27;sink.compaction.delta_seconds&#x27;=&#x27;180&#x27;,</span><br><span class="line">&#x27;sink.compaction.async.enabled&#x27;=&#x27;true&#x27;,</span><br><span class="line">&#x27;sink.read.streaming.skip_compaction&#x27;=&#x27;true&#x27;,</span><br><span class="line">&#x27;sink.compaction.delta_commits&#x27;=&#x27;20&#x27;,</span><br><span class="line">&#x27;sink.compaction.trigger.strategy&#x27;=&#x27;num_or_time&#x27;,</span><br><span class="line">&#x27;sink.compaction.max_memory&#x27;=&#x27;500&#x27;,</span><br><span class="line">&#x27;sink.changelog.enabled&#x27;=&#x27;true&#x27;,</span><br><span class="line">&#x27;sink.read.streaming.enabled&#x27;=&#x27;true&#x27;,</span><br><span class="line">&#x27;sink.read.streaming.check.interval&#x27;=&#x27;3&#x27;,</span><br><span class="line">&#x27;sink.hive_sync.enable&#x27;=&#x27;true&#x27;,</span><br><span class="line">&#x27;sink.hive_sync.mode&#x27;=&#x27;hms&#x27;,</span><br><span class="line">&#x27;sink.hive_sync.metastore.uris&#x27;=&#x27;thrift://sit-cdh01-ns-test-172-20-3-211:9083&#x27;,</span><br><span class="line">&#x27;sink.hive_sync.db&#x27;=&#x27;hudi_demo&#x27;,</span><br><span class="line">&#x27;sink.hive_sync.table&#x27;=&#x27;$&#123;tableName&#125;&#x27;,</span><br><span class="line">&#x27;sink.hive_sync.conf.dir&#x27;=&#x27;/etc/hive/conf&#x27;,</span><br><span class="line">&#x27;sink.table.prefix.schema&#x27;=&#x27;true&#x27;,</span><br><span class="line">&#x27;flink.checkpoint.interval&#x27;=&#x27;180000&#x27;,</span><br><span class="line">&#x27;flink.checkpoint.mode&#x27;=&#x27;exactly_once&#x27;,</span><br><span class="line">&#x27;flink.checkpoint.timeout&#x27;=&#x27;180000&#x27;,</span><br><span class="line">&#x27;flink.checkpoint.minPause&#x27;=&#x27;180000&#x27;,</span><br><span class="line">&#x27;flink.checkpoint.backend.path&#x27;=&#x27;hdfs:///hudi-warehouse/hudi_demo/checkpoints/cdcTohudi/cdc_input&#x27;)</span><br></pre></td></tr></table></figure><h2 id="表结构变更"><a href="#表结构变更" class="headerlink" title="表结构变更"></a>表结构变更</h2><ul><li>需要开启参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;source.schema.changes&#x27; = &#x27;true&#x27;</span><br></pre></td></tr></table></figure><ul><li>不要使用create table&#x2F;view like这样的语法，cdc会抓不到表名</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h2 id="多sink写入"><a href="#多sink写入" class="headerlink" title="多sink写入"></a>多sink写入</h2><h2 id="集成其他Sink"><a href="#集成其他Sink" class="headerlink" title="集成其他Sink"></a>集成其他Sink</h2><h2 id="本地执行参数"><a href="#本地执行参数" class="headerlink" title="本地执行参数"></a>本地执行参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f D:\Users\hz21066838\IdeaProjects\cdc-source\src\main\resources\cdc_its.sql --java.security.krb5.conf D:\Users\hz21066838\IdeaProjects\cdc-source\src\main\resources\krb5.conf --security.kerberos.login.keytab D:\Users\hz21066838\IdeaProjects\cdc-source\src\main\resources\dae_huize_dev.keytab --security.kerberos.login.principal dae_huize_dev@TPL-HADOOP-WH.COM</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Flink </tag>
            
            <tag> Hudi </tag>
            
            <tag> 实时计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Features of Java 21 - Sequenced Collections</title>
      <link href="/2023/10/24/New-Features-of-Java-21-Sequenced-Collections/"/>
      <url>/2023/10/24/New-Features-of-Java-21-Sequenced-Collections/</url>
      
        <content type="html"><![CDATA[<p>序列集合是Java21的一个正式特性，该特性通过引入新的接口表示具有定义的相遇顺序的集合。每个这样的集合都有定义良好的第一个元素、第二个元素，依此类推，直到最后一个元素。它还提供了统一的api来访问它的第一个和最后一个元素，并以相反的顺序处理它的元素。</p><p>1 为什么会有序列集合</p><p>Java的集合框架缺少一种集合类型来表示具有定义的相遇顺序的元素序列，它还缺乏适用于这些集合的统一操作集。这些差距一再成为问题和抱怨的根源。</p><p>例如，List和Deque都定义了相遇顺序，但它们的共同超类型是Collection，而Collection没有定义相遇顺序。类似地，Set不定义相遇顺序，HashSet等子类型也不定义相遇顺序，但SortedSet和LinkedHashSet等子类型定义了相遇顺序。因此，对相遇顺序的支持在整个类型中展开。</p><p>一个相关的问题是视图集合经常被迫降级为较弱的语义。用Collections:: unmodiableleset包装LinkedHashSet产生一个Set，丢弃关于相遇顺序的信息。</p><p>如果没有接口来定义它们，与遭遇战顺序相关的操作要么不一致，要么缺失。虽然许多实现都支持获取第一个或最后一个元素，但每个集合都定义了自己的方式，有些并不明显或完全缺失:</p><p>First element</p><p>Last element</p><p>List</p><p>list.get(0)</p><p>list.get(list.size() - 1)</p><p>Deque</p><p>deque.getFirst()</p><p>deque.getLast()</p><p>SortedSet</p><p>sortedSet.first()</p><p>sortedSet.last()</p><p>LinkedHashSet</p><p>linkedHashSet.iterator().next()</p><p>&#x2F;&#x2F; missing</p><p>其中一些是不必要的麻烦，例如我们要获取List的最后一个元素。有些甚至不可能没有英雄:获得LinkedHashSet的最后一个元素的唯一方法是迭代整个集合。</p><p>类似地，从第一个到最后迭代集合的元素是直接和一致的，但反向迭代就不一样了。所有这些集合都可以使用Iterator、增强的for循环、stream()或toArray()向前迭代。在每种情况下，反向迭代都是不同的。NavigableSet为反向迭代提供了descendingSet()视图:</p><p>for (var e : navSet.descendingSet())<br>    process(e);<br>Deque通过反向迭代器实现了这一点:</p><p>for (var it &#x3D; deque.descendingIterator(); it.hasNext();) {<br>    var e &#x3D; it.next();<br>    process(e);<br>}<br>List可以这样做，但使用ListIterator:</p><p>for (var it &#x3D; list.listIterator(list.size()); it.hasPrevious();) {<br>    var e &#x3D; it.previous();<br>    process(e);<br>}<br>最后，LinkedHashSet不支持反向迭代。以相反的顺序处理LinkedHashSet元素的唯一实际方法是将其元素复制到另一个集合中。</p><p>类似地，与使用循环处理元素相比，使用流处理集合的元素是一种强大而有效的替代方法，但是以相反的顺序获取流可能比较困难。在定义相遇顺序的各种集合中，唯一方便地支持这一点的是NavigableSet: </p><p>navSet.descendingSet().stream()<br>其他方法要么需要将元素复制到另一个集合，要么需要从自定义的Spliterator创建一个流来反转迭代。</p><p>这是一种不好的状况。具有定义的相遇顺序的集合的概念存在于集合框架中的多个位置，但没有单一类型表示它。因此，这些集合上的一些操作不一致或丢失，以相反的顺序处理元素从不方便到不可能。我们应该填补这些空白。</p><p>正因为上面的一切原因，我们才为序列集合、序列集合和序列映射定义了新的接口，然后将它们改造成现有的集合类型层次结构。在这些接口中声明的所有新方法都有默认实现。</p><ol start="2"><li>有序Collections</li></ol><p>有序集合是其元素具有已定义的相遇顺序的集合。(这里的“sequenced”一词是动词to sequence的过去分词，意思是“按特定顺序排列元素”。)一个有顺序的集合有第一个元素和最后一个元素，它们之间的元素有后继元素和前继元素。序列集合在任意一端都支持通用操作，并且支持从第一到最后和从最后到第一(即正向和反向)处理元素，让我们来看看序列集合的接口申明：</p><p>public interface SequencedCollection<E> extends Collection<E> {<br>    &#x2F;**<br>     * Returns a reverse-ordered <a href="Collection.html#view">view</a> of this collection.<br>     * The encounter order of elements in the returned view is the inverse of the encounter<br>     * order of elements in this collection. The reverse ordering affects all order-sensitive<br>     * operations, including those on the view collections of the returned view. If the collection<br>     * implementation permits modifications to this view, the modifications “write through” to the<br>     * underlying collection. Changes to the underlying collection might or might not be visible<br>     * in this reversed view, depending upon the implementation.<br>     *<br>     * @return a reverse-ordered view of this collection<br>     <em>&#x2F;<br>    SequencedCollection<E> reversed();<br>​<br>    &#x2F;</em>*<br>     * Adds an element as the first element of this collection (optional operation).<br>     * After this operation completes normally, the given element will be a member of<br>     * this collection, and it will be the first element in encounter order.<br>     *<br>     * @implSpec<br>     * The implementation in this interface always throws {@code UnsupportedOperationException}.<br>     *<br>     * @param e the element to be added<br>     * @throws NullPointerException if the specified element is null and this<br>     *         collection does not permit null elements<br>     * @throws UnsupportedOperationException if this collection implementation<br>     *         does not support this operation<br>     <em>&#x2F;<br>    default void addFirst(E e) {<br>        throw new UnsupportedOperationException();<br>    }<br>​<br>    &#x2F;</em>*<br>     * Adds an element as the last element of this collection (optional operation).<br>     * After this operation completes normally, the given element will be a member of<br>     * this collection, and it will be the last element in encounter order.<br>     *<br>     * @implSpec<br>     * The implementation in this interface always throws {@code UnsupportedOperationException}.<br>     *<br>     * @param e the element to be added.<br>     * @throws NullPointerException if the specified element is null and this<br>     *         collection does not permit null elements<br>     * @throws UnsupportedOperationException if this collection implementation<br>     *         does not support this operation<br>     <em>&#x2F;<br>    default void addLast(E e) {<br>        throw new UnsupportedOperationException();<br>    }<br>​<br>    &#x2F;</em>*<br>     * Gets the first element of this collection.<br>     *<br>     * @implSpec<br>     * The implementation in this interface obtains an iterator of this collection, and<br>     * then it obtains an element by calling the iterator’s {@code next} method. Any<br>     * {@code NoSuchElementException} thrown is propagated. Otherwise, it returns<br>     * the element.<br>     *<br>     * @return the retrieved element<br>     * @throws NoSuchElementException if this collection is empty<br>     <em>&#x2F;<br>    default E getFirst() {<br>        return this.iterator().next();<br>    }<br>​<br>    &#x2F;</em>*<br>     * Gets the last element of this collection.<br>     *<br>     * @implSpec<br>     * The implementation in this interface obtains an iterator of the reversed view<br>     * of this collection, and then it obtains an element by calling the iterator’s<br>     * {@code next} method. Any {@code NoSuchElementException} thrown is propagated.<br>     * Otherwise, it returns the element.<br>     *<br>     * @return the retrieved element<br>     * @throws NoSuchElementException if this collection is empty<br>     <em>&#x2F;<br>    default E getLast() {<br>        return this.reversed().iterator().next();<br>    }<br>​<br>    &#x2F;</em>*<br>     * Removes and returns the first element of this collection (optional operation).<br>     *<br>     * @implSpec<br>     * The implementation in this interface obtains an iterator of this collection, and then<br>     * it obtains an element by calling the iterator’s {@code next} method. Any<br>     * {@code NoSuchElementException} thrown is propagated. It then calls the iterator’s<br>     * {@code remove} method. Any {@code UnsupportedOperationException} thrown is propagated.<br>     * Then, it returns the element.<br>     *<br>     * @return the removed element<br>     * @throws NoSuchElementException if this collection is empty<br>     * @throws UnsupportedOperationException if this collection implementation<br>     *         does not support this operation<br>     <em>&#x2F;<br>    default E removeFirst() {<br>        var it &#x3D; this.iterator();<br>        E e &#x3D; it.next();<br>        it.remove();<br>        return e;<br>    }<br>​<br>    &#x2F;</em>*<br>     * Removes and returns the last element of this collection (optional operation).<br>     *<br>     * @implSpec<br>     * The implementation in this interface obtains an iterator of the reversed view of this<br>     * collection, and then it obtains an element by calling the iterator’s {@code next} method.<br>     * Any {@code NoSuchElementException} thrown is propagated. It then calls the iterator’s<br>     * {@code remove} method. Any {@code UnsupportedOperationException} thrown is propagated.<br>     * Then, it returns the element.<br>     *<br>     * @return the removed element<br>     * @throws NoSuchElementException if this collection is empty<br>     * @throws UnsupportedOperationException if this collection implementation<br>     *         does not support this operation<br>     *&#x2F;<br>    default E removeLast() {<br>        var it &#x3D; this.reversed().iterator();<br>        E e &#x3D; it.next();<br>        it.remove();<br>        return e;<br>    }<br>}</p><p>新的reversed()方法提供了原始集合的反向排序视图。对原始集合的任何修改都可以在视图中看到。如果允许，对视图的修改将写到原始集合。</p><p>逆序视图允许所有不同的顺序类型在两个方向上处理元素，使用所有常用的迭代机制:增强的for循环、显式iterator()循环、forEach()、stream()、parallelStream()和toArray()。</p><p>例如，以前从LinkedHashSet中获得反向排序流是相当困难的，现在它很简单。</p><p>linkedHashSet.reversed().stream()<br>(reversed()方法本质上是一个重命名的NavigableSet::descendingSet，提升为SequencedCollection。)</p><p>SequencedCollection的以下方法是从Deque提升而来的。它们支持在两端添加、获取和删除元素:</p><p>void addFirst(E)<br>void addLast(E)<br>E getFirst()<br>E getLast()<br>E removeFirst()<br>E removeLast()<br>add*(E)和remove*()方法是可选的，主要是为了支持不可修改集合的情况。如果集合为空，get*()和remove*()方法会抛出NoSuchElementException。</p><p>在SequencedCollection中没有equals()和hashCode()的定义，因为它的子接口有冲突的定义。</p><ol start="3"><li>有序Sets</li></ol><p>Sequenced Set是一个不包含重复元素的SequencedCollection。</p><p>&#x2F;**</p><ul><li>A collection that is both a {@link SequencedCollection} and a {@link Set}. As such,</li><li>it can be thought of either as a {@code Set} that also has a well-defined</li><li><a href="SequencedCollection.html#encounter">encounter order</a>, or as a</li><li>{@code SequencedCollection} that also has unique elements.</li><li><p></li><li>This interface has the same requirements on the {@code equals} and {@code hashCode}</li><li>methods as defined by {@link Set#equals Set.equals} and {@link Set#hashCode Set.hashCode}.</li><li>Thus, a {@code Set} and a {@code SequencedSet} will compare equals if and only</li><li>if they have equal elements, irrespective of ordering.</li><li><p></li><li>{@code SequencedSet} defines the {@link #reversed} method, which provides a</li><li>reverse-ordered <a href="Collection.html#view">view</a> of this set. The only difference</li><li>from the {@link SequencedCollection#reversed SequencedCollection.reversed} method is</li><li>that the return type of {@code SequencedSet.reversed} is {@code SequencedSet}.</li><li><p></li><li>This class is a member of the</li><li><a href="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"></li><li>Java Collections Framework</a>.</li><li></li><li>@param <E> the type of elements in this sequenced set</li><li>@since 21<br> <em>&#x2F;<br>public interface SequencedSet<E> extends SequencedCollection<E>, Set<E> {<br> &#x2F;</em>*<ul><li>{@inheritDoc}</li><li></li><li>@return a reverse-ordered view of this collection, as a {@code SequencedSet}<br>  *&#x2F;<br> SequencedSet<E> reversed();<br>}</li></ul></li></ul><p>SortedSet之类的集合通过相对比较来定位元素，它们不能支持显式定位操作，例如在SequencedCollection超接口中声明的addFirst(E)和addLast(E)方法。因此，这些方法可以抛出UnsupportedOperationException。</p><p>SequencedSet的addFirst(E)和addLast(E)方法对于LinkedHashSet等集合具有特殊情况语义:如果元素已经存在于集合中，则将其移动到适当的位置。这弥补了LinkedHashSet中一个长期存在的缺陷，即无法重新定位元素。</p><ol start="4"><li>有序Maps</li></ol><p>Sequenced Map有序映射是其条目具有定义的相遇顺序的map。</p><p>public interface SequencedMap&lt;K, V&gt; extends Map&lt;K, V&gt; {<br>    &#x2F;**<br>     * Returns a reverse-ordered <a href="Collection.html#view">view</a> of this map.<br>     * The encounter order of mappings in the returned view is the inverse of the encounter<br>     * order of mappings in this map. The reverse ordering affects all order-sensitive operations,<br>     * including those on the view collections of the returned view. If the implementation permits<br>     * modifications to this view, the modifications “write through” to the underlying map.<br>     * Changes to the underlying map might or might not be visible in this reversed view,<br>     * depending upon the implementation.<br>     *<br>     * @return a reverse-ordered view of this map<br>     <em>&#x2F;<br>    SequencedMap&lt;K, V&gt; reversed();<br>​<br>    &#x2F;</em>*<br>     * Returns the first key-value mapping in this map,<br>     * or {@code null} if the map is empty.<br>     *<br>     * @implSpec<br>     * The implementation in this interface obtains the iterator of this map’s entrySet.<br>     * If the iterator has an element, it returns an unmodifiable copy of that element.<br>     * Otherwise, it returns null.<br>     *<br>     * @return the first key-value mapping,<br>     *         or {@code null} if this map is empty<br>     <em>&#x2F;<br>    default Map.Entry&lt;K,V&gt; firstEntry() {<br>        var it &#x3D; entrySet().iterator();<br>        return it.hasNext() ? new NullableKeyValueHolder&lt;&gt;(it.next()) : null;<br>    }<br>​<br>    &#x2F;</em>*<br>     * Returns the last key-value mapping in this map,<br>     * or {@code null} if the map is empty.<br>     *<br>     * @implSpec<br>     * The implementation in this interface obtains the iterator of the entrySet of this map’s<br>     * reversed view. If the iterator has an element, it returns an unmodifiable copy of<br>     * that element. Otherwise, it returns null.<br>     *<br>     * @return the last key-value mapping,<br>     *         or {@code null} if this map is empty<br>     <em>&#x2F;<br>    default Map.Entry&lt;K,V&gt; lastEntry() {<br>        var it &#x3D; reversed().entrySet().iterator();<br>        return it.hasNext() ? new NullableKeyValueHolder&lt;&gt;(it.next()) : null;<br>    }<br>​<br>    &#x2F;</em>*<br>     * Removes and returns the first key-value mapping in this map,<br>     * or {@code null} if the map is empty (optional operation).<br>     *<br>     * @implSpec<br>     * The implementation in this interface obtains the iterator of this map’s entrySet.<br>     * If the iterator has an element, it calls {@code remove} on the iterator and<br>     * then returns an unmodifiable copy of that element. Otherwise, it returns null.<br>     *<br>     * @return the removed first entry of this map,<br>     *         or {@code null} if this map is empty<br>     * @throws UnsupportedOperationException if this collection implementation does not<br>     *         support this operation<br>     <em>&#x2F;<br>    default Map.Entry&lt;K,V&gt; pollFirstEntry() {<br>        var it &#x3D; entrySet().iterator();<br>        if (it.hasNext()) {<br>            var entry &#x3D; new NullableKeyValueHolder&lt;&gt;(it.next());<br>            it.remove();<br>            return entry;<br>        } else {<br>            return null;<br>        }<br>    }<br>​<br>    &#x2F;</em>*<br>     * Removes and returns the last key-value mapping in this map,<br>     * or {@code null} if the map is empty (optional operation).<br>     *<br>     * @implSpec<br>     * The implementation in this interface obtains the iterator of the entrySet of this map’s<br>     * reversed view. If the iterator has an element, it calls {@code remove} on the iterator<br>     * and then returns an unmodifiable copy of that element. Otherwise, it returns null.<br>     *<br>     * @return the removed last entry of this map,<br>     *         or {@code null} if this map is empty<br>     * @throws UnsupportedOperationException if this collection implementation does not<br>     *         support this operation<br>     <em>&#x2F;<br>    default Map.Entry&lt;K,V&gt; pollLastEntry() {<br>        var it &#x3D; reversed().entrySet().iterator();<br>        if (it.hasNext()) {<br>            var entry &#x3D; new NullableKeyValueHolder&lt;&gt;(it.next());<br>            it.remove();<br>            return entry;<br>        } else {<br>            return null;<br>        }<br>    }<br>​<br>    &#x2F;</em>*<br>     * Inserts the given mapping into the map if it is not already present, or replaces the<br>     * value of a mapping if it is already present (optional operation). After this operation<br>     * completes normally, the given mapping will be present in this map, and it will be the<br>     * first mapping in this map’s encounter order.<br>     *<br>     * @implSpec The implementation in this interface always throws<br>     * {@code UnsupportedOperationException}.<br>     *<br>     * @param k the key<br>     * @param v the value<br>     * @return the value previously associated with k, or null if none<br>     * @throws UnsupportedOperationException if this collection implementation does not<br>     *         support this operation<br>     <em>&#x2F;<br>    default V putFirst(K k, V v) {<br>        throw new UnsupportedOperationException();<br>    }<br>​<br>    &#x2F;</em>*<br>     * Inserts the given mapping into the map if it is not already present, or replaces the<br>     * value of a mapping if it is already present (optional operation). After this operation<br>     * completes normally, the given mapping will be present in this map, and it will be the<br>     * last mapping in this map’s encounter order.<br>     *<br>     * @implSpec The implementation in this interface always throws<br>     * {@code UnsupportedOperationException}.<br>     *<br>     * @param k the key<br>     * @param v the value<br>     * @return the value previously associated with k, or null if none<br>     * @throws UnsupportedOperationException if this collection implementation does not<br>     *         support this operation<br>     <em>&#x2F;<br>    default V putLast(K k, V v) {<br>        throw new UnsupportedOperationException();<br>    }<br>​<br>    &#x2F;</em>*<br>     * Returns a {@code SequencedSet} view of this map’s {@link #keySet keySet}.<br>     *<br>     * @implSpec<br>     * The implementation in this interface returns a {@code SequencedSet} instance<br>     * that behaves as follows. Its {@link SequencedSet#add add} and {@link<br>     * SequencedSet#addAll addAll} methods throw {@link UnsupportedOperationException}.<br>     * Its {@link SequencedSet#reversed reversed} method returns the {@link<br>     * #sequencedKeySet sequencedKeySet} view of the {@link #reversed reversed} view of<br>     * this map. Each of its other methods calls the corresponding method of the {@link<br>     * #keySet keySet} view of this map.<br>     *<br>     * @return a {@code SequencedSet} view of this map’s {@code keySet}<br>     <em>&#x2F;<br>    default SequencedSet<K> sequencedKeySet() {<br>        class SeqKeySet extends AbstractMap.ViewCollection<K> implements SequencedSet<K> {<br>            Collection<K> view() {<br>                return SequencedMap.this.keySet();<br>            }<br>            public SequencedSet<K> reversed() {<br>                return SequencedMap.this.reversed().sequencedKeySet();<br>            }<br>            public boolean equals(Object other) {<br>                return view().equals(other);<br>            }<br>            public int hashCode() {<br>                return view().hashCode();<br>            }<br>        }<br>        return new SeqKeySet();<br>    }<br>​<br>    &#x2F;</em>*<br>     * Returns a {@code SequencedCollection} view of this map’s {@link #values values} collection.<br>     *<br>     * @implSpec<br>     * The implementation in this interface returns a {@code SequencedCollection} instance<br>     * that behaves as follows. Its {@link SequencedCollection#add add} and {@link<br>     * SequencedCollection#addAll addAll} methods throw {@link UnsupportedOperationException}.<br>     * Its {@link SequencedCollection#reversed reversed} method returns the {@link<br>     * #sequencedValues sequencedValues} view of the {@link #reversed reversed} view of<br>     * this map. Its {@link Object#equals equals} and {@link Object#hashCode hashCode} methods<br>     * are inherited from {@link Object}. Each of its other methods calls the corresponding<br>     * method of the {@link #values values} view of this map.<br>     *<br>     * @return a {@code SequencedCollection} view of this map’s {@code values} collection<br>     <em>&#x2F;<br>    default SequencedCollection<V> sequencedValues() {<br>        class SeqValues extends AbstractMap.ViewCollection<V> implements SequencedCollection<V> {<br>            Collection<V> view() {<br>                return SequencedMap.this.values();<br>            }<br>            public SequencedCollection<V> reversed() {<br>                return SequencedMap.this.reversed().sequencedValues();<br>            }<br>        }<br>        return new SeqValues();<br>    }<br>​<br>    &#x2F;</em>*<br>     * Returns a {@code SequencedSet} view of this map’s {@link #entrySet entrySet}.<br>     *<br>     * @implSpec<br>     * The implementation in this interface returns a {@code SequencedSet} instance<br>     * that behaves as follows. Its {@link SequencedSet#add add} and {@link<br>     * SequencedSet#addAll addAll} methods throw {@link UnsupportedOperationException}.<br>     * Its {@link SequencedSet#reversed reversed} method returns the {@link<br>     * #sequencedEntrySet sequencedEntrySet} view of the {@link #reversed reversed} view of<br>     * this map. Each of its other methods calls the corresponding method of the {@link<br>     * #entrySet entrySet} view of this map.<br>     *<br>     * @return a {@code SequencedSet} view of this map’s {@code entrySet}<br>     *&#x2F;<br>    default SequencedSet&lt;Map.Entry&lt;K, V&gt;&gt; sequencedEntrySet() {<br>        class SeqEntrySet extends AbstractMap.ViewCollection&lt;Map.Entry&lt;K, V&gt;&gt;<br>                implements SequencedSet&lt;Map.Entry&lt;K, V&gt;&gt; {<br>            Collection&lt;Map.Entry&lt;K, V&gt;&gt; view() {<br>                return SequencedMap.this.entrySet();<br>            }<br>            public SequencedSet&lt;Map.Entry&lt;K, V&gt;&gt; reversed() {<br>                return SequencedMap.this.reversed().sequencedEntrySet();<br>            }<br>            public boolean equals(Object other) {<br>                return view().equals(other);<br>            }<br>            public int hashCode() {<br>                return view().hashCode();<br>            }<br>        }<br>        return new SeqEntrySet();<br>    }<br>}</p><p>在编写代码时，插值不仅比串联更方便，而且在阅读代码时也更清晰。对于较复杂的字符串，其清晰度尤其突出。例如，在JavaScript中:</p><p>4 总结</p><p>通过以上例子，我们可以实现自定义字符串模板处理器，不仅如此我们还可以实现针对返回指定类型的模板处理器，由此可见内嵌模板表达式可以很方便地实现插值，并且插值之前可以对值进行规则检验，不过当前的字符串模板目前只是一个预览特性，在未来的Java版本是否正式公开此特性我们拭目以待。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试重点</title>
      <link href="/2019/05/11/Redis%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/"/>
      <url>/2019/05/11/Redis%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1）Redis为什么使用单进程单线程方式也这么快"><a href="#1）Redis为什么使用单进程单线程方式也这么快" class="headerlink" title="1）Redis为什么使用单进程单线程方式也这么快"></a>1）Redis为什么使用单进程单线程方式也这么快</h3><p>Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。</p><span id="more"></span><p>Redis快的主要原因是：</p><ol><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I&#x2F;O 复用模型</li></ol><p>多路 I&#x2F;O 复用模型是利用select、poll、epoll可以同时监察多个流的 I&#x2F;O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I&#x2F;O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p>和Memcached不同，Redis并没有直接使用Libevent，而是自己完成了一个非常轻量级的对select、epoll、evport、kqueue这些通用的接口的实现。在不同的系统调用选用适合的接口，linux下默认是epoll。因为Libevent比较重更通用代码量也就很庞大，拥有很多Redis用不上的功能，Redis为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。</p><h4 id="单进程单线程好处"><a href="#单进程单线程好处" class="headerlink" title="单进程单线程好处"></a>单进程单线程好处</h4><ul><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ul><h4 id="单进程单线程弊端"><a href="#单进程单线程弊端" class="headerlink" title="单进程单线程弊端"></a>单进程单线程弊端</h4><p>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</p><h4 id="其他一些优秀的开源软件采用的模型"><a href="#其他一些优秀的开源软件采用的模型" class="headerlink" title="其他一些优秀的开源软件采用的模型"></a>其他一些优秀的开源软件采用的模型</h4><ul><li>多进程单线程模型：Nginx</li><li>单进程多线程模型：Memcached</li></ul><h3 id="2）五种类型数据类型"><a href="#2）五种类型数据类型" class="headerlink" title="2）五种类型数据类型"></a>2）五种类型数据类型</h3><p>字符串、列表、散列表，集合、有序集合</p><h3 id="3）内存中数据持久化"><a href="#3）内存中数据持久化" class="headerlink" title="3）内存中数据持久化"></a>3）内存中数据持久化</h3><p>使用复制来扩展读性能：复制到多台服务器、提高读性能和可用性</p><p>使用分区来扩展写性能【hash一致性算法】：当数据量大的时候,把数据分散存入多个数据库中,减少单节点的连接压力</p><p>特点</p><ul><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I&#x2F;O 复用模型</li></ul><h3 id="4）Redis-适用场景"><a href="#4）Redis-适用场景" class="headerlink" title="4）Redis 适用场景"></a>4）Redis 适用场景</h3><ol><li>缓存 将热点数据放到内存中</li><li>消息队列 List 类型是双向链表，很适合用于消息队列</li><li>计数器 快速、频繁读写操作；string的单线性自增减 ++ –</li><li>共同好友关系 set 交集运算，很容易就可以知道用户的共同好友</li><li>排名 zset有序集合</li></ol><h3 id="5）持久化"><a href="#5）持久化" class="headerlink" title="5）持久化"></a>5）持久化</h3><p>快照持久化</p><p>将某个时间点的所有数据都存放到硬盘上</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本</p><p>缺点：故障可能丢失最后一次创建快照之后的数据；如果数据量很大，保存快照的时间也会很长。</p><p>AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾</p><ul><li>always： 每个写命令都同步，严重减低服务器的性能；</li><li>everysec ：每秒同步一次，比较合适，保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no ：让操作系统来决定何时同步，不能给性能带来提升，且会增加奔溃时数据丢失量</li></ul><p> </p><p>随着服务器写请求的增多，AOF 文件会越来越大；Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><p>对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，操作系统决定何时写</p><p>用户可以调用 file.flush() 方法请求尽快将缓冲区存储的数据同步到硬盘</p><p>redis主从复制 分布式数据同步方式</p><p>slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器</p><p>从服务器连接主服务器的过程</p><ul><li>主服务器创建快照文件，发送给从服务器。同时记录其间执行的写命令，发送完毕后，开始向从服务器发送写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器的快照文件，然后开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令</li></ul><p>主从链 创建一个中间层来分担主服务器的复制工作</p><ul><li>随着负载不断上升，主服务器可能无法很快地更新所有从服务器</li><li>重新连接和重新同步从服务器将导致系统超载</li><li>中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器</li></ul><h3 id="6）redis-主服务器-故障-处理"><a href="#6）redis-主服务器-故障-处理" class="headerlink" title="6）redis 主服务器 故障 处理"></a>6）redis 主服务器 故障 处理</h3><p>当主服务器出现故障时，Redis 常用的做法是新开一台服务器作为主服务器，具体步骤如下：假设 A 为主服务器，B 为从服务器，当 A 出现故障时，让 B 生成一个快照文件，将快照文件发送给 C，并让 C 恢复快照文件的数据。最后，让 B 成为 C 的从服务器。</p><h3 id="7）分片-集群-读并发"><a href="#7）分片-集群-读并发" class="headerlink" title="7）分片 集群 读并发"></a>7）分片 集群 读并发</h3><p>数据划分为多个部分，可以将数据存储到多台机器里，作用：负载均衡、线性级别的性能提升</p><h3 id="8）分片方式："><a href="#8）分片方式：" class="headerlink" title="8）分片方式："></a>8）分片方式：</h3><p>客户端代码分片</p><ul><li>Redis Sharding，对Redis数据的key进行hash，相同的key到相同的节点上</li><li>一致性哈希算法</li><li>代理服务器分片 轮询round-bin</li></ul><h3 id="9）redis与数据库的同步-数据一致"><a href="#9）redis与数据库的同步-数据一致" class="headerlink" title="9）redis与数据库的同步 数据一致"></a>9）redis与数据库的同步 数据一致</h3><ul><li><p>一致性要求高场景，实时同步方案，即查询redis，若查询不到再从DB查询，保存到redis；</p></li><li><p>更新redis时，先更新数据库，再将redis内容设置为过期(建议不要去更新缓存内容，直接设置缓存过期)，再用ZINCRBY增量修正redis数据</p></li><li><p>并发程度高的，采用异步队列的方式，采用kafka等消息中间件处理消息生产和消费</p></li><li><p>阿里的同步工具canal，实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发redis的更新，解放程序员双手，减少工作量</p></li><li><p>利用mysql触发器的API进行编程,c&#x2F;c++语言实现，学习成本高。</p></li></ul><h3 id="10）热数据与Mysql的同步编码实现-数据库上锁"><a href="#10）热数据与Mysql的同步编码实现-数据库上锁" class="headerlink" title="10）热数据与Mysql的同步编码实现 数据库上锁"></a>10）热数据与Mysql的同步编码实现 数据库上锁</h3><p>热点数据（经常会被查询，但是不经常被修改或者删除的数据），首选是使用redis缓存</p><p>用spring的AOP来构建redis缓存的自动生产和清除，过程如下：</p><ul><li>Select 数据库前查询redis，有的话使用redis数据，放弃select 数据库，没有的话，select 数据库，然后将数据插入redis</li><li>update或者delete 数据库数据<ul><li>高并发的情况下：先对数据库加锁，再删除redis</li><li>查询redis是否存在该数据，若存在则先对数据库加行锁，再删除redis，再update或者delete数据库中数据</li></ul></li><li>update或者delete redis，先更新数据库，再将redis内容设置为过期(建议不要去更新缓存内容，直接设置缓存过期)</li></ul><p> </p><p>出错场景：update先删掉了redis中的该数据，这时另一个线程执行查询，发现redis中没有，瞬间执行了查询SQL，并且插入到redis</p><h3 id="11）缓存穿透，缓存击穿，缓存雪崩解决方案分析"><a href="#11）缓存穿透，缓存击穿，缓存雪崩解决方案分析" class="headerlink" title="11）缓存穿透，缓存击穿，缓存雪崩解决方案分析"></a>11）缓存穿透，缓存击穿，缓存雪崩解决方案分析</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>我们的目标是：尽量少的线程构建缓存(甚至是一个) + 数据一致性 + 较少的潜在危险</p><p><a href="https://www.cnblogs.com/raichen/p/7750165.html">https://www.cnblogs.com/raichen/p/7750165.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引使用和优化</title>
      <link href="/2019/05/11/Mysql%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/"/>
      <url>/2019/05/11/Mysql%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引； </p><span id="more"></span><p>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替： </p><ul><li>正确选择复合索引中的主列字段，一般是选择性较好的字段； </li><li>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否  极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； </li><li>如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； </li><li>如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； </li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；<br>8、频繁进行数据操作的表，不要建立太多的索引；<br>9、删除无用的索引，避免对执行计划造成负面影响；</li></ul><p>以上是一些普遍的建立索引时的判断依据。索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。</p><p> 因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。 另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 </p><p>总的来说，小型表肯定不建索引，或者数据库记录在亿条数据级以上，还是建议使用非关系型数据库。 还有些特殊字段的数据库，比如BLOB，CLOB字段肯定也不适合建索引。</p><h3 id="对千万级MySQL数据库建立索引的事项及提高性能的手段"><a href="#对千万级MySQL数据库建立索引的事项及提高性能的手段" class="headerlink" title="对千万级MySQL数据库建立索引的事项及提高性能的手段"></a>对千万级MySQL数据库建立索引的事项及提高性能的手段</h3><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>首先，应当考虑表空间和磁盘空间是否足够。我们知道索引也是一种数据，在建立索引的时候势必也会占用大量表空间。因此在对一大表建立索引的时候首先应当考虑的是空间容量问题。<br>其次，在对建立索引的时候要对表进行加锁，因此应当注意操作在业务空闲的时候进行。</p><h4 id="性能调整方面"><a href="#性能调整方面" class="headerlink" title="性能调整方面"></a>性能调整方面</h4><p>首当其冲的考虑因素便是磁盘I&#x2F;O。物理上，应当尽量把索引与数据分散到不同的磁盘上（不考虑阵列的情况）。逻辑上，数据表空间与索引表空间分开。这是在建索引时应当遵守的基本准则。<br>其次，我们知道，在建立索引的时候要对表进行全表的扫描工作，因此，应当考虑调大初始化参数db_file_multiblock_read_count的值。一般设置为32或更大。</p><p>再次，建立索引除了要进行全表扫描外同时还要对数据进行大量的排序操作，因此，应当调整排序区的大小。<br>    9i之前，可以在session级别上加大sort_area_size的大小，比如设置为100m或者更大。<br>    9i以后，如果初始化参数workarea_size_policy的值为TRUE，则排序区从pga_aggregate_target里自动分配获得。<br>最后，建立索引的时候，可以加上nologging选项。以减少在建立索引过程中产生的大量redo，从而提高执行的速度。</p><h3 id="MySql在建立索引优化时需要注意的问题"><a href="#MySql在建立索引优化时需要注意的问题" class="headerlink" title="MySql在建立索引优化时需要注意的问题"></a>MySql在建立索引优化时需要注意的问题</h3><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>比如有一条语句是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where area=’beijing’ and age=22;</span><br></pre></td></tr></table></figure><p>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</p><h4 id="索引不会包含有NULL值的列"><a href="#索引不会包含有NULL值的列" class="headerlink" title="索引不会包含有NULL值的列"></a>索引不会包含有NULL值的列</h4><p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p><h4 id="使用短索引"><a href="#使用短索引" class="headerlink" title="使用短索引"></a>使用短索引</h4><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。</p><h4 id="排序的索引问题"><a href="#排序的索引问题" class="headerlink" title="排序的索引问题"></a>排序的索引问题</h4><p>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><h4 id="like语句操作"><a href="#like语句操作" class="headerlink" title="like语句操作"></a>like语句操作</h4><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%a%” 不会使用索引而like “aaa%”可以使用索引。</p><h4 id="不要在列上进行运算"><a href="#不要在列上进行运算" class="headerlink" title="不要在列上进行运算"></a>不要在列上进行运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where YEAR(adddate)</span><br></pre></td></tr></table></figure><h4 id="不使用NOT-IN和操作"><a href="#不使用NOT-IN和操作" class="headerlink" title="不使用NOT IN和操作"></a>不使用NOT IN和操作</h4><p>NOT IN和操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id3则可使用id&gt;3 or id</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat性能优化</title>
      <link href="/2019/05/11/Tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/05/11/Tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-What-is-Tomcat"><a href="#1-What-is-Tomcat" class="headerlink" title="1 What is Tomcat"></a>1 What is Tomcat</h3><p>The Apache Tomcat® software is an open source implementation of the Java Servlet, JavaServer<br>Pages, Java Expression Language and Java WebSocket technologies.</p><span id="more"></span><h3 id="2-Version-choose-and-reason"><a href="#2-Version-choose-and-reason" class="headerlink" title="2 Version choose and reason"></a>2 Version choose and reason</h3><h4 id="2-1-Version-choose"><a href="#2-1-Version-choose" class="headerlink" title="2.1 Version choose"></a>2.1 Version choose</h4><p>Tomcat版本：Tomcat8.0.11<br>jdk版本：大于等于jdk1.7—&gt;【Download&#x2F;Which version 】<br>tomcat各个版本下载地址：【Download&#x2F;Archives 】 各个版本产品和源码</p><h4 id="2-2-Reason"><a href="#2-2-Reason" class="headerlink" title="2.2 Reason"></a>2.2 Reason</h4><p>在tomcat7.0中没有NIO2，在tomcat8.5中没有BIO，而在tomcat8.0中支持的比较丰富<br>可以在源码中验证一下:AbstractEndpoint.bind()—&gt;implementation</p><h3 id="3-了解回顾"><a href="#3-了解回顾" class="headerlink" title="3 了解回顾"></a>3 了解回顾</h3><h4 id="3-1-源码需要引入的pom-xml文件"><a href="#3-1-源码需要引入的pom-xml文件" class="headerlink" title="3.1 源码需要引入的pom.xml文件"></a>3.1 源码需要引入的pom.xml文件</h4><p>在tomcat源码的根目录新建pom.xml文件，将下面这段内容复制到pom.xml文件中<br>The Apache Tomcat® software is an open source implementation of the Java Servlet, JavaServer<br>Pages, Java Expression Language and Java WebSocket technologies.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;Tomcat8.0&lt;/artifactId&gt;</span><br><span class="line">&lt;name&gt;Tomcat8.0&lt;/name&gt;</span><br><span class="line">&lt;version&gt;8.0&lt;/version&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;finalName&gt;Tomcat8.0&lt;/finalName&gt;</span><br><span class="line">&lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;</span><br><span class="line">&lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;java&lt;/directory&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;testResources&gt;</span><br><span class="line">&lt;testResource&gt;</span><br><span class="line">&lt;directory&gt;test&lt;/directory&gt;</span><br><span class="line">&lt;/testResource&gt;</span><br><span class="line">&lt;/testResources&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.3&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">&lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">&lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.easymock&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;easymock&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ant&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;ant&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;wsdl4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.xml&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;ecj&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.5.1&lt;/version&gt;</span><br><span class="line">&lt;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="3-2-tomcat产品目录文件含义"><a href="#3-2-tomcat产品目录文件含义" class="headerlink" title="3.2 tomcat产品目录文件含义"></a>3.2 tomcat产品目录文件含义</h4><p>（1）bin：主要用来存放命令，.bat是windows下，.sh是Linux下<br>（2）conf：主要用来存放tomcat的一些配置文件<br>（3）lib：存放tomcat依赖的一些jar包<br>（4）logs：存放tomcat在运行时产生的日志文件<br>（5）temp：存放运行时产生的临时文件<br>（6）webapps：存放应用程序<br>（7）work：存放tomcat运行时编译后的文件，比如JSP编译后的文件<br>这块咱们就不详细去说了，因为在Javaweb中都学过，即使忘了一些文件或者文件夹的作用，网上介绍的一大堆</p><h4 id="3-3-tomcat额外需知"><a href="#3-3-tomcat额外需知" class="headerlink" title="3.3 tomcat额外需知"></a>3.3 tomcat额外需知</h4><p>（1）Java语言写的<br>（2）servlet&#x2F;jsp technologies</p><h3 id="4-不妨手写一个mini的Tomcat"><a href="#4-不妨手写一个mini的Tomcat" class="headerlink" title="4 不妨手写一个mini的Tomcat"></a>4 不妨手写一个mini的Tomcat</h3><p>为什么要手写？既然上述提到了tomcat是java语言写的，又和servlet相关，那就自己设计一个试试，先不管作者的想法如<br>何</p><h4 id="4-1-确定tomcat作用"><a href="#4-1-确定tomcat作用" class="headerlink" title="4.1 确定tomcat作用"></a>4.1 确定tomcat作用</h4><p>web服务器，说白了就是能够让客户端和服务端进行交互，比如客户端想要获取服务端某些资源，服务端可以通过<br>tomcat去进行一些处理并且返回。</p><h4 id="4-2-基于Socket进行网络通信"><a href="#4-2-基于Socket进行网络通信" class="headerlink" title="4.2 基于Socket进行网络通信"></a>4.2 基于Socket进行网络通信</h4><p>实际上就是通过serversocket在服务端监听一个端口，等待客户端的连接，然后能够获取到对应的输入输出流<br></dependency><br></dependencies><br></project><br>&#x2F;&#x2F;基于网络编程socket套接字来做<br>class MyTomcat{<br>ServerSocket server&#x3D;new ServerSocket(8080);<br>Socket socket&#x3D;server.accept();<br>InputStream in&#x3D;socket.getInputStream();<br>OutputStream out&#x3D;socket.getOutputStream();<br>}</p><h4 id="4-3-优化"><a href="#4-3-优化" class="headerlink" title="4.3 优化"></a>4.3 优化</h4><p>发现一个比较靠谱的tomcat已经被我们写出来了，问题是这个tomcat如果使用起来方便吗？你会发现不方便，因为对应的<br>request和response都放到了tomcat源码的内部，业务人员想要进行开发时，很难获得request对象，从而获得客户端传来的<br>数据，也不能进行很好的返回，怎么办呢？<br>我们发现在JavaEE中有servlet这项技术，比如我们进行登录功能业务代码开发时,写过如下这段代码和配置<br>所以不妨让tomcat也实现servlet规范，这时候手写的tomcat源码就可以做一个改变</p><h4 id="4-4-手写版tomcat-servlets-真的可行吗？"><a href="#4-4-手写版tomcat-servlets-真的可行吗？" class="headerlink" title="4.4 手写版tomcat[servlets]真的可行吗？"></a>4.4 手写版tomcat[servlets]真的可行吗？</h4><p>换句话说：tomcat官方开发者对于用list集合保存项目中的servlets也是这样想的吗？我们可以从几个维度进行一下推测<br>&#x2F;&#x2F;优化1:将输入输出流封装到对象<br>class MyTomcat{<br>ServerSocket server&#x3D;new ServerSocket(8080);<br>Socket socket&#x3D;server.accept();<br>InputStream in&#x3D;socket.getInputStream();<br>new Request(in);<br>OutputStream out&#x3D;socket.getOutputStream();<br>new Response(out);<br>}<br>class Request{private String host;private String accept-language;}<br>class Response{}<br>&#x2F;&#x2F;优化2前奏：<br>class LoginServlet extends HttpServlet{<br>doGet(request,response){}<br>doPost(request,response){}<br>}<br><servlet><br><servlet-name>LoginServlet</servlet-name><br><servlet-class>com.gupao.web.servlet.SimpleServlet</servlet-class><br></servlet><br><servlet-mapping><br><servlet-name>LoginServlet</servlet-name><br><url-pattern>&#x2F;login</url-pattern><br></servlet-mapping><br>&#x2F;&#x2F;优化2：<br>class MyTomcat{<br>List list&#x3D;new ArrayList();<br>ServerSocket server&#x3D;new ServerSocket(8080);<br>Socket socket&#x3D;server.accept();<br>&#x2F;&#x2F;也就是这个地方不是直接处理request和response<br>&#x2F;&#x2F;而是处理一个个servlets<br>list.add(servlets);<br>}<br>4.4.1 servlet之业务代码<br>业务代码中关于servlet想必大家都配置过，或者用注解的方式，原本开发web应用就采用的是这样的方式。你的<br>controller中有很多自己写的servlet，都继承了HttpServlet类，然后web.xml文件中配置过所有的servlets，也就<br>是mapping映射，这个很简单。<br>4.4.2 servlet之产品角度<br>如果apache提供的tomcat也这么做了，势必也要跟servlet规范有关系，也就是要依赖servlet的jar包，我们来看一<br>下在tomcat产品的bin文件夹之下有没有servlet.jar，发现有。<br>4.4.3 servlet之源码角度<br>最后我们如果能够在tomcat源码中找到载入servlets的依据，就更加能说明问题了<br>于是我们在idea中的tomcat8.0源码，关键是到哪里找呢？总得有个入口吧？源码中除了能够看到各种Java类型的<br>文件之外，一脸懵逼，怎么办？<br>不妨先跳出来想想，如果我们是tomcat源码的设计者，也就是上述手写的代码，我们怎么将业务代码中的servlets<br>加载到源码中？我觉得可以分为两步<br>（1）加载web项目中的web.xml文件，解析这个文件中的servlet标签，将其变成java中的对象<br>（2）在源码中用集合保存<br>注意第（1）步，为什么是加载web.xml文件呢？因为要想加载servlets，一定是以web项目为单位的，而一个web项目中有多<br>少个servlet类，是会配置在web.xml文件中的。<br>寻找和验证<br>加载和解析web.xml文件<br>加载：ContextConfig.webConfig()—&gt;getContextWebXmlSource()—&gt;Constants.ApplicationWebXml<br>解析：ContextConfig.webConfig()—&gt;configureContext(webXml)—&gt;context.createWrapper()<br>将servlets加载到list集合中<br>StandardContext.loadOnStartup(Container children[])—&gt;list.add(wrapper)<br>4.4.4 加载servlets的疑惑<br>怎么知道上面找的过程的？<br>我们会发现上面加载web.xml文件和添加servlets都和Context有点关系，因为都有这个单词，那这个Context大家<br>眼熟吗？其实我们见过，比如你把web项目想要供外界访问时，你会添加web项目到webapps目录，这是tomcat<br>的规定，除此之外，还可以在conf&#x2F;server.xml文件中配置Context标签。<br>按照经验之谈，一般框架的设计者都会提供一两个核心配置文件给我们，比如server.xml就是tomcat提供给我们的，而这些<br>文件中的标签属性最终会对应到源码的类和属性<br>4.5 手写版tomcat[监听端口]可行吗？<br>换句话说：tomcat官方开发者对于监听端口也是这么设计的吗<br>其实我们手写的tomcat这块有两个核心：第一是监听端口，第二是添加servlets，上面解决了添加servlets。<br>接下来显然我们有必要验证一下监听端口tomcat也是这么做的吗？<br>4.5.1 监听端口之画图<br>上述的课堂中呈现出来的最好只有MyTomcat和Connector这块，其他先不管<br>在tomcat这块左边一定会监听在某个端口，等待客户端的连接，不然所有的操作都没办法进行交互<br>4.5.2 监听端口之源码角度<br>Connector.initInternal()-&gt;protocolHandler.init()-&gt;AbstractProtocol.init()-&gt;endpoint.init()-&gt;bind()-</p><blockquote><p>Apr,JIo,NIO,NIO2-&gt;JIo即Socket实现方式<br>4.5.3 监听端口的疑惑<br>为什么知道找Connector?<br>再次回到conf&#x2F;web.xml文件，发现有一个Connector标签，而且还可以配置port端口，我们能够联想到监听端口，<br>按照配置文件到源码类的经验，源码中一定会有这样一个Connector类用于端口的监听。<br>4.6 完善自己的tomcat架构图<br>4.7 推导出tomcat架构图<br>conclusion：架构图&lt;—&gt;server.xml&lt;—&gt;源码 三者有一一对应的关系<br>5 折腾Tomcat架构和源码<br>5.1 认识强化主要组件的含义<br>官网:Documentation&#x2F;Tomcat8.0&#x2F;Apache Tomcat Development&#x2F;Architecture&#x2F;Overview<br>Server<br>Service<br>Engine<br>In the Tomcat world, a Server represents the whole container. Tomcat provides a default<br>implementation of the Server interface which is rarely customized by users.<br>A Service is an intermediate component which lives inside a Server and ties one or more<br>Connectors to exactly one Engine. The Service element is rarely customized by users, as the<br>default implementation is simple and sufficient: Service interface.Engine<br>Host<br>Connector<br>Context<br>5.2 它们是如何协同工作的？<br>换句话说：之前找了两个点，监听端口，加载servlets的调用过程是如何的？<br>比如bind(),loadOnstartup()到底谁来调用？<br>此时大家还是要回归到最初的流程，客户端发起请求到得到响应来看。<br>客户端角度：发起请求，最终得到响应<br>tomcat代码角度：虽然是要监听端口和添加servlets进来，但是肯定有一个主函数，从主函数开始调用<br>说白了，如果我是源码设计者，既然架构图我都了解了，肯定是要把这些组件初始化出来，然后让它们一起工作，<br>也就是：<br>初始化一个个组件<br>利用这些组件进行相应的操作<br>5.2.1 寻找源码开始的地方<br>An Engine represents request processing pipeline for a specific Service. As a Service may<br>have multiple Connectors, the Engine receives and processes all requests from these<br>connectors, handing the response back to the appropriate connector for transmission to the<br>client. The Engine interface may be implemented to supply custom Engines, though this is<br>uncommon.<br>Note that the Engine may be used for Tomcat server clustering via the jvmRoute parameter.<br>Read the Clustering documentation for more information.<br>A Host is an association of a network name, e.g. <a href="http://www.yourcompany.com/">www.yourcompany.com</a>, to the Tomcat server.<br>An Engine may contain multiple hosts, and the Host element also supports network aliases<br>such as yourcompany.com and abc.yourcompany.com. Users rarely create custom Hosts because<br>the StandardHost implementation provides significant additional functionality.<br>A Connector handles communications with the client. There are multiple connectors available<br>with Tomcat. These include the HTTP connector which is used for most HTTP traffic,<br>especially when running Tomcat as a standalone server, and the AJP connector which<br>implements the AJP protocol used when connecting Tomcat to a web server such as Apache<br>HTTPD server. Creating a customized connector is a significant effort.<br>A Context represents a web application. A Host may contain multiple contexts, each with a<br>unique path. The Context interface may be implemented to create custom Contexts, but this<br>is rarely the case because the StandardContext provides significant additional<br>functionality.<br>一定有一个类，这个类中有main函数开始，这样才能有一款java源码到产品，一贯的作风。<br>感性的认知： BootStrap -&gt;main()-&gt;根据脚本命令-&gt;startd<br>daemon.load() 加载<br>daemon.start() 启动<br>果然被我们找到了，先加载再启动，那就继续看咯<br>5.2.2 加载:daemon.load()的过程<br>Bootstrap.main()-&gt;Bootstrap.load()-&gt;Catalina.load()-&gt;初始化的依据是什么？考虑coder的设计server.xml<br>-&gt;Lifecycle.init()-&gt;LifecycleBase.init()-&gt;LifecycleBase.initInternal()-&gt;StandardServer.initInternal()<br>-&gt;services[i].init()-&gt;StandardService.initInternal()-&gt;executor.init()&#x2F; connector.init()<br>-&gt;LifecyleBase.initInternal()-&gt;Connector.initInternal()-&gt;protocolHandler.init()-&gt;AbstractProtocol.init()<br>-&gt;endpoint.init()-&gt;bind()-&gt;Apr,JIo,NIO,NIO2<br>conclusion:请求目前没有来，只是内部的初始化工作<br>5.2.3 启动:daemon.start()的过程<br>Bootstrap.start()-&gt;Catalina.start()-&gt;getServer.start()-&gt;LifecycleBase.start()-&gt;LifecycleBase.startInternal()<br>-&gt;StandardServer.startInternal()-&gt;services[i].start()-&gt;StandardService.startInternal()<br>-&gt; container.start()[查看一下Container接口] &#x2F;executors.init()&#x2F;connectors.start()-&gt;engine.start()-<br>StandardEngine.startInternal()<br>查看一下StandardEngine类关系结构图，发现ContainerBase是它的爸爸，而这个爸爸有多少孩子呢？<br>-&gt;super[ContainerBase].startInternal()-&gt;代码呈现<br>关注到new StartChild(children[i])—&gt;child.start()，也就是会调用Engine子容器的start方法，那子容器是什么呢？<br>Host，child.start-&gt;LifecycleBase.start()-&gt;startInternal()-&gt;StandardHost.startInternal()<br>Host将一个个web项目加载进来<br>StandardHost.startInternal()-&gt;ContainerBase.startInternal()-&gt;最后threadStart()<br>-&gt;new Thread(new ContainerBackgroundProcessor())-&gt; run()[processChildren(ContainerBase.this)]<br>-&gt;container.backgroundProcess()-&gt;ContainerBase.backgroundProcess()<br>-&gt;fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null)-&gt;listener.lifecycleEvent(event)<br>-&gt;interested[i].lifecycleEvent(event)-&gt;监听器HostConfig-&gt;HostConfig.lifecycleEvent(LifecycleEvent event)<br>-&gt;check()-&gt; deployApps()<br>Engine,Host,Context,Wrapper都是它的孩子<br>results.add(startStopExecutor.submit(new StartChild(children[i])))<br>回到StandardHost.startInternal() -&gt;super.startInternal()<br>results.add(startStopExecutor.submit(new StartChild(children[i])));<br>然后又会调用它的子容器-&gt;super.startInternal()-&gt;StandardContext.initInternal()<br>StandardContext.startInternal()解析每个web项目<br>ContextConfig.webConfig()的step9解析到servlets包装成wrapper对象<br>何时调用loadOnstartup()<br>StandardContext.startInternal()-&gt;最终会调用if (!loadOnStartup(findChildren()))<br>5.3 官网验证上述流程<br>5.3.1 Server Startup<br>Documentation&#x2F;Tomcat8.0&#x2F;Apache Tomcat Development&#x2F;Architecture&#x2F;Server Startup:Server Startup<br>5.3.2 Request Process<br>Documentation&#x2F;Tomcat8.0&#x2F;Apache Tomcat Development&#x2F;Architecture&#x2F;Request Process:UML sequence<br>diagram<br>6 Tomcat性能优化思路<br>6.1 优化思路过渡<br>上面说了这么多，接下来咱们就来聊聊tomcat的性能优化，那怎么进行优化？哪些方面需要进行优化？先有一个<br>整体的认知。<br>其实还是要回归到问题的本质，一个客户端的连接请求响应的流程，看看这个过程经历了什么，哪些地方能够优<br>化。<br>当然，我要补充的一点是，服务器的CPU、内存、硬盘等对性能有决定性的影响，硬件这块配置越高越好。<br>再次看tomcat architecture ：<br>&#x2F;&#x2F; Deploy XML descriptors from configBase<br>deployDescriptors(configBase, configBase.list());<br>&#x2F;&#x2F; Deploy WARs<br>deployWARs(appBase, filteredAppPaths);<br>&#x2F;&#x2F; Deploy expanded folders<br>deployDirectories(appBase, filteredAppPaths);<br>fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null)-&gt;listener.lifecycleEvent(event)<br>interested[i].lifecycleEvent(event)-&gt;[找实现]ContextConfig.lifecycleEvent(LifecycleEvent event)-<br>configureStart()-&gt;webConfig()-&gt;解析每个web项目的xml文件了-&gt;getContextWebXmlSource()-<br>Constants.ApplicationWebXml<br>发现客户端的连接请求会和Connector打交道，对于Connector可以进行选择，比如Http Connector，A JP<br>Connector。<br>整体介绍:Documentation&#x2F;Tomcat8.0&#x2F;User Guide&#x2F;21)Connectors链接<br>详细介绍:Documentation&#x2F;Tomcat8.0&#x2F;Reference&#x2F;Configuration&#x2F;Connectors链接<br>Executor<br>介绍:Documentation&#x2F;Tomcat8.0&#x2F;Reference&#x2F;Configuration&#x2F;Executors链接<br>Context<br>介绍:Documentation&#x2F;Tomcat8.0&#x2F;Reference&#x2F;Configuration&#x2F;Containers&#x2F;Context链接<br>Context中加载web.xml文件时的源码<br>处理一些过滤器，全局servlet，session等等这些有一个全局的web.xml文件，在conf目录下，源码中会将两<br>者进行合并处理。<br>conclusion:要想改变上面这些内容，适当进行调整，咱们去修改tomcat源码显然不合适，那怎么修改呢？tomcat给我们提<br>供了可以进行定制自己组建的相关配置文件，比如说conf目录下的server.xml和web.xml文件,也就是说我们可以站在修改配<br>置文件的角度进行性能优化<br>继续思考tomcat性能优化思路<br>既然tomcat是Java写的，最终这些代码是会跑到jvm虚拟机中的，也就是说jvm的一些优化思路也可以在tomcat中<br>进行落实。<br>6.2 配置优化<br>由前面的分析可以定位目前两个重要的配置文件conf&#x2F;server.xml conf&#x2F;web.xml<br>6.2.1 conf&#x2F;server.xml核心组件<br>Server<br>官网描述:Server interface which is rarely customized by users. 【pass】<br>Service<br>官网描述:The Service element is rarely customized by users. 【pass】<br>Connector<br>官网描述:Creating a customized connector is a significant effort. 【need 】<br>Engine<br>官网描述:The Engine interface may be implemented to supply custom Engines, though this is uncommon.<br>【pass】<br>Host<br>官网描述:Users rarely create custom Hosts because the StandardHost implementation provides significant<br>additional functionality. 【pass】<br>Context<br>官网描述:The Context interface may be implemented to create custom Contexts, but this is rarely the case<br>because the StandardContext provides significant additional functionality. 【maybe 】<br>Context既然代表的是web应用，是和我们比较接近的，这块我们考虑对其适当的优化<br>conclusion:Connector and Context<br>6.2.2 conf&#x2F;server.xml非核心组件<br>官网:Documentation&#x2F;Reference&#x2F;Configuration&#x2F;Nested Components&#x2F;xxx<br>Listener<br>Global Resources<br>The GlobalNamingResources element defines the global JNDI resources for the [Server]<br>(<a href="https://tomcat.apache.org/tomcat-8.0-doc/config/server.html">https://tomcat.apache.org/tomcat-8.0-doc/config/server.html</a>)<br>Valve<br>功能类似于过滤器Filter<br>Realm<br>Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是Tomcat的启动和停止。<br><Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /></p></blockquote><!--监听内存溢出--><Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /><Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /><Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" />GlobalNamingResources元素定义了全局资源，通过配置可以看出，该配置是通过读取$TOMCAT_HOME/ conf/tomcatusers.xml实现的。<GlobalNamingResources><Resource name="UserDatabase" auth="Container"type="org.apache.catalina.UserDatabase"description="User database that can be updated and saved"factory="org.apache.catalina.users.MemoryUserDatabaseFactory"pathname="conf/tomcat-users.xml" /></GlobalNamingResources><Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"prefix="localhost_access_log" suffix=".txt"pattern="%h %l %u %t &quot;%r&quot; %s %b" />A Realm element represents a "database" of usernames, passwords, and roles (similar to Unix groups)assigned to those users.6.2.3 conf/web.xml全局的web.xml文件有些标签用不到的，可以删除掉，具体后面会说。6.3 JVM优化6.3.1 内存设置为了防止内存不够用，显然可以设置一下内存的大小6.3.2 GC算法选择合适的GC算法，其实内存大小的设置也会影响GC6.4 小结减少相关配置->查看日志tomcat启动时间项目方法:Connector->BIO/NIO/APR->压测某个项目的方法观察ThroughoutJVM :jconsole,gceasy.io,jvisual7 相关环境准备7.1 windowsjdk1.8mavengitideatomcat8.0Realm，可以把它理解成“域”；Realm提供了一种用户密码与web应用的映射关系，从而达到角色安全管理的作用。在本例中，Realm的配置使用name为UserDatabase的资源实现。而该资源在Server元素中使用GlobalNamingResources配置<Realm className="org.apache.catalina.realm.LockOutRealm"><!-- This Realm uses the UserDatabase configured in the global JNDIresources under the key "UserDatabase". Any editsthat are performed against this UserDatabase are immediatelyavailable for use by the Realm. --><Realm className="org.apache.catalina.realm.UserDatabaseRealm"resourceName="UserDatabase"/></Realm>Xshelljmeter用于本地压测观察ftp/rzsz用于本地和远端文件交互7.2 centos7本地搭建或者购买阿里云服务器安装centos系统jdk1.8本地上传到生产环境,解压配置环境变量maven本地上传到生产环境,解压配置环境变量tomcat8.0本地上传到生产环境,解压配置环境变量如果tomcat启动慢，则catalina.sh的JAVA_OPTS加入-Djava.security.egd=file:/dev/./urandom7.3 一个web项目7.4 JVisualVM监控java进程（1）命令行输入jvisualvm（2）选择本地的java进程【本地无需任何设置，直接连接即可】（3）监控远程tomcat输入远程ip地址，修改远端的catalina.sh文件，添加如下内容这是我上课用的账号和密码，只有一个月有效期ip地址:39.98.168.189账户:root密码:AAbb1234项目名称:gp/index.html项目介绍:其实就是一个静态页面，接下来就是对这个页面进行压测JAVA_OPTS="$JAVA_OPTS -Dcom.sun.management.jmxremote-Djava.rmi.server.hostname=39.98.168.189 -Dcom.sun.management.jmxremote.port=8998-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true-Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password-Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access"然后在jvisualvm中添加远程连接，JMX类型采坑指南查看hostname -i，修改/etc/hosts文件公网ip地址指向查询到的地址lsof -i tcp:8998 得到PID然后netstat -antup | grep PID 得到几个端口号，在阿里云安全组中添加相应端口上述修改之后要重启远端的tomcat添加JMX Connection，注意端口写8999防火墙要记得添加对应的策略在conf文件中添加两个文件jmxremote.access和jmxremote.password，内容分别为授予文件相应权限: chmod 600 *jmxremot*7.5 tomcat-manager/probe如果不想用jvisualvm来监控tomcat线程内存的信息，也可以选择tomcat自带的tomcat-manager或者probe来监控，只是有些功能没有那么完善。7.6 课程中常用命令启动停止tomcat,来到tomcat的bin文件夹启动: ./startup.sh停止:./shutdown.sh查看tomcat启动日志cat ../logs/catalina.outtail -f ../logs/catalina.out 相当于监控该日志文件解压tar -zxvf xxx查看进程及端口号查看进程: ps -ef | grep tomcat/java端口号:lsof -i tcp:8080杀掉进程kill PID查看jvm内所有线程guest readonlymanager readwriteguest guestmanager managerjstack PID官网线程状态描述maven打包mvn clean packagemvn clean package -Dmaven.test.skipjinfo查看jvm某个参数是否启用jinfo -flag UseParallelGC PIDjinfo -flag MaxHeapSize PID 查看最大内存jinfo -flag UseG1GC PID 查看垃圾回收器jinfo -flags PID 查看曾经赋过值的一些参数查看java进程jps -l查看jvm统计信息jstat -class/-gc PID 1000 10导出内存信息8 Tomcat性能优化写的不错的一篇文章链接:资料8.1 配置优化8.1.1 减少web.xml/server.xml中标签最终观察tomcat启动日志[时间/内容]，线程开销，内存大小，GC等DefaultServlet官网:User Guide->Default ServletThe default servlet is the servlet which serves static resources as well as serves the directory listings (ifdirectory listings are enabled).jmap -dump:format=b,file=heap.hprof pidjmap -heap pid 打印出堆内存相关的信息<servlet><servlet-name>default</servlet-name><servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class><init-param><param-name>debug</param-name><param-value>0</param-value></init-param><init-param>JspServletwelcome-list-filemime-mapping移除响应的内容支持的下载打开类型<param-name>listings</param-name><param-value>false</param-value></init-param><load-on-startup>1</load-on-startup></servlet><servlet-mapping><servlet-name>default</servlet-name><url-pattern>/</url-pattern></servlet-mapping><servlet><servlet-name>jsp</servlet-name><servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class><init-param><param-name>fork</param-name><param-value>false</param-value></init-param><init-param><param-name>xpoweredBy</param-name><param-value>false</param-value></init-param><load-on-startup>3</load-on-startup></servlet><servlet-mapping><servlet-name>jsp</servlet-name><url-pattern>*.jsp</url-pattern><url-pattern>*.jspx</url-pattern></servlet-mapping><welcome-file-list><welcome-file>index.html</welcome-file><welcome-file>index.htm</welcome-file><welcome-file>index.jsp</welcome-file></welcome-file-list>session-config默认jsp页面有session，就是在于这个配置8.1.2 调整优化server.xml中标签8.1.2.1 Connector标签protocol属性对于protocol="HTTP/1.1"，查看源码构造函数setProtocol(protocol)因为配置文件中传入的是HTTP/1.1并且这里没有使用APR，一会我们会演示APR<mime-mapping><extension>123</extension><mime-type>application/vnd.lotus-1-2-3</mime-type></mime-mapping><mime-mapping><extension>3dml</extension><mime-type>text/vnd.in3d.3dml</mime-type></mime-mapping><session-config><session-timeout>30</session-timeout></session-config><Connector port="8080" protocol="HTTP/1.1"connectionTimeout="20000"redirectPort="8443" />public Connector(String protocol) {setProtocol(protocol);}发现这里调用的是Http11NioProtocol，也就是说明tomcat8.0.x中默认使用的是NIO使用同样的方式看tomcat7和tomcat8.5，你会发现tomcat7默认使用的是BIO，tomcat8.5默认使用的是NIO针对BIO和NIO的方式进行压测（1）BIO来到tomcat官网Configuration/HTTP/protocolorg.apache.coyote.http11.Http11Protocol - blocking Java connectororg.apache.coyote.http11.Http11NioProtocol - non blocking Java NIO connectororg.apache.coyote.http11.Http11Nio2Protocol - non blocking Java NIO2 connectororg.apache.coyote.http11.Http11AprProtocol - the APR/native connector.使用tomcat7取巧一下，默认是BIO，端口改成7070，将tomcat-optimize复制到tomcat7中（2）NIOtomcat8.0中默认使用的是NIO针对上述BIO和NIO的方式，进行压测，调整并发数，看吞吐量（3）APR【具体查看操作手册/APR安装方式】下载以下内容：aprapr-iconvapr-util并且上传到centos中先安装一些依赖库: yum install apr* openssl-devel gcc make安装apr解压apr，cd到源码目录./configure --prefix=/usr/local/apr 指定安装的目录make 编译make install 安装else {if ("HTTP/1.1".equals(protocol)) {setProtocolHandlerClassName("org.apache.coyote.http11.Http11NioProtocol");} else if ("AJP/1.3".equals(protocol)) {setProtocolHandlerClassName("org.apache.coyote.ajp.AjpNioProtocol");} else if (protocol != null) {setProtocolHandlerClassName(protocol);}}安装apr-iconv解压apr-iconv，cd到源码目录./configure --prefix==/usr/local/apr-iconv --with-apr=/usr/local/apr 使用了一下刚才的aprmakemake install安装依赖包 yum install expat-devel安装apr-util解压apr-util,cd到源码目录./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/aprmakemake install安装openssl 1.0.2k解压，cd到源码目录./config --prefix=/usr/local/openssl修改Makefile文件，将CFLAG=-DOPENSSL_THREADS修改为CFLAG= -fPIC -DOPENSSL_THREADSmakemake install来到tomcat的bin目录解压tomcat-native.tar.gzcd tomcat-native-1.x-src/jni/native./configure --with-apr=/usr/local/apr --with-ssl=/usr/local/opensslmakemake install配置bin/catalina.shLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/libexport LD_LIBRARY_PATHserver.xml中的AprListener需要关闭SSL的方式，值设置为off重新启动tomcat，看日志apr的方式也可以压测看一下效果executor属性最佳线程数公式:((线程等待时间+线程cpu时间)/线程cpu时间) * cpu数量设置一些属性官网:https://tomcat.apache.org/tomcat-8.0-doc/config/http.htmlThe Executor represents a thread pool that can be shared between components in Tomcat.Historically there has been a thread pool per connector created but this allows you to share athread pool, between (primarily) connector but also other components when those get configuredto support executors（1）acceptCount:达到最大连接数之后，等待队列中还能放多少连接，超过即拒绝，配置太大也没有意义The maximum queue length for incoming connection requests when all possible request processingthreads are in use. Any requests received when the queue is full will be refused. The defaultvalue is 100.（2）maxConnections达到这个值之后，将继续接受连接，但是不处理，能继续接受多少根据acceptCount的值BIO:maxThreadsNIO/NIO2:10000 ——— AbstractEndpoint.maxConnectionsAPR:8192The maximum number of connections that the server will accept and process at any given time. Whenthis number has been reached, the server will accept, but not process, one further connection.This additional connection be blocked until the number of connections being processed falls belowmaxConnections at which point the server will start accepting and processing new connectionsagain. Note that once the limit has been reached, the operating system may still acceptconnections based on the acceptCount setting. The default value varies by connector type. For BIOthe default is the value of maxThreads unless an Executor is used in which case the default willbe the value of maxThreads from the executor. For NIO and NIO2 the default is 10000. ForAPR/native, the default is 8192.Note that for APR/native on Windows, the configured value will be reduced to the highest multipleof 1024 that is less than or equal to maxConnections. This is done for performance reasons.If set to a value of -1, the maxConnections feature is disabled and connections are not counted.（3）maxThreads:最大工作线程数，也就是用来处理request请求的，默认是200，如果自己配了executor，并且和Connector有关联了，则之前默认的200就会被忽略，取决于CPU的配置。监控中就可以看到所有的工作线程是什么状态，通过监控就能知道开启多少个线程合适The maximum number of request processing threads to be created by this Connector, which thereforedetermines the maximum number of simultaneous requests that can be handled. If not specified,this attribute is set to 200. If an executor is associated with this connector, this attribute isignored as the connector will execute tasks using the executor rather than an internal threadpool. Note that if an executor is configured any value set for this attribute will be recordedcorrectly but it will be reported (e.g. via JMX) as -1 to make clear that it is not used.（4）minSpareThreads最小空闲线程数The minimum number of threads always kept running. This includes both active and idle threads. Ifnot specified, the default of 10 is used. If an executor is associated with this connector, thisattribute is ignored as the connector will execute tasks using the executor rather than aninternal thread pool. Note that if an executor is configured any value set for this attributewill be recorded correctly but it will be reported (e.g. via JMX) as -1 to make clear that it isnot used.可以实践一下，Connector配合自定义的线程池其实这块最好的方式是结合BIO来看，因为BIO是一个request对应一个线程值太低，并发请求多了之后，多余的则进入等待状态。值太高，启动Tomcat将花费更多的时间。比如可以改成250。enableLookups设置为false删掉A JP的Connector8.1.2.2 Host标签autoDeploy :Tomcat运行时，要用一个线程拿出来进行检查，生产环境之下一定要改成falseThis flag value indicates if Tomcat should check periodically for new or updated web applicationswhile Tomcat is running. If true, Tomcat periodically checks the appBase and xmlBase directoriesand deploys any new web applications or context XML descriptors found. Updated web applicationsor context XML descriptors will trigger a reload of the web application. The flag's valuedefaults to true. See Automatic Application Deployment for more information.8.1.2.3 Context标签reloadable:falsereloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用。在开发阶段将reloadable属性设为true，有助于调试servlet和其它的class文件，但这样用加重服务器运行负荷，建议在Web应用的发存阶段将reloadable设为false。Set to true if you want Catalina to monitor classes in /WEB-INF/classes/ and /WEB-INF/lib forchanges, and automatically reload the web application if a change is detected. This feature isvery useful during application development, but it requires significant runtime overhead and isnot recommended for use on deployed production applications. That's why the default setting forthis attribute is false. You can use the Manager web application, however, to trigger reloads ofdeployed applications on demand.<Connector executor="tomcatThreadPool"port="8080" protocol="HTTP/1.1"connectionTimeout="20000"redirectPort="8443" /><Executor name="tomcatThreadPool" namePrefix="catalina-exec-"maxThreads="150" minSpareThreads="4"/>8.2 JVM优化8.2.1 JVM优化过渡为什么会有JVM这块的优化？因为tomcat是java语言写的，那么对于jvm这块的优化在tomcat中就是适用的。比如修改一些参数，调整内存大小，选择合适的垃圾回收算法等等。现在有个问题，修改JVM参数在哪里修改会对tomcat生效？还是在bin文件夹之下，有一个catalina.sh，找到JAVA_OPTS即可，当然不建议对此文件进行直接修改，一般是在外面新建一个文件，然后引入进来，我们就不这样做了，直接修改bin/catalina.sh 文件。8.2.2 运行时数据区和内存结构既然要对内存的大小做调整设置，你得认知一下jvm这块的内容，这里之前James老师的公开课和VIP课中讲过，当然你没听过也没关系，可以回头听一下，而且后面大白老师也会和大家讲这块的内容。结论:接下来我也站在我的角度和大家做一个简单的分享，这有利于接下来我们tomcat的jvm调优。运行时数据区是一个规范，内存结构是一个实际的实现运行时数据区官网:官网（1）程序计数器The pc RegisterJVM支持多线程同时执行，每一个线程都有自己的pc register，线程正在执行的方法叫做当前方法。如果是java代码，pc register中存放的就是当前正在执行的指令的地址，如果是c代码，则为空。（2）Java虚拟机栈Java Virtual Machine StacksJava虚拟机栈是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。（3）堆HeapJava堆是Java虚拟机所管理的内存中最大的一块。对是被所有线程共享的一块内存区域，在虚拟机启动时创建。次内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java对可以处于物理上不连续的内存空间中，只要逻辑上市连续的即可。（4）方法区Method Area方法区和Java堆一样，是各个线程共享的内存区域，也是在虚拟机启动时创建。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的是与Java堆区分开来。jdk1.8中就是metaspacejdk1.6或者1.7中就是perm space运行时常量池Runtime Constant Pool是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。（5）本地方法栈Native Method Stacks本地方法栈和虚拟机栈锁发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。内存结构上面对运行时数据区描述了很多，其实重点存储数据的是堆和方法区(非堆)，所以我们内存结构的设计也是着重从这两方面展开的。一块是非堆区，一块是堆区。堆区分为两大块，一个是Old区，一个是Young区。Young区分为两大块，一个是Survival区（S0+S1），一块是Eden区。 Eden:S0:S1=8:1:1S0和S1一样大，也可以叫From和To。在同一个时间点上，S0和S1只能有一个区有数据，另外一个是空的。8.2.3 垃圾回收算法为什么需要学习垃圾回收算法？Java是做自动内存管理的，自动垃圾回收。如何确定一个对象是否是垃圾，从而确定是否需要回收？（1）引用计数对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其引用，它就是垃圾。弊端:AB相互持有引用，导致永远不能被回收。（2）枚举根节点做可达性分析能作为根节点的:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等。常量的垃圾回收算法能够确定一个对象是垃圾之后，怎么回收？得要有对应的算法（1）标记清除先标记所有需要回收的对象，然后统一回收。缺点:效率不高，标记和清除两个过程的效率都不高，容易产生碎片，碎片太多会导致提前GC。（2）复制将内存按容量划分为大小相等的两块(S0和S1)，每次只使用其中一块。当这块使用完了，就讲还存活的对象复制到另一块上，然后再把已经使用过的内存空间一次性清除掉【Young区此采用的是复制算法】优缺点:实现简单，运行高效，但是空间利用率低。（3）标记整理标记需要回收的对象，然后让所有存活的对象移动到另外一端，直接清理掉端边界意外的内存。JVM中采用的是分代垃圾回收换句话说，堆中的Old区和Young区采用的垃圾回收算法是不一样的。（1）Young区：复制算法（2）Old区：标记清除或标记整理对象在被分配之后，可能声明周期比较短，Young区复制效率比较高。Old区对象存活时间比较长，复制来复制去没必要，不如做个标记。对象分配方式对象优先分配在Eden区大对象直接进入老年代，多大的对象称为大对象？可以通过JVM参数指定 -XX:PretenureSizeThreshold长期存活对象进入老年代8.2.4 垃圾收集器串行收集器Serial:Serial、Serial Old一个线程跑，停止，启动垃圾回收线程，回收完成，继续执行刚才暂停的线程。适用于内存比较小的嵌入式设备中。并行收集器Parallel:Parallel Scavenge、Parallel Old，吞吐量优先多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态，适合科学计算、后台处理等弱交互场景并发收集器Concurrent:CMS、G1，停顿时间优先用户线程和垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾收集线程在执行的时候不会停顿用户程序的运行。适合于对相应时间有要求的场景，比如Web。吞吐量和停顿时间解释吞吐量:花在垃圾收集的时间和花在应用程序时间的占比停顿时间:垃圾收集器做垃圾回收终端应用执行的时间小结: 评价一个垃圾回收器的好坏，其实调优的时候就是在观察者两个变量开启垃圾收集器Young区和Old区适用的垃圾回收器jdk1.8中比较推荐使用G1垃圾回收器，性能比较高。常用的G1 Collectorjdk1.7开始使用，jdk1.8非常成熟，jdk1.9默认的垃圾收集器要求:>=6GB,停顿时间小于0.5秒适用于新老生代（1）串行： -XX：+UseSerialGC -XX：+UseSerialOldGC 新老生代（2）并行(吞吐量优先)：-XX：+UseParallelGC-XX：+UseParallelOldGC（3）并发收集器(响应时间优先)CMS： -XX：+UseConcMarkSweepGCG1： -XX：+UseG1GC是否需要用G1的判断依据（1）50%以上的堆被存活对象占用（2）对象分配和晋升的速度变化非常大（3）垃圾回收时间比较长如何选择合适的垃圾回收器（1）优先调整堆的大小让服务器自己来选择（2）如果内存小于100M，使用串行收集器（3）如果是单核，并且没有停顿时间要求，使用串行或JVM自己选（4）如果允许停顿时间超过1秒，选择并行或JVM自己选（5）如果响应时间最重要，并且不能超过1秒，使用并发收集器8.2.5 两款GC日志分析工具评价一个垃圾回收器的好坏：吞吐量和停顿时间要想分析，得把GC日志打印出来才行，可以在tomcat中catalina.sh JAVA_OPTS配置相关参数XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:$CATALINA_HOME/logs/gc.log然后重启tomcat，下载下来看看内容在线:http://gceasy.io上述日志直接看比较费力，不妨借助工具，把gc.log下载到本地，然后上传到gceasy.io可以比较不同的垃圾回收器的日志情况GCViewer8.2.6 内存模型和GC联系Minor GC:新生代Major GC:老年代Full GC:新生代+老年代一个对象的一辈子-概要一般情况下,新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后,如果仍然存活,将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC,年龄就会增加1岁,当它的年龄增加到一定程度时,就会被移动到年老代中。一个对象的一辈子-理论在GC开始的时候,对象只会存在于Eden区和名为“From”的Survivor区,Survivor区“To”是空的。紧接着进行GC,Eden区中所有存活的对象都会被复制到“To”,而在“From”区中,仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值,可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中,没有达到阈值的对象会被复制到“To”区域。经过这次GC后,Eden区和From区已经被清空。这个时候,“From”和“To”会交换他们的角色,也就是新的“To”就是上次GC前的“From”,新的“From”就是上次GC前的“To”。不管怎样,都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。一个对象的一辈子-案例我是一个普通的Java对象,我出生在Eden区,在Eden区我还看到和我长的很像的小兄弟,我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了,我就被迫去了Survivor区的“From”区,自从去了Survivor区,我就开始漂了,有时候在Survivor的“From”区,有时候在Survivor的“To”区,居无定所。直到我18岁的时候,爸爸说我成人了,该去社会上闯闯了。于是我就去了年老代那边,年老代里,人很多,并且年龄都挺大的,我在这里也认识了很多人。在年老代里,我生活了20年(每次GC加一岁),然后被回收。为什么会有Survival区如果没有Survivor,Eden区每进行一次Minor GC,存活的对象就会被送到老年代。老年代很快被填满,触发Major GC(因为Major GC一般伴随着Minor GC,也可以看做触发了Full GC)。老年代的内存空间远大于新生代,进行一次Full GC消耗的时间比Minor GC长得多。你也许会问,执行时间长有什么坏处?频发的Full GC消耗的时间是非常可观的,这一点会影响大型程序的执行和响应速度,更不要说某些连接会因为超时发生连接错误了。增加老年代空间 更多存活对象才能填满老年代。降低Full GC频率 随着老年代空间加大,一旦发生Full GC,执行所需要的时间更长减少老年代空间 Full GC所需时间减少 老年代很快被存活对象填满,Full GC频率增加Survivor的存在意义,就是减少被送到老年代的对象,进而减少Full GC的发生,Survivor的预筛选保证,只有经历16次Minor GC还能在新生代中存活的对象,才会被送到老年代。为什么会有两个Survival区设置两个Survivor区最大的好处就是解决了碎片化,下面我们来分析一下。为什么一个Survivor区不行?第一部分中,我们知道了必须设置Survivor区。假设现在只有一个survivor区,我们来模拟一下流程:刚刚新建的对象在Eden中,一旦Eden满了,触发一次Minor GC,Eden中的存活对象就会被移动到Survivor区。这样继续循环下去,下一次Eden满了的时候,问题来了,此时进行Minor GC,Eden和Survivor各有一些存活对象,如果此时把Eden区的存活对象硬放到Survivor区,很明显这两部分对象所占有的内存是不连续的,也就导致了内存碎片化。永远有一个survivor space是空的,另一个非空的survivor space无碎片。8.2.7 JVM常见参数无论是设置内存大小还是选用不同的GC Collector都可以通过JVM参数的形式，所以我们有必要了解一下JVM参数相关的内容。标准参数-help-server -client-version -showversion-cp -classpathX参数非标准参数，也就是在jvm各个版本中可能会变-Xint 解释执行-Xcomp 第一次使用就编译成本地代码-Xmixed 混合模式，JVM自己来决定是否编译成本地代码XX参数特殊参数-Xmx -Xms 设置最大最小内存的不是X参数，而是XX参数-Xms等价于-XX:InitialHeapSize-Xmx等价于-XX:MaxHeapSize-Xss等价于-XX:ThreadStackSize查看JVM运行时参数得先知道当前的值是什么，然后才能设置调优=表示默认值:=表示被用户或JVM修改后的值查看PID: jps -l，专门用来查看java进程的jinfo 查看已经运行的jvm里面的参数值jinfo -flag MaxHeapSize PID 查看最大内存jinfo -flag UseG1GC PID 查看垃圾回收器jinfo -flags PID 查看曾经赋过值的一些参数jstat查看JVM统计信息（1）类装载jstat -class PID 1000 10PID进程ID，1000每个一秒钟，10输出10次（2）垃圾收集jstat -gc PID 1000 10平时用的最多的参数类型非标准化参数，相对不稳定，主要用于JVM调优和Debuga.Boolean类型格式：-XX:[+-]<name> 表示启用或者禁用name属性比如：-XX:+UseConcMarkSweepGC 表示启用CMS类型的垃圾回收器-XX:+UseG1GC 表示启用CMS类型的垃圾回收器b.非Boolean类型格式：-XX<name>=<value>表示name属性的值是value比如：-XX:MaxGCPauseMillis=500S0C S1C S0U S1U EC EU OC OU GCT2560.0 2560.0 0.0 2556.0 30720.0 29499.0 40960.0 11559.8 16512.0MC MU CCSC CCSU YGC YGCT FGC FGCT15968.7 1920.0 1795.4 3 0.038 0 0.000 0.0388.2.8 内存溢出和优化内存不够用主要分为两个方面：堆和非堆所以这时候就要去手动设置堆或者非堆的大小，然后程序中不停使用相对应的区域，等待内存溢出。关键是内存溢出之后，怎么得到溢出信息进行分析，有两种做法参数设置自动-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath=./jmap手动查看当前进程id PIDjmap -dump:format=b,file=heap.hprof PIDjmap -heap PID 打印出堆内存相关的信息当内存信息打印出来之后，发现看不懂，怎么办呢？得要有工具帮助我们看这块的信息，比如MAT小结:这块可以适当增加内存的大小，这样防止内存溢出，减少垃圾回收的频率8.2.9 GC调优（1）查看目前JVM使用的垃圾回收器[root@pretty ~]# jinfo -flag UseParallelGC 6925-XX:+UseParallelGC --->发现使用了ParallelGC[root@pretty ~]# jinfo -flag UseG1GC 6925-XX:-UseG1GC --->发现没有使用G1GC（2）将垃圾回收器修改为G1-XX:+UseG1GC[root@pretty ~]# jinfo -flag UseG1GC 7158-XX:+UseG1GC（3）打印出日志详情信息和日志输出目录文件PrintGCDetails:打印日志详情信息PrintGCTimeStamps:输出GC的时间戳(以基准时间的形式)（4）将日志用工具来分析，看相应的参数8.2.10 JVM调优小结内存大小设置——>dump出日志 使用MAT工具分析垃圾收集器选择———>dump出GC日志 gceasy或者GCViewer8.3 其他优化Connector配置压缩属性compression="500"，文件大于500bytes才会压缩数据库优化减少对数据库访问等待的时间，可以从数据库的层面进行优化，或者加缓存等等各种方案。开启浏览器缓存，nginx静态资源部署9 嵌入式Tomcat主类寻找9.1 maven寻找:Tomcat7RunnerCli类，寻找main函数9.2 springbootorg.springframework.boot.context.embedded.tomcat.EmbeddedServletContainerCustomizer-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:$CATALINA_HOME/logs/g1gc.log<dependency><groupId>org.apache.tomcat.maven</groupId><artifactId>tomcat7-maven-plugin</artifactId><version>2.0</version></dependency>// 相当于 new TomcatContextCustomizer(){}factory.addContextCustomizers((context) -> { // Lambdaif (context instanceof StandardContext) {StandardContext standardContext = (StandardContext) context;// standardContext.setDefaultWebXml(); // 设置}});]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四种引用的理解</title>
      <link href="/2018/12/22/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/12/22/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>受检查异常和非受检查异常的区别</title>
      <link href="/2018/12/21/%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/12/21/%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker命令整理</title>
      <link href="/2018/10/18/Docker%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2018/10/18/Docker%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之ConcurrentHashMap原理分析</title>
      <link href="/2018/08/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BConcurrentHashMap%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BConcurrentHashMap%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在并发编程实践中，ConcurrentHashMap是一个经常被使用的数据结构，相比于Hashtable和Collections.synchronizedMap()，前者在线程安全的基础上提供了更好的写并发能力，但同时降低了对读一致性的要求。ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS和锁分段的技术来减少锁竞争对于性能的影响，接下来我将分别阐述ConcurrentHashMap在JDK6&#x2F;7&#x2F;8分别是如何实现的。</p><span id="more"></span><h2 id="1-JDK1-6和1-7中的实现"><a href="#1-JDK1-6和1-7中的实现" class="headerlink" title="1. JDK1.6和1.7中的实现"></a>1. JDK1.6和1.7中的实现</h2><h3 id="1-1-设计思路"><a href="#1-1-设计思路" class="headerlink" title="1.1 设计思路"></a>1.1 设计思路</h3><p>在jdk1.6和1.7中采用了锁分段的技术实现，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争，相比于HashTable对整个map加锁的设计，分段锁大大的提高了高并发环境下的处理能力，正因为不是对整个map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如clear()）甚至放弃了对一致性的要求（ConcurrentHashMap是弱一致性的；</p><p>ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，代码如下：</p><pre><code>static final class HashEntry&lt;K,V&gt; &#123;    final int hash;    final K key;    volatile V value;    volatile HashEntry&lt;K,V&gt; next;</code></pre><h3 id="1-2-并发度（Concurrency-Level）"><a href="#1-2-并发度（Concurrency-Level）" class="headerlink" title="1.2 并发度（Concurrency Level）"></a>1.2 并发度（Concurrency Level）</h3><p>并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，但用户也可以在构造函数中设置并发度。当用户设置并发度时，ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。运行时通过将key的高n位（n &#x3D; 32 – segmentShift）和并发度减1（segmentMask）做位与运算定位到所在的Segment。segmentShift与segmentMask都是在构造过程中根据concurrency level被相应的计算出来。</p><p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。（文档的说法是根据你并发的线程数量决定，太多会导性能降低）。</p><h3 id="1-3-创建分段锁"><a href="#1-3-创建分段锁" class="headerlink" title="1.3 创建分段锁"></a>1.3 创建分段锁</h3><p>和JDK6不同，JDK7中除了第一个Segment之外，剩余的Segments采用的是延迟初始化的机制：每次put之前都需要检查key对应的Segment是否为null，如果是则调用ensureSegment()以确保对应的Segment被创建。</p><p>ensureSegment可能在并发环境下被调用，但与想象中不同，ensureSegment并未使用锁来控制竞争，而是使用了Unsafe对象的getObjectVolatile()提供的原子读语义结合CAS来确保Segment创建的原子性。代码段如下：<br>    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                &#x3D;&#x3D; null) { &#x2F;&#x2F; recheck<br>                Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);<br>                while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                       &#x3D;&#x3D; null) {<br>                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))<br>                        break;<br>                }<br>}</p><h3 id="1-4-put-putIfAbsent-putAll"><a href="#1-4-put-putIfAbsent-putAll" class="headerlink" title="1.4 put&#x2F;putIfAbsent&#x2F;putAll"></a>1.4 put&#x2F;putIfAbsent&#x2F;putAll</h3><p>和JDK6一样，ConcurrentHashMap的put方法被代理到了对应的Segment（定位Segment的原理之前已经描述过）中。与JDK6不同的是，JDK7版本的ConcurrentHashMap在获得Segment锁的过程中，做了一定的优化 - 在真正申请锁之前，put方法会通过tryLock()方法尝试获得锁，在尝试获得锁的过程中会对对应hashcode的链表进行遍历，如果遍历完毕仍然找不到与key相同的HashEntry节点，则为后续的put操作提前创建一个HashEntry。当tryLock一定次数后仍无法获得锁，则通过lock申请锁。</p><p>需要注意的是，由于在并发环境下，其他线程的put，rehash或者remove操作可能会导致链表头结点的变化，因此在过程中需要进行检查，如果头结点发生变化则重新对表进行遍历。而如果其他线程引起了链表中的某个节点被删除，即使该变化因为是非原子写操作（删除节点后链接后续节点调用的是Unsafe.putOrderedObject()，该方法不提供原子写语义）可能导致当前线程无法观察到，但因为不影响遍历的正确性所以忽略不计。</p><p>之所以在获取锁的过程中对整个链表进行遍历，主要目的是希望遍历的链表被CPU cache所缓存，为后续实际put过程中的链表遍历操作提升性能。</p><p>在获得锁之后，Segment对链表进行遍历，如果某个HashEntry节点具有相同的key，则更新该HashEntry的value值，否则新建一个HashEntry节点，将它设置为链表的新head节点并将原头节点设为新head的下一个节点。新建过程中如果节点总数（含新建的HashEntry）超过threshold，则调用rehash()方法对Segment进行扩容，最后将新建HashEntry写入到数组中。</p><p>put方法中，链接新节点的下一个节点（HashEntry.setNext()）以及将链表写入到数组中（setEntryAt()）都是通过Unsafe的putOrderedObject()方法来实现，这里并未使用具有原子写语义的putObjectVolatile()的原因是：JMM会保证获得锁到释放锁之间所有对象的状态更新都会在锁被释放之后更新到主存，从而保证这些变更对其他线程是可见的。</p><h3 id="1-5-rehash"><a href="#1-5-rehash" class="headerlink" title="1.5 rehash"></a>1.5 rehash</h3><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。这部分代码如下：<br>    private void rehash(HashEntry&lt;K,V&gt; node) {<br>           HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;<br>           int oldCapacity &#x3D; oldTable.length;<br>           int newCapacity &#x3D; oldCapacity &lt;&lt; 1;<br>           threshold &#x3D; (int)(newCapacity * loadFactor);<br>           HashEntry&lt;K,V&gt;[] newTable &#x3D;<br>               (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];<br>           int sizeMask &#x3D; newCapacity - 1;<br>           for (int i &#x3D; 0; i &lt; oldCapacity ; i++) {<br>               HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];<br>               if (e !&#x3D; null) {<br>                   HashEntry&lt;K,V&gt; next &#x3D; e.next;<br>                   int idx &#x3D; e.hash &amp; sizeMask;<br>                   if (next &#x3D;&#x3D; null)   &#x2F;&#x2F;  Single node on list<br>                       newTable[idx] &#x3D; e;<br>                   else { &#x2F;&#x2F; Reuse consecutive sequence at same slot<br>                       HashEntry&lt;K,V&gt; lastRun &#x3D; e;<br>                       int lastIdx &#x3D; idx;<br>                       for (HashEntry&lt;K,V&gt; last &#x3D; next;<br>                            last !&#x3D; null;<br>                            last &#x3D; last.next) {<br>                           int k &#x3D; last.hash &amp; sizeMask;<br>                           if (k !&#x3D; lastIdx) {<br>                               lastIdx &#x3D; k;<br>                               lastRun &#x3D; last;<br>                           }<br>                       }<br>                       newTable[lastIdx] &#x3D; lastRun;<br>                       &#x2F;&#x2F; Clone remaining nodes<br>                       for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) {<br>                           V v &#x3D; p.value;<br>                           int h &#x3D; p.hash;<br>                           int k &#x3D; h &amp; sizeMask;<br>                           HashEntry&lt;K,V&gt; n &#x3D; newTable[k];<br>                           newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);<br>                       }<br>                   }<br>               }<br>           }<br>           int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node<br>           node.setNext(newTable[nodeIndex]);<br>           newTable[nodeIndex] &#x3D; node;<br>           table &#x3D; newTable;<br>       }</p><h3 id="1-6-remove"><a href="#1-6-remove" class="headerlink" title="1.6 remove"></a>1.6 remove</h3><p>和put类似，remove在真正获得锁之前，也会对链表进行遍历以提高缓存命中率。</p><h3 id="1-7-get与containsKey"><a href="#1-7-get与containsKey" class="headerlink" title="1.7 get与containsKey"></a>1.7 get与containsKey</h3><p>get与containsKey两个方法几乎完全一致：他们都没有使用锁，而是通过Unsafe对象的getObjectVolatile()方法提供的原子读语义，来获得Segment以及对应的链表，然后对链表遍历判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p><h3 id="1-8-size、containsValue"><a href="#1-8-size、containsValue" class="headerlink" title="1.8 size、containsValue"></a>1.8 size、containsValue</h3><p>这些方法都是基于整个ConcurrentHashMap来进行操作的，他们的原理也基本类似：首先不加锁循环执行以下操作：循环所有的Segment（通过Unsafe的getObjectVolatile()以保证原子读语义），获得对应的值以及所有Segment的modcount之和。如果连续两次所有Segment的modcount和相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p><p>当循环次数超过预定义的值时，这时需要对所有的Segment依次进行加锁，获取返回值后再依次解锁。值得注意的是，加锁过程中要强制创建所有的Segment，否则容易出现其他线程创建Segment并进行put，remove等操作。代码如下：</p><pre><code>for(int j =0; j &lt; segments.length; ++j)     ensureSegment(j).lock();// force creation</code></pre><p>一般来说，应该避免在多线程环境下使用size和containsValue方法。</p><blockquote><p>注1：modcount在put, replace, remove以及clear等方法中都会被修改。</p></blockquote><blockquote><p>注2：对于containsValue方法来说，如果在循环过程中发现匹配value的HashEntry，则直接返回true。</p></blockquote><p>最后，与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照Doug Lea的说法，这么设计的原因是在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key&#x2F;value没有映射完成就被其他线程所见，需要特殊处理。在JDK6中，get方法的实现中就有一段对HashEntry.value &#x3D;&#x3D; null的防御性判断。但Doug Lea也承认实际运行过程中，这种情况似乎不可能发生。</p><h2 id="2-JDK8中的实现"><a href="#2-JDK8中的实现" class="headerlink" title="2. JDK8中的实现"></a>2. JDK8中的实现</h2>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么String类是不可变的</title>
      <link href="/2018/07/30/%E4%B8%BA%E4%BB%80%E4%B9%88String%E7%B1%BB%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/"/>
      <url>/2018/07/30/%E4%B8%BA%E4%BB%80%E4%B9%88String%E7%B1%BB%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>String是所有语言中最常用的一个类。我们知道在Java中，String是不可变的、final的。Java在运行时也保存了一个字符串池(String pool)，这使得String成为了一个特别的类。</p><span id="more"></span><h3 id="String类不可变性的好处"><a href="#String类不可变性的好处" class="headerlink" title="String类不可变性的好处"></a>String类不可变性的好处</h3><ul><li><p>只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(译者注：String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串。)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</p></li><li><p>如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p></li><li><p>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p></li><li><p>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p></li><li><p>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串</p></li></ul><blockquote><p>如果觉得翻译不好的，可以查看原文<a href="https://www.journaldev.com/802/string-immutable-final-java">原文链接</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Consulu服务注册和发现</title>
      <link href="/2018/07/05/Consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/"/>
      <url>/2018/07/05/Consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction-to-Consul"><a href="#Introduction-to-Consul" class="headerlink" title="Introduction to Consul"></a>Introduction to Consul</h3><p>欢迎来到Consul导览!这本指南是我们从Consul开始的最好地方。我们将介绍Consul是什么，它可以解决什么问题，它如何与现有的软件进行比较，以及如何开始使用它。如果您熟悉Consul的基本知识，那么文档将提供可用特性的更详细参考.</p><span id="more"></span><h3 id="What-is-Consul"><a href="#What-is-Consul" class="headerlink" title="What is Consul?"></a>What is Consul?</h3><p>Consul(<a href="https://www.consul.io/">https://www.consul.io/</a>) 是一个服务网格解决方案，提供了一个功能齐全的控制平面与服务发现，配置，和分割功能。这些特性可以根据需要单独使用，也可以一起使用来构建一个完整的服务网格。Consul需要一个数据平面，并支持代理和本地集成模型。Consul船与一个简单的内置代理，使一切工作开箱，但也支持第三方代理集成，如特使</p><p>其官方网站上列出了它的五点主要功能：</p><ul><li>服务发现<br>Consul的客户端可以注册服务，如api或mysql，其他客户端可以使用Consul来发现给定服务的提供者。使用DNS或HTTP，应用程序可以很容易地找到它们所依赖的服务</li><li>健康检查<br>Consul客户端可以提供任意数量的健康检查，要么与给定的服务关联(“web服务器是否返回200 OK”)，要么与本地节点关联(“内存利用率是否低于90%”)。操作员可以使用这些信息来监视集群的健康状况，服务发现组件可以使用这些信息来将流量路由到不健康的主机,关于健康检查的更多信息，可以参考 <a href="https://www.consul.io/docs/agent/checks.html%E3%80%82">https://www.consul.io/docs/agent/checks.html。</a></li><li>KV 存储<br>应用程序可以使用Consul的分层密钥&#x2F;值存储用于任何目的，包括动态配置、特性标记、协调、领导人选举等。简单的HTTP API使其易于使用。</li><li>安全服务通信<br>Consul可以为服务生成和分发TLS证书，以建立相互的TLS连接。意图可以用来定义允许哪些服务进行通信。服务细分可以很容易地管理，其意图可以实时更改，而无需使用复杂的网络拓扑和静态防火墙规则。</li><li>多数据中心支持<br>Consul支持多个数据中心开箱即用。这意味着Consul的用户不必担心构建额外的抽象层来扩展到多个区域。</li></ul><h3 id="Consul的基本机构"><a href="#Consul的基本机构" class="headerlink" title="Consul的基本机构"></a>Consul的基本机构</h3><p>Consul是一个分布式的，高度可用的系统。本节将介绍基本知识，有意省略一些不必要的细节，以便您能够快速了解Consul是如何工作的。有关更多细节，请参阅深入的体系结构概述。</p><p>为Consul提供服务的每个节点都运行一个Consul代理。运行代理不需要发现其他服务或获取&#x2F;设置键&#x2F;值数据。代理负责对节点上的服务以及节点本身进行健康检查。</p><p>代理与一个或多个Consul服务器通信。Consul服务器是存储和复制数据的地方。服务器自己选举一个领导者。虽然Consul可以与一台服务器一起工作，但建议使用3到5来避免导致数据丢失的故障场景。对于每个数据中心，建议使用一组Consul服务器。</p><p>需要发现其他服务或节点的基础设施组件可以查询任何Consul服务器或任何Consul代理。代理自动将查询转发到服务器。</p><p>每个数据中心运行一个Consul服务器集群。当跨数据中心服务发现或配置请求发出时，本地Consul服务器将请求转发到远程数据中心并返回结果。</p><h3 id="Consul的安装和启动"><a href="#Consul的安装和启动" class="headerlink" title="Consul的安装和启动"></a>Consul的安装和启动</h3><p>要使用Consul，我们需要先安装它。Consul是用golang开发的(GitHub 地址为：<a href="https://github.com/hashicorp/consul">https://github.com/hashicorp/consul</a> ),其分发的安装包里包含的是针<br>对各个不同平台预先编译好的二进制文件，解压即可使用。安装包可以到<a href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a> 下载获得。以 Linux 为例，我们可以<br>通过一下命令来完成安装：</p><h5 id="1-下载-consul，这里用-linux-64bit-的-1-0-7-版本"><a href="#1-下载-consul，这里用-linux-64bit-的-1-0-7-版本" class="headerlink" title="1.下载 consul，这里用 linux 64bit 的 1.0.7 版本"></a>1.下载 consul，这里用 linux 64bit 的 1.0.7 版本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -LO https://releases.hashicorp.com/consul/1.0.7/</span><br><span class="line">consul_1.0.7_linux_amd64.zip</span><br><span class="line">% Total % Received % Xferd Average Speed Time Time Time Current</span><br><span class="line">Dload Upload Total Spent Left Speed</span><br><span class="line">100 11.7M 100 11.7M 0 0 1477k 0 0:00:08 0:00:08 --:--:-- 2466k</span><br></pre></td></tr></table></figure><h5 id="2-解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）"><a href="#2-解压（zip-包里面只包含了一个可执行-绿色的文件，名字就叫-consul）" class="headerlink" title="2.解压（zip 包里面只包含了一个可执行&#x2F;绿色的文件，名字就叫 consul）"></a>2.解压（zip 包里面只包含了一个可执行&#x2F;绿色的文件，名字就叫 consul）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ unzip consul_1.0.7_linux_amd64.zip</span><br><span class="line">Archive: consul_1.0.7_linux_amd64.zip</span><br><span class="line">inflating: consul</span><br></pre></td></tr></table></figure><h5 id="3-将-consul-移动到-PATH-中，方便后续敲命令"><a href="#3-将-consul-移动到-PATH-中，方便后续敲命令" class="headerlink" title="3.将 consul 移动到$PATH 中，方便后续敲命令"></a>3.将 consul 移动到$PATH 中，方便后续敲命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> consul /usr/local/bin 完成后，我们可以用 consul --version 命令来验证一下：</span><br><span class="line">$ consul --version</span><br><span class="line">Consul v1.0.7 Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when</span><br><span class="line">speaking to compatible agents)</span><br></pre></td></tr></table></figure><p>好了，consul 安装成功了。接下来我们启动 consul。Consul agent 是 Consul的核心进程，它可以工作在client或server模式下。关于Consul的架构以及如何搭建 Consul 集群超出了本文要讨论的范围，感兴趣的读者可以参考 <a href="https://www.consul.io/docs/internals/architecture.html%E3%80%82">https://www.consul.io/docs/internals/architecture.html。</a> 这里，我们采用一种简单(不推荐在生产环境使用）的方式来启动一个Consul agent:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ consul agent -data-dir=/tmp/consul -dev -<span class="built_in">bind</span>=127.0.0.1</span><br><span class="line">==&gt; Starting Consul agent...</span><br><span class="line">==&gt; Consul agent running!</span><br><span class="line">Version: <span class="string">&#x27;v1.0.7&#x27;</span></span><br><span class="line">Node ID: <span class="string">&#x27;17028164-ad99-b9f4-6769-b74fcfce6f96&#x27;</span></span><br><span class="line">Node name: <span class="string">&#x27;brian-pc&#x27;</span></span><br><span class="line">Datacenter: <span class="string">&#x27;dc1&#x27;</span> (Segment: <span class="string">&#x27;&lt;all&gt;&#x27;</span>)</span><br><span class="line">Server: <span class="literal">true</span> (Bootstrap: <span class="literal">false</span>)</span><br><span class="line">Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, DNS: 8600)</span><br><span class="line">Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)</span><br><span class="line">Encrypt: Gossip: <span class="literal">false</span>, TLS-Outgoing: <span class="literal">false</span>, TLS-Incoming: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>从输出的日志，我们可以看到这个agent工作在 Server模式下(Server:true），并监听了8500端口。在浏览器中输入 <a href="http://127.0.0.1:8500/">http://127.0.0.1:8500</a> 我们可以看到<br>如下界面：</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> consul </tag>
            
            <tag> java </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/2018/06/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/06/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。排序算法大体可分为两种：一种是比较排序，时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。另一种是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。这里我们来探讨一下常用的算法。</p><span id="more"></span><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><a href="https://github.com/whd-mtt/interview-preparation/blob/master/src/main/java/com/whd/interview/preparation/sortalgorithm/BubbleSort.java">1.冒泡排序</a></p><blockquote><p>算法思想：从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端</p></blockquote><p>算法步骤：<br>（1）从数组中第一个数开始，依次与下一个数比较并次交换比自己小的数，直到最后一个数。如果发生交换，则继续下面的步骤，如果未发生交换，则数组有序，排序结束，此时时间复杂度为O(n)；<br>（2）每一轮”冒泡”结束后，最大的数将出现在乱序数列的最后一位。重复步骤（1）。</p><p>稳定性：稳定排序。</p><p>时间复杂度： O(n)至O(n2)，平均时间复杂度为O(n2)。<br>最好的情况：如果待排序数据序列为正序，则一趟冒泡就可完成排序，排序码的比较次数为n-1次，且没有移动，时间复杂度为O(n)。<br>最坏的情况：如果待排序数据序列为逆序，则冒泡排序需要n-1次趟起泡，每趟进行n-i次排序码的比较和移动，即比较和移动次数均达到最大值：<br>比较次数:Cmax&#x3D;∑i&#x3D;1n−1(n−i)&#x3D;n(n−1)&#x2F;2&#x3D;O(n2)<br>移动次数等于比较次数，因此最坏时间复杂度为O(n2)。</p><p><a href="https://github.com/whd-mtt/interview-preparation/blob/master/src/main/java/com/whd/interview/preparation/sortalgorithm/QuickSort.java">2.快速排序</a><br>快速排序（Quicksort）是对冒泡排序的一种改进</p><blockquote><p>算法思想： 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><p>(1)设置两个变量i、j，排序开始的时候：i&#x3D;0，j&#x3D;N-1；<br>(2)以第一个数组元素作为关键数据，赋值给key，即key&#x3D;A[0]；<br>(3)从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>(4)从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>(5)重复第3、4步，直到i&#x3D;j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j&#x3D;j-1，i&#x3D;i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i&#x3D;&#x3D;j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><p>稳定性：不稳定排序。</p><p>时间复杂度： O（nlog2n）至O(n2)，平均时间复杂度为O（nlgn）。<br>最好的情况：是每趟排序结束后，每次划分使两个子文件的长度大致相等，时间复杂度为O（nlog2n）。<br>最坏的情况：是待排序记录已经排好序，第一趟经过n-1次比较后第一个记录保持位置不变，并得到一个n-1个元素的子记录；第二趟经过n-2次比较，将第二个记录定位在原来的位置上，并得到一个包括n-2个记录的子文件，依次类推，这样总的比较次数是：<br>Cmax&#x3D;∑i&#x3D;1n−1(n−i)&#x3D;n(n−1)&#x2F;2&#x3D;O(n2)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu16.04.3安装RabbitMQ服务器</title>
      <link href="/2018/06/03/Bootstrap-table%E5%88%86%E9%A1%B5%E5%88%A0%E9%99%A4%E5%B0%BE%E9%A1%B5%E6%95%B0%E6%8D%AE%E5%90%8E%E5%88%B7%E6%96%B0%E6%97%A0%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/03/Bootstrap-table%E5%88%86%E9%A1%B5%E5%88%A0%E9%99%A4%E5%B0%BE%E9%A1%B5%E6%95%B0%E6%8D%AE%E5%90%8E%E5%88%B7%E6%96%B0%E6%97%A0%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构，关于消息队列，市面上有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ这样一些消息队列，但是目前大家用得最多的就是Kafka，<strong>RabbitMQ</strong>，ActiveMQ，但是我们常用的<strong>SpringBoot</strong>不支持ActiveMQ（支持Kafka，RabbitMQ），所以先动手实现在linux上安装RabbitMQ服务器。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>为了顺利，建议大家以官方文档，根据这个链接<a href="http://www.rabbitmq.com/install-debian.html">http://www.rabbitmq.com/install-debian.html</a>实现安装;</p></blockquote><h3 id="添加新的源"><a href="#添加新的源" class="headerlink" title="添加新的源"></a>添加新的源</h3><ul><li>添加新的源 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;deb http://www.rabbitmq.com/debian/ testing main&#x27;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/rabbitmq.list</span><br></pre></td></tr></table></figure></li></ul><h3 id="下载公钥"><a href="#下载公钥" class="headerlink" title="下载公钥"></a>下载公钥</h3><ul><li>下载公钥，防止后面的安装出现安全警告（可选，不执行此步骤也不会影响安装）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新和安装"><a href="#更新和安装" class="headerlink" title="更新和安装"></a>更新和安装</h3><ul><li><p>更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure><p>这时候我们可以通过ps -ef|grep rabbit命令来看哈情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep rabbit </span><br></pre></td></tr></table></figure><p>使用上述命令边可以查看到如下信息：</p><p>  rabbitmq  1609     1  0 21:46 ?        00:00:02 &#x2F;usr&#x2F;lib&#x2F;erlang&#x2F;erts-7.3&#x2F;bin&#x2F;beam -W w -A 64 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K true – -root &#x2F;usr&#x2F;lib&#x2F;erlang -progname erl – -home &#x2F;var&#x2F;lib&#x2F;rabbitmq – -pa &#x2F;usr&#x2F;lib&#x2F;rabbitmq&#x2F;lib&#x2F;rabbitmq_server-3.6.15&#x2F;ebin -noshell -noinput -s rabbi boot -sname rabbit@iZwz9ajwdnsg4s5368tvcpZ -boot start_sasl -kernel inet_default_connect_options [{nodelay,true}] -sasl errlog_type error -sasl sasl_error_logger false -rabbit error_logger {file,”&#x2F;var&#x2F;log&#x2F;rabbitmq&#x2F;<a href="mailto:&#114;&#97;&#98;&#x62;&#105;&#x74;&#x40;&#x69;&#x5a;&#x77;&#x7a;&#57;&#x61;&#106;&#119;&#x64;&#x6e;&#115;&#x67;&#52;&#x73;&#x35;&#51;&#54;&#56;&#x74;&#x76;&#x63;&#112;&#x5a;&#46;&#108;&#x6f;&#x67;">&#114;&#97;&#98;&#x62;&#105;&#x74;&#x40;&#x69;&#x5a;&#x77;&#x7a;&#57;&#x61;&#106;&#119;&#x64;&#x6e;&#115;&#x67;&#52;&#x73;&#x35;&#51;&#54;&#56;&#x74;&#x76;&#x63;&#112;&#x5a;&#46;&#108;&#x6f;&#x67;</a>“} -rabbit sasl_error_logger {file,”&#x2F;var&#x2F;log&#x2F;rabbitmq&#x2F;<a href="mailto:&#114;&#97;&#98;&#98;&#105;&#116;&#x40;&#x69;&#90;&#x77;&#x7a;&#57;&#x61;&#x6a;&#119;&#100;&#x6e;&#x73;&#103;&#x34;&#115;&#x35;&#51;&#x36;&#56;&#116;&#x76;&#x63;&#x70;&#x5a;&#x2d;&#115;&#97;&#115;&#x6c;&#x2e;&#x6c;&#111;&#103;">&#114;&#97;&#98;&#98;&#105;&#116;&#x40;&#x69;&#90;&#x77;&#x7a;&#57;&#x61;&#x6a;&#119;&#100;&#x6e;&#x73;&#103;&#x34;&#115;&#x35;&#51;&#x36;&#56;&#116;&#x76;&#x63;&#x70;&#x5a;&#x2d;&#115;&#97;&#115;&#x6c;&#x2e;&#x6c;&#111;&#103;</a>“} -rabbit enabled_plugins_file “&#x2F;etc&#x2F;rabbitmq&#x2F;enabled_plugins” -rabbit plugins_dir “&#x2F;usr&#x2F;lib&#x2F;rabbitmq&#x2F;plugins:&#x2F;usr&#x2F;lib&#x2F;rabbitmq&#x2F;lib&#x2F;rabbitmq_server-3.6.15&#x2F;plugins” -rabbit plugins_expand_dir “&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;mnesia&#x2F;rabbit@iZwz9ajwdnsg4s5368tvcpZ-plugins-expand” -os_mon start_cpu_sup false -os_mon start_disksup false -os_mon start_memsup false -mnesia dir “&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;mnesia&#x2F;rabbit@iZwz9ajwdnsg4s5368tvcpZ” -kernel inet_dist_listen_min 25672 -kernel inet_dist_listen_max 25672<br>  rabbitmq  1703     1  0 21:46 ?        00:00:00 &#x2F;usr&#x2F;lib&#x2F;erlang&#x2F;erts-7.3&#x2F;bin&#x2F;epmd -daemon<br>  rabbitmq  1811  1609  0 21:46 ?        00:00:00 inet_gethost 4<br>  rabbitmq  1812  1811  0 21:46 ?        00:00:00 inet_gethost 4<br>  root      2059   394  0 22:02 pts&#x2F;1    00:00:00 grep –color&#x3D;auto rabbit</p></li></ul><blockquote><p>注意：最新版本为了安全，默认只允许本地可访问，也就是说我们远程无法访问。还需要进行配置才行。</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我这里使用的是ubuntu的系统，登录远程服务器，cd &#x2F;etc&#x2F;rabbitmq&#x2F;下，</p><ul><li><p>新建rabbitmq.config文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> rabbitmq.config</span><br></pre></td></tr></table></figure><p>如果不知道如何写配置文件，还是参照官网<a href="http://www.rabbitmq.com/access-control.html">http://www.rabbitmq.com/access-control.html</a>完成自己的配置文件<br>配置文件的内容为：</p><p>  [{rabbit, [{loopback_users, []}]}].</p></li></ul><p>如果我们想有一个web端可视化操作界面，我们还需要配置插件,先进入到安全目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/lib/rabbitmq/bin/ </span><br><span class="line">$ ./rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><p>最后别忘记了重启你的rabbitmq</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ invoke-rc.d rabbitmq-server restart</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>重新你启动后：输入.&#x2F;rabbitmqctl status查看启动状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./rabbitmqctl status</span><br></pre></td></tr></table></figure><p>看到如下信息表示rabbitmq启动成功：</p><pre><code>Status of node rabbit@iZwz9ajwdnsg4s5368tvcpZ[&#123;pid,1616&#125;, &#123;running_applications,     [&#123;rabbitmq_management,&quot;RabbitMQ Management Console&quot;,&quot;3.6.15&quot;&#125;,      &#123;rabbitmq_web_dispatch,&quot;RabbitMQ Web Dispatcher&quot;,&quot;3.6.15&quot;&#125;,      &#123;rabbitmq_management_agent,&quot;RabbitMQ Management Agent&quot;,&quot;3.6.15&quot;&#125;,      &#123;rabbit,&quot;RabbitMQ&quot;,&quot;3.6.15&quot;&#125;,      &#123;cowboy,&quot;Small, fast, modular HTTP server.&quot;,&quot;1.0.4&quot;&#125;,      &#123;ranch,&quot;Socket acceptor pool for TCP protocols.&quot;,&quot;1.3.2&quot;&#125;,      &#123;ssl,&quot;Erlang/OTP SSL application&quot;,&quot;7.3&quot;&#125;,      &#123;public_key,&quot;Public key infrastructure&quot;,&quot;1.1.1&quot;&#125;,      &#123;os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.4&quot;&#125;,      &#123;amqp_client,&quot;RabbitMQ AMQP Client&quot;,&quot;3.6.15&quot;&#125;,      &#123;rabbit_common,          &quot;Modules shared by rabbitmq-server and rabbitmq-erlang-client&quot;,          &quot;3.6.15&quot;&#125;,      &#123;compiler,&quot;ERTS  CXC 138 10&quot;,&quot;6.0.3&quot;&#125;,      &#123;inets,&quot;INETS  CXC 138 49&quot;,&quot;6.2&quot;&#125;,      &#123;cowlib,&quot;Support library for manipulating Web protocols.&quot;,&quot;1.0.2&quot;&#125;,      &#123;crypto,&quot;CRYPTO&quot;,&quot;3.6.3&quot;&#125;,      &#123;asn1,&quot;The Erlang ASN1 compiler version 4.0.2&quot;,&quot;4.0.2&quot;&#125;,      &#123;recon,&quot;Diagnostic tools for production use&quot;,&quot;2.3.2&quot;&#125;,      &#123;mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.13.3&quot;&#125;,      &#123;syntax_tools,&quot;Syntax tools&quot;,&quot;1.7&quot;&#125;,      &#123;xmerl,&quot;XML parser&quot;,&quot;1.3.10&quot;&#125;,      &#123;sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.7&quot;&#125;,      &#123;stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;2.8&quot;&#125;,      &#123;kernel,&quot;ERTS  CXC 138 10&quot;,&quot;4.2&quot;&#125;]&#125;, &#123;os,&#123;unix,linux&#125;&#125;, &#123;erlang_version,     &quot;Erlang/OTP 18 [erts-7.3] [source] [64-bit] [async-threads:64] [kernel-poll:true]\n&quot;&#125;, &#123;memory,     [&#123;connection_readers,0&#125;,      &#123;connection_writers,0&#125;,      &#123;connection_channels,0&#125;,      &#123;connection_other,2592&#125;,      &#123;queue_procs,2592&#125;,      &#123;queue_slave_procs,0&#125;,      &#123;plugins,719912&#125;,      &#123;other_proc,21169952&#125;,      &#123;metrics,51816&#125;,      &#123;mgmt_db,145272&#125;,      &#123;mnesia,58224&#125;,      &#123;other_ets,2325224&#125;,      &#123;binary,59168&#125;,      &#123;msg_index,40704&#125;,      &#123;code,27779661&#125;,      &#123;atom,1000601&#125;,      &#123;other_system,4364826&#125;,      &#123;allocated_unused,16974432&#125;,      &#123;reserved_unallocated,0&#125;,      &#123;total,72642560&#125;]&#125;, &#123;alarms,[]&#125;, &#123;listeners,[&#123;clustering,25672,&quot;::&quot;&#125;,&#123;amqp,5672,&quot;::&quot;&#125;,&#123;http,15672,&quot;::&quot;&#125;]&#125;, &#123;vm_memory_calculation_strategy,rss&#125;, &#123;vm_memory_high_watermark,0.4&#125;, &#123;vm_memory_limit,838947635&#125;, &#123;disk_free_limit,50000000&#125;, &#123;disk_free,36661555200&#125;, &#123;file_descriptors,     [&#123;total_limit,924&#125;,&#123;total_used,2&#125;,&#123;sockets_limit,829&#125;,&#123;sockets_used,0&#125;]&#125;, &#123;processes,[&#123;limit,1048576&#125;,&#123;used,321&#125;]&#125;, &#123;run_queue,0&#125;, &#123;uptime,602&#125;, &#123;kernel,&#123;net_ticktime,60&#125;&#125;]</code></pre><h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><p>在浏览器段查看rabbit的后台管理界面：</p><ul><li><p>首先，在自己的系统防火墙的端口号，后台管理界面的访问端口是15672,因此需要在执行以下命令开放该端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --add-port=15672/tcp --zone=public --permanent</span><br><span class="line"></span><br><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>由于我的服务器是阿里云的ubuntu，因此需要登陆阿里云，进入你的管理控制台安全组入口配置规则，开放端口，在浏览器输入以下地址，便可访问后台管理界面。</p><pre><code>  你的服务器公网地址:15672</code></pre></li></ul><p>效果如下:<br><img src="http://120.78.190.213/images/tomcat.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> linux </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate中get()和load()的区别</title>
      <link href="/2018/06/03/Hibernate%E4%B8%ADget()%E5%92%8Cload()%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/06/03/Hibernate%E4%B8%ADget()%E5%92%8Cload()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>最近面试中遇到了关于hibernate中get()和load()两个方法的区别,我在论坛看到了各种论述，我总结了他们的观点以及自己的理解来简单说明下，如果有哪里不对的地方欢迎指正。</p><span id="more"></span><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>首先要清楚一点的是get()和load()方法都是hibernate中session中获取实体对象两个方法,如果是get()方法加载实体对象，但是如果加载对象失败的话，那么结果会返回为null，而通过load()方式加载实体对象，加载不到的数据话便会抛出ObjectNotFoundException。</p><hr><h2 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h2><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get( )方法"></a>get( )方法</h3><p>对于get( )方法，hibernate会确认一下该id对应的数据是否存在，首先会在session一级缓存中查找，如果在session缓存中找到了该id对应的对象；</p><ul><li><p>如果刚好该对象前面是被代理过的，如被load方法使用过，或者被其他关联对象延迟加载过，那么返回的还是原先的代理对象，而不是实体类对象;</p></li><li><p>如果该代理对象还没有加载实体数据（就是id以外的其他属性数据），那么它会查询二级缓存或者数据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据;</p></li><li><p>如果该id对应的对象并且不是被延迟加载的代理对象，或者在session缓存中没有找到该对象，则查找二级缓存</p></li></ul><p>如果二级缓存中没有的话，就会直接发送sql语句去数据库查询数据返回实体对象，如果数据库中也没有就返回null。</p><h3 id="load-方法"><a href="#load-方法" class="headerlink" title="load()方法"></a>load()方法</h3><p>对于load方法加载实体对象的时，会根据*.hbm.xml映射文件上类级别的lazy属性的配置(默认为true)选择加载方式；</p><ul><li><p>若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)，这个代理对象只保存了实体对象的id值，当我们使用该对象的其他属性值时就会查找二级缓存，二级缓存没有就发出sql语句去数据库查找数据，如果数据库仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。这也是我们时常所说的**延迟加载 **</p></li><li><p>若为false，就跟get( )方法加载顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException;</p></li></ul><hr><h2 id="使用get-和load-时的注意事项"><a href="#使用get-和load-时的注意事项" class="headerlink" title="使用get( )和load( )时的注意事项"></a>使用get( )和load( )时的注意事项</h2><p>当我们了解了load和get的加载机制以后，在以后使用过程后需要注意一些问题：</p><ul><li><p>如果使用get方式来加载对象，当我们试图得到一个id不存在的对象时，此时会报NullPointException,这是因为通过get( )方式加载实体对象时候，我们会去数据库中查询出该对象，但是这个id值不存在，所以此时实体对象是null，也就会报NullPointException。</p></li><li><p>如果使用load方式来加载对象，当我们试图得到一个id不存在的实体对象时，此时会报ObjectNotFoundException，为什么使用load的方式和get的方式来得到一个不存在的对象报的异常不同呢？？其原因还是因为load的延迟加载机制，使用load()时，此时的实体对象是一个代理对象，仅仅保存了当前的这个id值，当我们试图得到该对象的其他属性时，这个属性其实是为空，所以就会报ObjectNotFoundException</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之对于get( )和load( )的根本区别，一句话，hibernate对于load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get( )方法，hibernate一定要获取到真实的数据，否则返回null。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA的使用</title>
      <link href="/2018/06/03/IntelliJ-idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/03/IntelliJ-idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言，对于这样一个强大的代码编辑器，我们势必要了解他的快捷键操作，方便我们快速的编写实现代码。</p><span id="more"></span><h2 id="快捷键的使用"><a href="#快捷键的使用" class="headerlink" title="快捷键的使用"></a>快捷键的使用</h2><blockquote><p>注意：以下快捷键的使用仅针对于Windows平台的操作，对于MAC和LINUX大家自己对照windows平台idea的使用</p></blockquote><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><ul><li>项目之间的跳转（项目分别位于不同的idea窗口）：<br>  Ctrl + Alt + [ : 跳转到上一个idea窗口<br>  Ctrl + Alt + ] : 跳转到下一个idea窗口</li><li>文件之间的跳转<br>  Ctrl + E : 多个文件之间的跳转（最近打开文件）<br>  Ctrl + Shift + E : 多个文件之间的跳转（最近编辑修改文件）</li><li>浏览修改位置的跳转<br>  Ctrl + Shift + BackSpace : 跳转到上一次编辑的文件 </li><li>浏览位置的跳转<br>  Ctrl + Alt + ← : 跳转到上一次浏览文件的位置<br>  Ctrl + Alt + → : 跳转到下一次浏览文件的位置</li><li>最近两个文件之间的跳转（windows自带）<br>  Ctrl + Tab : 最近两个文件之间随意切换</li><li>根据书签进行跳转<br>  首先要针对你要标记的代码行作为书签，F11或者Ctrl + F11,其中后者可以使用数字进行标记，但我们要跳转的时候就可以<br>   使用Ctrl + 你标记的数字 进行跳转定位</li><li>使用收藏夹<br>   通过Shift + Alt + F : 可以将当前文件（类），当前函数方法 加入到收藏列表<br>   然后Alt + 2 : 可以打开你的收藏的文件和书签</li><li>字符跳转插件emacsIDEAs跳转<br>  1.首先要安装这个插件，自行安装<br>  2.设置快捷键</li><li>编辑区和文件区的来回跳转<br>  Alt + 1 : 通过右边的编辑区定位该文件在文件区的位置</li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li>通过输入类名称搜索<br>  Ctrl + N : 通过输入类名称搜索类文件，如果要搜索jar包里面的类，直接勾选上include non-project classes即可</li><li>通过输入文件名搜索<br>  Ctrl + Shift + N : 通过输入文件名称搜索文件，如果要搜索jar包里面的文件，直接勾选上include non-project classes即可</li><li>通过输入字符串搜索<br>  Ctrl + Shift + Alt + N : 通过输入字符串搜索（这里的字符串可以是函数，属性，类名，其他文件名称），如果要搜索jar包里面的内容，直接勾选上include non-project symbols即可</li><li>通过输入查找普通字符串<br>  Ctrl + Shift + F ：通过输入字符串搜索所有的东西</li></ul><h3 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h3><ul><li>列选<br> Ctrl + Shift + Alt + J : 列选</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ idea </tag>
            
            <tag> jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap-table分页删除尾页数据后刷新无数据问题</title>
      <link href="/2018/06/03/ubuntu16.04.3%E5%AE%89%E8%A3%85rabbitmq%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/06/03/ubuntu16.04.3%E5%AE%89%E8%A3%85rabbitmq%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们使用bootstrap-table做表格分页展示的时候，当我们删除最后一页数据的时候，刷新数据发现无数据展示, 针对这种问题，我们有三种解决方式；</p></blockquote><span id="more"></span><h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ </span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootstrap-table </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/03/hello-world/"/>
      <url>/2018/06/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><span id="more"></span><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git右键没有Git Bash Here的解决办法</title>
      <link href="/2018/06/02/Git%E5%8F%B3%E9%94%AE%E6%B2%A1%E6%9C%89Git-Bash-Here%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/06/02/Git%E5%8F%B3%E9%94%AE%E6%B2%A1%E6%9C%89Git-Bash-Here%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>大家经常会遇到的一个问题，大家在安装git完成的时候，一般用鼠标右键就可以看到Git Bash Here和Git Gui这两个选项，但是有时候安装git后并没有两个选项，这里我们将要介绍如何配置Git Bash Here这个命令。</p><span id="more"></span><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>对于各位右键看不到这个命令，出现这个问题的原因，主要是我在安装git的时候，安装路径没有在C盘下，安装在C盘下系统就会自动帮你创建这个命令，再右键就能看到这两个命令，如果你的git安装在其他盘符下，那么就需要你自己完成手动配置。</p><h4 id="1-打开注册表"><a href="#1-打开注册表" class="headerlink" title="1.打开注册表"></a>1.打开注册表</h4><p>（win按键+R打开运行小窗口）在“运行”中输入‘regedit’，打开注册表。</p><h4 id="2-创建shell文件夹"><a href="#2-创建shell文件夹" class="headerlink" title="2.创建shell文件夹"></a>2.创建shell文件夹</h4><p>在注册表编辑器界面  HKEY_CLASSES_ROOT\Directory\Background\shell中进行设置，如果Background目录下没有shell文件夹就新建shell文件夹。</p><h4 id="3-新建项"><a href="#3-新建项" class="headerlink" title="3.新建项"></a>3.新建项</h4><p>在shell目录下 新建项 Git Bash Here，此时点击鼠标右键菜单会出现“Git Bush Here”选项，但是你继续点击她，还不会打开git命令块。</p><h4 id="4-添加图标"><a href="#4-添加图标" class="headerlink" title="4.添加图标"></a>4.添加图标</h4><p>到此时你会发现右键没有图标，我们可以给右键 Git Bush Here 快捷方式添加一个 Icon，这样看起来就美观很多，在Git Bash Here 项下 新建字符串值 Icon 然后编辑Icon 值 ，E:\Git\mingw64\share\git\git-for-windows.ico ，注意：需要根据安装的Git真实目录进行配置。</p><h4 id="5-新建Command项"><a href="#5-新建Command项" class="headerlink" title="5.新建Command项"></a>5.新建Command项</h4><p>在 Git Bash Here  下新建Command项，随后修改Command项的默认值修改为 E:\Git\bin\bash.exe –login -i，注意：需要根据安装的Git真实目录进行配置。 此时你可以放心的使用Git Bush Here快捷方式了。<br><img src="/Git%E5%8F%B3%E9%94%AE%E6%B2%A1%E6%9C%89Git-Bash-Here%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/git-bash-here.png" alt="如图所示"></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解的原理和应用</title>
      <link href="/2018/05/03/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/"/>
      <url>/2018/05/03/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>注解（Annotation）也叫元数据,即一种描述数据的数据，一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明。</p><span id="more"></span><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><p>一般的注解护照要分为三类：</p><h4 id="Java自带的标准注解"><a href="#Java自带的标准注解" class="headerlink" title="Java自带的标准注解"></a>Java自带的标准注解</h4><p>Java自带的标准注解主要包括包括@Override、@Deprecated和@SuppressWarnings三类，用这些注解标明后编译器就会进行检查；</p><ul><li>@Override 用于标明重写某个方法；</li><li>@Deprecated 用于标明某个类或方法过时、标明要忽略的警告；</li><li>@SuppressWarnings 用于申明要忽略的警告；</li></ul><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解是用于定义注解的注解，主要包括@Retention、@Target、@Inherited、@Documented四个；</p><ul><li>@Retention 用于标明注解被保留的阶段;</li><li>@Target  用于标明注解使用的范围;</li><li>@Inherited 用于标明注解可继承;</li><li>@Documented   用于标明是否生成javadoc文档；</li></ul><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>自定义注解，程序员可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p><h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>它主要的作用有以下四方面：</p><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>注解的使用大体分为三部分：定义注解，使用注解和解析注解，标准注解非常简单，大家可以自己实现，同时现在存在很多的java框架（Spring,SpringBoot,SpringCloud,Hibernate）中间的注解，大家使用的比较多，框架中的注解一般已经做好注解的定义和注解的解析，我们程序员只需要使用它就是了，这里主要说明自定义注解的使用。</p><h4 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h4><p>注解的定义通过@interface定义，然后在注解内部可以定义方法，很类似接口中的方法，但是在注解中他是一个成员变量，定义成员变量要遵守一些规则：<br>1.成员类型是受限制的，合法的类型包括基本的数据类型以及String，Class，Annotation,Enumeration等。<br>2.如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（&#x3D;）。<br>3.注解类可以没有成员，没有成员的注解称为标识注解<br>现在我们定义一个在方法上注解，里面有两个String类型的成员变量</p><pre><code>@Documented@Target(ElementType.METHOD)@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface AuthorAPI &#123;    String author() default &quot;whd&quot;;    String comments() default  &quot;no comments&quot;;    int age() default 23;&#125;</code></pre><h4 id="注解的使用-1"><a href="#注解的使用-1" class="headerlink" title="注解的使用"></a>注解的使用</h4><pre><code>public class UseAnnotation &#123;    @AuthorAPI    public void getInfo(String name)&#123;        System.out.println(name);    &#125;    @AuthorAPI(author = &quot;mtt&quot;, comments = &quot;you are pretty good&quot;, age = 20)    public void getDetail(String name)&#123;        System.out.println(name);    &#125;    public void getInfomation(String name)&#123;        System.out.println(name);    &#125;&#125;</code></pre><h4 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h4><pre><code>public class TestAnnotation &#123;    public static void main(String[] args) &#123;        getSomeAuthorInfo(UseAnnotation.class);    &#125;    private static void getSomeAuthorInfo(Class&lt;?&gt; clazz)  &#123;        Method[] methods = clazz.getDeclaredMethods();        for (Method method : methods) &#123;            if (method.isAnnotationPresent(AuthorAPI.class))&#123;                AuthorAPI annotation = method.getDeclaredAnnotation(AuthorAPI.class);                System.out.println(annotation.author() +&quot; &quot;+ annotation.comments() +&quot; &quot;+ annotation.age());                try &#123;                    method.invoke(new UseAnnotation(), &quot;hello, baby&quot;);                &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果：</p><pre><code>mtt you are pretty good 20hello, babywhd no comments 23hello, baby</code></pre><p>我们发现只有添加AuthorAPI注解的方法才能获取到注解成员变量的值，当然你也可以实现其他的逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用nginx搭建图片服务器</title>
      <link href="/2017/10/15/%E5%88%A9%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/10/15/%E5%88%A9%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;大家经常在做项目的时候，特别是javaweb服务，对于图片等静态文件的处理都是放在项目里面的，这种方式在小型系统中是没有问题的，但是随着业务地不断增加，图片数量地增加，应用服务器的性能就会大幅度减小, 为了缓解应用服务器的压力, 搭建一个专门用来存储图片等静态资源的服务器是必须的，接下来就会教大家如何搭建一个图片服务器。</p><span id="more"></span><h2 id="图片服务器的现状"><a href="#图片服务器的现状" class="headerlink" title="图片服务器的现状"></a>图片服务器的现状</h2>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片服务器 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性之Optional</title>
      <link href="/2017/09/15/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/"/>
      <url>/2017/09/15/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在我们的开发中，NullPointerException可谓是所有java程序员随时随处可见的一种异常，为了避免空指针异常，我们常常需要进行非空检查，如果你厌倦了空指针异常，可以考虑使用java8的Optional,它能够让你的代码更具有可读性，并保护其不受空指针异常的影响。</p><span id="more"></span><blockquote><p><a href="https://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html">英语比较好的话可以看官方原文</a></p></blockquote><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>一位智者曾经说过，除非你处理过空指针异常，否则你不是一个真正的Java程序员。顺便说一句，null引用是许多问题的根源，因为它通常用于表示没有值，其实早在在Google Guava 中就有Optional，在Swift语言中也有这样类似的语法，因此Java SE 8引入了一个名为Java.util.Optional的新类，用来减轻这些问题。</p><h3 id="2-类的说明"><a href="#2-类的说明" class="headerlink" title="2.类的说明"></a>2.类的说明</h3><h4 id="2-1-类中的所有属性和方法"><a href="#2-1-类中的所有属性和方法" class="headerlink" title="2.1 类中的所有属性和方法"></a>2.1 类中的所有属性和方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Optional</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common instance for &#123;<span class="doctag">@code</span> empty()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If non-null, the value; if null, indicates no value is present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an empty &#123;<span class="doctag">@code</span> Optional&#125; instance.  No value is present for this</span></span><br><span class="line"><span class="comment">     * Optional.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an instance with the value present.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an &#123;<span class="doctag">@code</span> Optional&#125; with the specified present non-null value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an &#123;<span class="doctag">@code</span> Optional&#125; describing the specified value, if non-null,</span></span><br><span class="line"><span class="comment">     * otherwise returns an empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present in this &#123;<span class="doctag">@code</span> Optional&#125;, returns the value,</span></span><br><span class="line"><span class="comment">     * otherwise throws &#123;<span class="doctag">@code</span> NoSuchElementException&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Optional#isPresent()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return &#123;<span class="doctag">@code</span> true&#125; if there is a value present, otherwise &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, invoke the specified consumer with the value,</span></span><br><span class="line"><span class="comment">     * otherwise do nothing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">            consumer.accept(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is pre``sent, and the value matches the given predicate,</span></span><br><span class="line"><span class="comment">     * return an &#123;<span class="doctag">@code</span> Optional&#125; describing the value, otherwise return an</span></span><br><span class="line"><span class="comment">     * empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, apply the provided mapping function to it,</span></span><br><span class="line"><span class="comment">     * and if the result is non-null, return an &#123;<span class="doctag">@code</span> Optional&#125; describing the</span></span><br><span class="line"><span class="comment">     * result.  Otherwise return an empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> This method supports post-processing on optional values, without</span></span><br><span class="line"><span class="comment">     * the need to explicitly check for a return status.  For example, the</span></span><br><span class="line"><span class="comment">     * following code traverses a stream of file names, selects one that has</span></span><br><span class="line"><span class="comment">     * not yet been processed, and then opens that file, returning an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Optional&lt;FileInputStream&gt;&#125;:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     *     Optional&lt;FileInputStream&gt; fis =</span></span><br><span class="line"><span class="comment">     *         names.stream().filter(name -&gt; !isProcessedYet(name))</span></span><br><span class="line"><span class="comment">     *                       .findFirst()</span></span><br><span class="line"><span class="comment">     *                       .map(name -&gt; new FileInputStream(name));</span></span><br><span class="line"><span class="comment">     * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(mapper);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, apply the provided &#123;<span class="doctag">@code</span> Optional&#125;-bearing</span></span><br><span class="line"><span class="comment">     * mapping function to it, return that result, otherwise return an empty</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Optional&#125;.  This method is similar to &#123;<span class="doctag">@link</span> #map(Function)&#125;,</span></span><br><span class="line"><span class="comment">     * but the provided mapper is one whose result is already an &#123;<span class="doctag">@code</span> Optional&#125;,</span></span><br><span class="line"><span class="comment">     * and if invoked, &#123;<span class="doctag">@code</span> flatMap&#125; does not wrap it with an additional</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(mapper);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the value if present, otherwise return &#123;<span class="doctag">@code</span> other&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment">     * the result of that invocation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the contained value, if present, otherwise throw an exception</span></span><br><span class="line"><span class="comment">     * to be created by the provided supplier.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> A method reference to the exception constructor with an empty</span></span><br><span class="line"><span class="comment">     * argument list can be used as the supplier. For example,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> IllegalStateException::new&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether some other object is &quot;equal to&quot; this Optional. The</span></span><br><span class="line"><span class="comment">     * other object is considered equal if:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;it is also an &#123;<span class="doctag">@code</span> Optional&#125; and;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;both instances have no value present or;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;the present values are &quot;equal to&quot; each other via &#123;<span class="doctag">@code</span> equals()&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Optional)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(value, other.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the hash code value of the present value, if any, or 0 (zero) if</span></span><br><span class="line"><span class="comment">     * no value is present.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a non-empty string representation of this Optional suitable for</span></span><br><span class="line"><span class="comment">     * debugging. The exact presentation format is unspecified and may vary</span></span><br><span class="line"><span class="comment">     * between implementations and versions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span> If a value is present the result must include its string</span></span><br><span class="line"><span class="comment">     * representation in the result. Empty and present Optionals must be</span></span><br><span class="line"><span class="comment">     * unambiguously differentiable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span></span><br><span class="line">            ? String.format(<span class="string">&quot;Optional[%s]&quot;</span>, value)</span><br><span class="line">            : <span class="string">&quot;Optional.empty&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-属性和方法解释"><a href="#2-2-属性和方法解释" class="headerlink" title="2.2 属性和方法解释"></a>2.2 属性和方法解释</h4><p>建议大家在学习新的知识的时候，先打开源码看看每个方法的注释说明，介绍了每个方法的作用，刚开始英语不好没关系，看得多了慢慢就会适应了，所以英语对程序员来讲是一个很重要的技能喔，接下来我们看哈每个方法的作用。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public static <T> Optional<T> of(T value)</td><td>把指定的值封装为Optional对象，如果指定的值为null，则抛出NullPointerException</td></tr><tr><td>public static<T> Optional<T> empty()</td><td>创建一个空的Optional对象</td></tr><tr><td>public static <T> Optional<T> ofNullable(T value)</td><td>把指定的值封装为Optional对象，如果指定的值为null，则创建一个空的Optional对象</td></tr><tr><td>public T get()</td><td>如果创建的Optional中有值存在，则返回此值，否则抛出NoSuchElementException</td></tr><tr><td>public T orElse(T other)</td><td>如果创建的Optional中有值存在，则返回此值，否则返回一个默认值</td></tr><tr><td>public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td>如果创建的Optional中有值存在，则返回此值，否则返回一个由Supplier接口生成的值</td></tr><tr><td>public <X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</td><td>如果创建的Optional中有值存在，则返回此值，否则抛出一个由指定的Supplier接口生成的异常</td></tr><tr><td>public Optional<T> filter(Predicate&lt;? super T&gt; predicate)</td><td>如果创建的Optional中的值满足filter中的条件，则返回包含该值的Optional对象，否则返回一个空的Optional对象</td></tr><tr><td>public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td>如果创建的Optional中的值存在，对该值执行提供的Function函数调用</td></tr><tr><td>public<U> Optional<U> flatMap(Function&lt;? super T, Optional<U>&gt; mapper)</td><td>如果创建的Optional中的值存在，就对该值执行提供的Function函数调用，返回一个Optional类型的值，否则就返回一个空的Optional对象</td></tr><tr><td>public boolean isPresent()</td><td>如果创建的Optional中的值存在，返回true，否则返回false</td></tr><tr><td>public void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>如果创建的Optional中的值存在，则执行该方法的调用，否则什么也不做</td></tr></tbody></table><h3 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3.基本使用"></a>3.基本使用</h3><h4 id="3-1-对象创建"><a href="#3-1-对象创建" class="headerlink" title="3.1 对象创建"></a>3.1 对象创建</h4><ul><li>创建一个空对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空的Optional&lt;User&gt;对象</span></span><br><span class="line">Optional&lt;User&gt; optStr = Optional.empty();</span><br></pre></td></tr></table></figure></li><li>创建对象：不允许为空<br>Optional提供了方法of()用于创建非空对象，该方法要求传入的参数不能为空，否则抛NullPointException，示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当user为null的时候，将抛出NullPointException</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optionals =  Optional.of(user); </span><br></pre></td></tr></table></figure><img src="http://120.78.190.213/images/learn-java8/optional-of.png" alt="如图示例"></li><li>创建对象：允许为空<br>如果不能确定传入的参数是否存在null值的可能性，则可以用Optional的ofNullable()方法创建对象，如果入参为null，则创建一个空对象。示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果user是null，则创建一个空对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optStr = Optional.ofNullable(user);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-存在则返回"><a href="#3-2-存在则返回" class="headerlink" title="3.2 存在则返回"></a>3.2 存在则返回</h4><ul><li>get() 如果创建的Optional中有值存在，则返回此值，否则抛出NoSuchElementException，示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optional2 = Optional.ofNullable(user);</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> optional2.get();</span><br></pre></td></tr></table></figure><img src="http://120.78.190.213/images/learn-java8/optional-get.png" alt="如图示例"></li><li>orElse(T other) 如果创建的Optional中有值存在，则返回此值，否则返回一个默认值（默认值就是入参参入的值，这里传入null），示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optional2 = Optional.ofNullable(user);</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> optional2.orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><img src="http://120.78.190.213/images/learn-java8/optional-orElse.png" alt="如图示例"></li><li>orElseGet(Supplier&lt;? extends T&gt; other) 如果创建的Optional中有值存在，则返回此值，否则返回一个由Supplier接口生成的值（这个生成的值可为空），示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> optional2.orElseGet(() -&gt; <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user3: &quot;</span> + user3);</span><br></pre></td></tr></table></figure><img src="http://120.78.190.213/images/learn-java8/optional-orElseGet.png" alt="如图示例"></li><li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)  如果创建的Optional中有值存在，则返回此值，否则抛出一个由指定的Supplier接口生成的异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> optional2.orElseThrow(() -&gt; <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user4: &quot;</span> + user4);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-Streams"><a href="#3-3-Streams" class="headerlink" title="3.3 Streams"></a>3.3 Streams</h4>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之线程顺序执行</title>
      <link href="/2017/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/"/>
      <url>/2017/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;我们知道在多线程中，线程在启动的时候不是马上去执行任务的，而是由cpu调度让哪一个线程执行，通常情况下多线程的执行顺序是随机的，如果我们想要让线程按照一定的顺序让线程执行，怎么做呢？</p><span id="more"></span><h3 id="1-初见"><a href="#1-初见" class="headerlink" title="1.初见"></a>1.初见</h3><p>首先我们先上一段代码,看看执行效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如图所示：<br><img src="http://120.78.190.213/images/multithread/multithread-orderexecute.png" alt="如图示"><br>从代码运行结果看，线程执行的顺序是随机的，我们无法保证线程按照特定的顺序执行，线程启动之后处于就绪状态，等待CPU调度执行，也就是说如果不做处理话，我们是无法控制的。</p><h3 id="2-相恋"><a href="#2-相恋" class="headerlink" title="2.相恋"></a>2.相恋</h3><h4 id="2-1-设置线程优先级"><a href="#2-1-设置线程优先级" class="headerlink" title="2.1 设置线程优先级"></a>2.1 设置线程优先级</h4><p>线程的执行除了CPU调度外，还有一个因素就是每个线程的优先级，线程的级别有1-10个等级，级别越高表示线程越有可能拿到CPU时间片，但是并不是优先级越高的线程就一定比优先级低的线程更早获得CPU时间片执行任务呢，按但是否定的，我们只能说优先级高的线程更有可能获取的执行权，如果说优先级高的进入了等待，那么优先级低的线程就会执行，如果几个线程都处于就组状态，那毫无疑问优先级高的线程就会先执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">thread3.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">thread2.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">thread1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line">thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-priority.png" alt="如图示"></p><h4 id="2-2-Thread-join"><a href="#2-2-Thread-join" class="headerlink" title="2.2 Thread.join()"></a>2.2 Thread.join()</h4><p>我们Thread.join()方法就是让主线程等待，新线程执行完了后再继续执行主线程，让我们来看一下Thread.join()方法的源码吧<br>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>源码很清晰的告诉我们，当我们调用join()方法后，后调用join(long millis)，在millis &#x3D;&#x3D; 0的情况下，如果当前线程是存活的，就让当前线程等待，让新线程继续执行知道死亡，知道原理后就来实现下代码喔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.join();</span><br><span class="line">    thread3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-join.png"></p><h4 id="2-3-Executors-newSingleThreadExecutor"><a href="#2-3-Executors-newSingleThreadExecutor" class="headerlink" title="2.3 Executors.newSingleThreadExecutor()"></a>2.3 Executors.newSingleThreadExecutor()</h4><p>Executors.newSingleThreadExecutor()就是创建一个只有一个线程线程池，让我们看了一个源码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到Executors.newSingleThreadExecutor()实际上是创建了一个单线程的线程池，并且维护了一个任务队列，我们知道队列的特点就是FIFO(先进先出)，而且线程池每次只能执行一个任务线程，其余的线程实际上放到new LinkedBlockingQueue<Runnable>()这个队列里等待CPU调度，当第一个线程执行完了后，线程池就会从队列取下一个任务线程来执行，以此类推，从而保证了线程的执行顺序，来看看代码怎么实现的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread1 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread2 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;thread3 开始执行&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    service.execute(thread1);</span><br><span class="line">    service.execute(thread2);</span><br><span class="line">    service.execute(thread3);</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://120.78.190.213/images/multithread/multithread-orderexecute-executors.png"></p><h3 id="婚恋"><a href="#婚恋" class="headerlink" title="婚恋"></a>婚恋</h3><p>以上就是控制多线程执行顺序方法，有什么不对欢迎指正喔。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
